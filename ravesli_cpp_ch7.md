# Глава №7.
## Урок №102. Параметры и аргументы функций
### Параметры vs. Аргументы
**Параметр функции** (или **"формальный параметр"**) — это переменная,\
создаваемая в объявлении функции:
```c++
void boo(int x); // объявление (прототип функции). x - это параметр
void boo(int x) // определение (также объявление). x - это параметр
{
}
```

**Аргумент** (или **"фактический параметр"**) — это значение, которое передает в\
функцию вызывающий объект (caller):
```c++
boo(7); // 7 - это аргумент, который передается в параметр x
boo(y+1); // выражение y+1 - это аргумент, который передается в параметр x
```

## Урок №103. Передача по значению
По умолчанию, аргументы в C++ передаются по значению. Когда аргумент\
**передается по значению**, то его значение копируется в параметр функции:
```c++
#include <iostream>

void boo(int y) {
    std::cout << "y = " << y << std::endl;
}

int main() {
    boo(7); // 1-й вызов - y = 7
    
    int x = 8;
    boo(x); // 2-й вызов - 7 = 8
    boo(x + 2); // 3-й вызов - y = 10
    
    return 0;
}
```

### Плюсы и минусы передачи по значению
**Плюсы передачи по значению:**
* Аргументы, переданные по значению, могут быть переменными (например,\
  `x`), литералами (например, `8`), выражениями (например, `x + 2`),\
  структурами, классами или перечислителями (т.е. почти всем, чем угодно).
* Аргументы никогда не изменяются функцией, в которую передаются, что\
  предотвращает возникновение побочных эффектов.

**Минусы передачи по значению:**
* Копирование структур и классов может привести к значительному\
  снижению производительности (особенно, когда функция вызывается\
  много раз).

**Когда использовать передачу по значению:**
* При передаче фундаментальных типов данных и перечислителей, когда\
  предполагается, что функция не должна изменять аргумент.

**Когда не использовать передачу по значению:**
* При передаче массивов, структур и классов.

## Урок №104. Передача по ссылке
### Передача по ссылке
При **передаче переменной по ссылке** нужно просто объявить параметры функции\
как ссылки, а не как обычные переменные:
```c++
void func(int &x) { // x - это переменная-ссылка
    x = x + 1;
}
```

### Возврат сразу нескольких значений
Одним из способов возврата сразу нескольких значений является **использование\
ссылок в качестве параметров**:
```c++
#include <iostream>
#include <math.h> // для sin() и cos()

void getSinCos(double degrees, double &sinOut, double &cosOut) {
    // sin() и cos() принимают радианы, а не градусы, поэтому необходима конвертация
    const double pi = 3.14159265358979323846; // значение Пи
    double radians = degrees * pi / 180.0;
    sinOut = sin(radians);
    cosOut = cos(radians);
}

int main() {
    double sin(0.0);
    double cos(0.0);

    // Функция getSinCos() возвратит sin и cos в переменные sin и cos
    getSinCos(30.0, sin, cos);

    std::cout << "The sin is " << sin << '\n'; // The sin is 0.5
    std::cout << "The cos is " << cos << '\n'; // The cos is 0.866025

    return 0;
}
```
Параметры, которые используются только для возврата значений обратно в\
caller, называются **параметрами вывода**.

В caller-е не очевидно, что `sin` и `cos` являются параметрами вывода,\
и они будут изменены функцией. Поэтому **не рекомендуется смешивать параметры\
ввода и вывода** именно по этой причине.

### Передача по константной ссылке
Когда мы знаем, что функция не должна изменять значение аргумента, но\
не хотим использовать передачу по значению, то лучшим решением будет\
использовать **передачу по константной ссылке**.\
Так как константная ссылка — это ссылка на переменную, значение которой\
изменить через эту же ссылку не получится никак. Следовательно, если мы\
используем константную ссылку в качестве параметра, то получаем 100% гарантию\
того, что функция не изменит аргумент:
```c++
void boo(const int &y) { // y - это константная ссылка
    y = 8; // ошибка компиляции: константная ссылка не может изменить свое же значение!
}
```

**Правило: При передаче аргументов по ссылке всегда используйте константные\
ссылки, если вам не нужно, чтобы функция изменяла значения аргументов.**

### Плюсы и минусы передачи по ссылке
**Плюсы передачи по ссылке:**
* Ссылки позволяют функции изменять значение аргумента, что иногда\
  полезно. В противном случае, для гарантии того, что функция не изменит\
  значение аргумента, нужно использовать константные ссылки.
* Поскольку при передаче по ссылке копирования аргументов не происходит,\
  то этот способ гораздо эффективнее и быстрее передачи по значению,\
  особенно при работе с большими структурами или классами.
* Ссылки могут использоваться для возврата сразу нескольких значений из\
  функции (через параметры вывода).

**Минусы передачи по ссылке:**
* Трудно определить, является ли параметр, переданный по неконстантной\
  ссылке, параметром ввода, вывода или того и другого одновременно.\
  Разумное использование const и суффикса Out для внешних переменных\
  решает эту проблему.
* По вызову функции невозможно определить, будет аргумент изменен\
  функцией или нет. Аргумент, переданный по значению или по ссылке,\
  выглядит одинаково. Мы можем определить способ передачи аргумента\
  только просмотрев объявление функции. Это может привести к ситуации,\
  когда программист не сразу поймет, что функция изменяет значение\
  аргумента.

**Когда использовать передачу по ссылке:**
* при передаче структур или классов (используйте const, если нужно только для\
  чтения);
* когда нужно, чтобы функция изменяла значение аргумента.

**Когда не использовать передачу по ссылке:**
* при передаче фундаментальных типов данных (используйте передачу по\
  значению);
* при передаче обычных массивов (используйте передачу по адресу).

## Урок №105. Передача по адресу
### Передача по адресу
**Передача аргументов по адресу** — это передача адреса переменной-аргумента (а\
не исходной переменной). Поскольку аргумент является адресом, то параметром\
функции должен быть указатель. Затем функция сможет разыменовать этот\
указатель для доступа или изменения исходного значения:
```c++
#include <iostream>

void boo(int *ptr) {
    *ptr = 7;
}

int main() {
    int value = 4;
    std::cout << "value = " << value << '\n'; // 4
    boo(&value);
    std::cout << "value = " << value << '\n'; // 7

    return 0;
}
```

### Передача по константному адресу
```c++
#include <iostream>

void setToNull(int *tempPtr) {
    // Мы присваиваем tempPtr другое значение (мы не изменяем значение, на которое указывает tempPtr)
    tempPtr = nullptr; // используйте 0, если не поддерживается C++11
}

int main() {
    // Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
    int six = 6;
    int *ptr = &six;

    // Здесь выведется 6
    std::cout << *ptr << "\n";

    // tempPtr получит копию ptr
    setToNull(ptr);

    // ptr до сих пор указывает на переменную six!

    // Здесь выведется 6
    if (ptr)
        std::cout << *ptr << "\n";
    else
        std::cout << " ptr is null";

    return 0;
}
```
В `tempPtr` копируется адрес указателя `ptr`. Несмотря на то, что мы изменили\
`tempPtr` на нулевой указатель (присвоили ему `nullptr`), это никак не повлияло на\
значение, на которое указывает `ptr`.

Обратите внимание, хотя сам адрес передается по значению, вы все равно можете\
разыменовать его для изменения значения исходного аргумента:
* При передаче аргумента по адресу в переменную-параметр функции\
  копируется адрес из аргумента. В этот момент параметр функции и аргумент\
  указывают на одно и то же значение.
* Если параметр функции затем разыменовать для изменения исходного\
  значения, то это приведет к изменению значения, на которое указывает\
  аргумент, поскольку параметр функции и аргумент указывают на одно и то же\
  значение!
* Если параметру функции присвоить другой адрес, то это никак не повлияет на\
  аргумент, поскольку параметр функции является копией, а изменение копии\
  не приводит к изменению оригинала. После изменения адреса параметра\
  функции, параметр функции и аргумент будут указывать на разные значения,\
  поэтому разыменование параметра и дальнейшее его изменение никак не\
  повлияют на значение, на которое указывает аргумент.

```c++
#include <iostream>

void setToSeven(int *tempPtr) {
    *tempPtr = 7; // мы изменяем значение, на которое указывает tempPtr (и ptr тоже)
}

int main() {
    // Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
    int six = 6;
    int *ptr = &six;

    // Здесь выведется 6
    std::cout << *ptr << "\n";

    // tempPtr получит копию ptr
    setToSeven(ptr);

    // tempPtr изменил значение, на которое указывал, на 7

    // Здесь выведется 7
    if (ptr)
        std::cout << *ptr << "\n";
    else
        std::cout << " ptr is null";

    return 0;
}
```

### Передача адресов по ссылке
Изменить адрес, на который указывает аргумент, внутри функции:
```c++
#include <iostream>

// tempPtr теперь является ссылкой на указатель, поэтому любые изменения
// tempPtr приведут и к изменениям исходного аргумента!
void setToNull(int *&tempPtr) {
    tempPtr = nullptr;
}

int main() {
    // Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
    int six = 6;
    int *ptr = &six;

    // Здесь выведется 6
    std::cout << *ptr;

    // tempPtr является ссылкой на ptr
    setToNull(ptr);

    // ptr было присвоено значение nullptr!
    
    // выведется ptr is null
    if (ptr)
        std::cout << *ptr;
    else
        std::cout << " ptr is null";

    return 0;
}
```

### Плюсы и минусы передачи по адресу
**Плюсы передачи по адресу:**
* Передача по адресу позволяет функции изменить значение аргумента, что\
  иногда полезно. В противном случае, используем const для гарантии того, что\
  функция не изменит аргумент.
* Поскольку копирования аргументов не происходит, то скорость передачи по\
  адресу достаточно высокая, даже если передавать большие структуры или\
  классы.
* Мы можем вернуть сразу несколько значений из функции, используя\
  параметры вывода.

**Минусы передачи по адресу:**
* Все указатели нужно проверять, не являются ли они нулевыми. Попытка\
  разыменовать нулевой указатель приведет к сбою в программе.
* Поскольку разыменование указателя выполняется медленнее, чем доступ к\
  значению напрямую, то доступ к аргументам, переданным по адресу,\
  выполняется также медленнее, чем доступ к аргументам, переданным по\
  значению.

**Когда использовать передачу по адресу:**
* при передаче обычных массивов (если нет никаких проблем с тем, что\
  массивы распадаются в указатели при передаче).

**Когда не использовать передачу по адресу:**
* при передаче структур или классов (используйте передачу по ссылке);
* при передаче фундаментальных типов данных (используйте передачу по\
  значению).

**Правило: Используйте передачу по ссылке, вместо передачи по адресу, когда это\
возможно.**

## Урок №106. Возврат значений по ссылке, по адресу и по значению
### Возврат по значению
**Возврат по значению** — это самый простой и безопасный тип возврата. При\
возврате по значению, копия возвращаемого значения передается обратно в caller.
```c++
int doubleValue(int a) {
    int value = a * 3;
    return value; // копия value возвращается здесь
} // value выходит из области видимости здесь
```

**Когда использовать возврат по значению:**
* при возврате переменных, которые были объявлены внутри функции;
* при возврате аргументов функции, которые были переданы в функцию по\
  значению.

**Когда не использовать возврат по значению:**
* при возврате стандартных массивов или указателей (используйте возврат по адресу);
* при возврате больших структур или классов (используйте возврат по ссылке).

### Возврат по адресу
**Возврат по адресу** — это возврат адреса переменной обратно в caller. Подобно\
передаче по адресу, возврат по адресу может возвращать только адрес\
переменной. Литералы и выражения возвращать нельзя, так как они не имеют\
адресов. Поскольку при возврате по адресу просто копируется адрес из функции в\
caller, то этот процесс также очень быстрый.\
Тем не менее, этот способ имеет один **недостаток**, который отсутствует при\
возврате по значению: если вы попытаетесь возвратить адрес локальной\
переменной, то получите неожиданные результаты.
```c++
int* doubleValue(int a) {
    int value = a * 3;
    return &value; // value возвращается по адресу здесь
} // value уничтожается здесь и caller получит адрес освобожденной памяти (висячий указатель)
```

Возврат по адресу часто используется для возврата динамически выделенной\
памяти обратно в caller:
```c++
int *allocateArray(int size) {
    return new int[size];
}

int main() {
    int *array = allocateArray(20);

    // Делаем что-нибудь с array

    delete[] array;

    return 0;
}
```

**Когда использовать возврат по адресу:**
* при возврате динамически выделенной памяти; 
* при возврате аргументов функции, которые были переданы по адресу.

**Когда не использовать возврат по адресу:**
* при возврате переменных, которые были объявлены внутри функции\
  (используйте возврат по значению);
* при возврате большой структуры или класса, который был передан по ссылке\
  (используйте возврат по ссылке).

### Возврат по ссылке
Подобно передаче по ссылке, значения, возвращаемые по ссылке, должны быть\
переменными (вы не сможете вернуть ссылку на литерал или выражение). При\
**возврате по ссылке** в caller возвращается ссылка на переменную. Затем caller может\
её использовать для продолжения изменения переменной, что может быть иногда\
полезно. Этот способ также очень быстрый и при возврате больших структур или\
классов.

Однако, как и при возврате по адресу, вы не должны возвращать локальные\
переменные по ссылке:
```c++
int &doubleValue(int a) {
    int value = a * 3;
    return value; // value возвращается по ссылке здесь
} // // value уничтожается здесь, caller получит ссылку на мусор
```

**Возврат по ссылке** обычно используется для **возврата аргументов, переданных в\
функцию по ссылке**:
```c++
#include <iostream>
#include <array>

// Возвращаем ссылку на элемент массива по индексу index
int& getElement(std::array<int, 20> &array, int index) {
    // Мы знаем, что array[index] не уничтожится, когда мы будем возвращать
    // данные в caller (так как caller сам передал этот array в функцию!)
    // Так что здесь не должно быть никаких проблем с возвратом по ссылке
    return array[index];
}

int main() {
    std::array<int, 20> array{};
    // Присваиваем элементу массива под индексом 15 значение 7
    getElement(array, 15) = 7;
    std::cout << array[15] << '\n'; // 7

    return 0;
}
```

**Когда использовать возврат по ссылке:**
* при возврате ссылки-параметра; 
* при возврате элемента массива, который был передан в функцию; 
* при возврате большой структуры или класса, который не уничтожается в\
  конце функции (например, тот, который был передан в функцию).

**Когда не использовать возврат по ссылке:**
* при возврате переменных, которые были объявлены внутри функции\
  (используйте возврат по значению);
* при возврате стандартного массива или значения указателя (используйте\
  возврат по адресу).

### Смешивание возвращаемых значений и ссылок
Хотя функция может возвращать как значение, так и ссылку, caller может\
неправильно это интерпретировать. Посмотрим, что произойдет при смешивании\
возвращаемых значений и ссылок на значения:
```c++
int returnByValue() {
    return 7;
}

int& returnByReference() {
    static int y = 7; // static гарантирует то, что переменная y не
    // уничтожится, когда выйдет из локальной области видимости
    return y;
}

int main() {
    int value = returnByReference(); // случай A: всё хорошо, обрабатывается
    // как возврат по значению

    int &ref = returnByValue(); // случай B: ошибка компилятора, так как 7 -
    // это r-value, а r-value не может быть привязано к неконстантной ссылке

    const int &cref = returnByValue(); // случай C: всё хорошо, время жизни
    // возвращаемого значения продлевается в соответствии со временем жизни cref
}
```
**В случае A** мы присваиваем ссылку возвращаемого значения переменной, которая\
сама не является ссылкой. Поскольку `value` не является ссылкой, то возвращаемое\
значение просто копируется в `value` так, как если бы `returnByReference()` был\
возвратом по значению.

**В случае B** мы пытаемся инициализировать ссылку `ref` копией возвращаемого\
значения функции `returnByValue()`. Однако, поскольку возвращаемое значение не\
имеет адреса (это r-value), мы получим ошибку компиляции.

**В случае C** мы пытаемся инициализировать константную ссылку `cref` копией\
возвращаемого значения функции `returnByValue()`. Поскольку константные ссылки\
могут быть инициализированы с помощью r-values, то здесь не должно быть\
никаких проблем. Обычно r-values уничтожаются в конце выражения, в котором они\
созданы, однако, при привязке к константной ссылке, время жизни r-value (в\
данном случае, возвращаемого значения функции) продлевается в соответствии со\
временем жизни ссылки (в данном случае, `cref`).

### Резюме
В большинстве случаев идеальным вариантом для использования является возврат\
по значению. Это также самый гибкий и безопасный способ возврата данных\
обратно в вызывающий объект. Однако возврат по ссылке или по адресу также\
может быть полезен при работе с динамически выделенной памятью. При\
использовании возврата по ссылке или по адресу убедитесь, что вы не возвращаете\
ссылку или адрес локальной переменной, которая выйдет из области видимости,\
когда функция завершит свое выполнение!

### Тест
**Задание №1.**\
Функция `sumTo()`, которая принимает целочисленный параметр, а возвращает\
сумму всех чисел между 1 и числом, которое ввел пользователь.
```c++
int sumTo(const int value);
```

**Задание №2.**\
Функция `printAnimalName()`, которая принимает структуру Animal в качестве\
параметра.
```c++
void printAnimalName(const Animal &animal);
```

**Задание №3.**\
Функция `minmax()`, которая принимает два целых числа в качестве входных данных,\
а возвращает наименьшее и наибольшее числа в качестве отдельных параметров.
```c++
void minmax(const int a, const int b, int &minOut, int &maxOut);
```

**Задание №4.**\
Функция `getIndexOfLargestValue()`, которая принимает целочисленный массив (как\
указатель) и его размер, а возвращает индекс наибольшего элемента массива.
```c++
int getIndexOfLargestValue(const int *array, const int length);
```

**Задание №5.**\
Функция `getElement()`, которая принимает целочисленный массив (как указатель) и\
индекс, а возвращает элемент массива по этому индексу (не копию элемента).\
Предполагается, что индекс корректен, а возвращаемое значение — константное.
```c++
const int &getElement(const int *array, const int index);
```

## Урок №107. Встроенные функции
**Ключевое слово `inline`** используется для запроса, чтобы компилятор рассматривал\
вашу функцию как встроенную. При компиляции вашего кода, все **встроенные функции**\
(англ. "inline functions") раскрываются "на месте", то есть вызов функции\
заменяется копией содержимого самой функции, и ресурсы, которые могли бы быть\
потрачены на вызов этой функции, сохраняются.\
Минусом является лишь увеличение компилируемого кода за счет того, что встроенная\
функция раскрывается в коде при каждом вызове (особенно если она длинная и/или\
её вызывают много раз).
```c++
#include <iostream>
inline int max(int a, int b) {
    return a < b ? b : a;
}

int main() {
    std::cout << max(7, 8) << '\n';
    std::cout << max(5, 4) << '\n';
    
    return 0;
}
```

**Правило: Если вы используете современный компилятор, то нет необходимости\
использовать ключевое слово `inline`.**

## Урок №108. Перегрузка функций
**Перегрузка функций** — это возможность определять несколько функций с одним и\
тем же именем, но с разными параметрами:
```c++
int subtract(int a, int b) {
    return a - b;
}

double subtract(double a, double b) {
    return a - b;
}

int subtract(int a, int b); // целочисленная версия
double subtract(double a, double b); // версия типа с плавающей запятой
```

**Тип возврата функции НЕ учитывается при перегрузке функции.**

### Псевдонимы типов в перегрузке функций
Поскольку объявление `typedef` (псевдонима типа) не создает новый тип данных, то\
следующие два объявления функции `print()` считаются идентичными:
```c++
typedef char *string;
void print(string value);
void print(char *value); // ошибка
```

### Вызовы функций
Выполнение вызова перегруженной функции приводит к одному из трех\
возможных результатов:
* **Совпадение найдено.** Вызов разрешен для соответствующей перегруженной\
  функции.
* **Совпадение не найдено.** Аргументы не соответствуют любой из\
  перегруженных функций.
* **Найдены несколько совпадений.** Аргументы соответствуют более чем одной\
  перегруженной функции.

При компиляции перегруженной функции, C++ выполняет следующие шаги для\
определения того, какую версию функции следует вызывать:
1. C++ пытается найти точное совпадение:
    ```c++
    void print(char *value);
    void print(int value);
   
    print(0); // точное совпадение с print(int)
    ```
2. Если точного совпадения не найдено, то C++ пытается найти совпадение\
   путем дальнейшего неявного преобразования типов.
    ```c++
    void print(char *value);
    void print(int value);
    
    print('b'); // совпадение с print(int) после неявного преобразования, поскольку нет print(char)
    ```
3. Если неявное преобразование невозможно, то C++ пытается найти\
   соответствие посредством стандартного преобразования.
    ```c++
    struct Employee; // определение упустим
    void print(float value);
    void print(Employee value);
    
    print('b'); // 'b' конвертируется в соответствие версии print(float)
    ```
4. C++ пытается найти соответствие путем пользовательского преобразования.
    ```c++
    class W; // с пользовательским преобразованием в тип int
    
    void print(float value);
    void print(int value);
    
    W value; // объявляем переменную value типа класса W
    print(value); // value конвертируется в int и, следовательно, соответствует print(int)
    ```
   
### Несколько совпадений
**Неоднозначное совпадение:**
```c++
void print(unsigned int value);
void print(float value);

print('b'); // C++ может преобразовать b как в unsigned int, так и во float
print(0); // та же ситуация
print(3.14159); // По умолчанию все значения-литералы типа с плавающей запятой относятся к 
// типу double, если у них нет окончания f. 3.14159 — это значение типа double, 
// а версии print(double) нет
```

**Решение №1:** Просто определить новую перегруженную функцию, которая\
принимает параметры именно того типа данных, который вы используете в вызове\
функции. Тогда C++ сможет найти точное совпадение.

**Решение №2:** Явно преобразовать с помощью операторов явного преобразования\
неоднозначный параметр(ы) в соответствии с типом функции, которую вы хотите\
вызвать. Например, чтобы вызов `print(0)` соответствовал `print(unsigned int)`,\
вам нужно сделать следующее:
```c++
print(static_cast<unsigned int>(0)); // произойдет вызов print(unsigned int)
```

### Резюме
**Правило: Используйте перегрузку функций для упрощения ваших программ.**

## Урок №109. Параметры по умолчанию
**Параметр по умолчанию** (или **«необязательный параметр»**) — это параметр\
функции, который имеет определенное (по умолчанию) значение.
```c++
#include <iostream>

void printValues(int a, int b=5) {
    std::cout << "a: " << a << '\n';
    std::cout << "b: " << b << '\n';
}

int main() {
    printValues(1); // в качестве b будет использоваться значение по умолчанию - 5
    printValues(6, 7); // в качестве b будет использоваться значение, предоставляемое пользователем - 7
}
```

### Несколько параметров по умолчанию
```c++
void printValues(int a=10, int b=11, int c=12) {
    std::cout << "Values: " << a << " " << b << " " << c << '\n'; 
}
```

Правила использования параметров по умолчанию:
1. Все параметры по умолчанию в прототипе или в определении функции должны\
   находиться справа.
    ```c++
    void printValue(int a=5, int b); // не разрешается
    void printValue(int a, int b=5); // правильно
    ```
2. Если имеется более одного параметра по умолчанию, то самым\
   левым параметром по умолчанию должен быть тот, который с наибольшей\
   вероятностью (среди всех остальных параметров) будет явно переопределен\
   пользователем.

### Объявление параметров по умолчанию
Рекомендуется объявлять параметры по умолчанию в предварительном\
объявлении, а не в определении функции, так как предварительные объявления\
можно использовать в нескольких файлах — при таком раскладе параметры по\
умолчанию будет легче увидеть.

**boo.h:**
```c++
#ifndef BOO_H
#define BOO_H
void printValues(int a, int b=15);
#endif
```

**main.cpp:**
```c++
#include "boo.h"
#include <iostream>

void printValues(int a, int b) {
    std::cout << "a: " << a << '\n';
    std::cout << "b: " << b << '\n';
}

int main() {
    printValues(7);
    
    return 0;
}
```

**Правило: Объявляйте параметры по умолчанию в предварительном объявлении\
функции, в противном случае (если функция не имеет предварительного\
объявления) — объявляйте в определении функции.**

### Параметры по умолчанию и перегрузка функций
Функции с параметрами по умолчанию могут быть перегружены:
```c++
// Допускается
void print(std::string string);
void print(char ch=' ');

// Не допускается
void printValues(int a);
void printValues(int a, int b=15);
```

## Урок №110. Указатели на функции
### Указатели на функции
```c++
// fcnPtr - это указатель на функцию, которая не принимает никаких аргументов
// и возвращает целочисленное значение и может указывать на любую другую функцию, 
// соответствующую этому типу.
int (*fcnPtr)();

int (*const fcnPtr)(); // константный указатель на функцию
```

### Присваивание функции указателю на функцию
```c++
int boo() {
    return 7;
}

int doo() {
    return 8;
}

int main() {
    int (*fcnPtr)() = boo; // fcnPtr указывает на функцию boo()
    fcnPtr = doo; // fcnPtr теперь указывает на функцию doo()
    
    return 0;
}
```

У указателя на функцию и самой функции должны совпадать тип, параметры и\
тип возвращаемого значения:
```c++
// Прототипы функций
int boo();
double doo();
int moo(int a);

// Присваивание значений указателям на функции
int (*fcnPtr1)() = boo; // ок
int (*fcnPtr2)() = doo; // не ок: тип указателя и тип возврата функции не совпадают!

double (*fcnPtr4)() = doo; // ок
fcnPtr1 = moo; // не ок: fcnPtr1 не имеет параметров, но moo() имеет
int (*fcnPtr3)(int) = moo; // ок
```

### Вызов функции через указатель на функцию
**Через явное разыменование:**
```c++
int boo(int a) {
    return a;
}

int main() {
    int (*fcnPtr)(int) = boo; // присваиваем функцию boo() указателю fcnPtr
    (*fcnPtr)(7); // вызываем функцию boo(7), используя fcnPtr
    
    return 0;
}
```

**Через неявное разыменование:**
```c++
int boo(int a) {
    return a;
}

int main() {
    int (*fcnPtr)(int) = boo; // присваиваем функцию boo() указателю fcnPtr
    fcnPtr(7); // вызываем функцию boo(7), используя fcnPtr
    
    return 0;
}
```

Неявное разыменования выглядит так же, как и обычный вызов функции, так как\
обычные **имена функций являются указателями на функции**.

**Примечание: параметры по умолчанию не могут обрабатываться при вызове функции\
через указатель на функцию; в этом случае вам нужно будет явно передать значения\
для параметров по умолчанию.**

### Передача функций в качестве аргументов другим функциям
Одна из самых полезных вещей, которую вы можете сделать с указателями на\
функции — это передать функцию в качестве аргумента другой функции. Функции,\
используемые в качестве аргументов для других функций, называются **функциями\
обратного вызова**:
```c++
void customSort(int *array, int size, bool (*comparisonFcn)(int, int)) {
    ...
}

bool ascending(int a, int b) {
    return a > b; // меняем местами, если первый элемент больше второго
}

bool descending(int a, int b) {
    return a < b; // меняем местами, если второй элемент больше первого
}

int main() {
    // Сортируем массив в порядке убывания, используя функцию descending()
    customSort(array, 8, descending);
    
    // Сортируем массив в порядке возрастания, используя функцию ascending()
    customSort(array, 8, ascending);
}
```

### Параметры по умолчанию в функциях
```c++
// Сортировка по умолчанию выполняется в порядке возрастания
void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int) = ascending);
```

### Указатели на функции и псевдонимы типов
С помощью `typedefs` мы можем исправить синтаксис указателей на функции:
```c++
typedef bool (*validateFcn)(int, int);
```
Здесь мы определили псевдоним типа под названием `validateFcn`, который\
является указателем на функцию, которая принимает два значения типа `int` и\
возвращает значение типа `bool`.

Теперь вместо написания следующего:
```c++
bool validate(int a, int b, bool (*fcnPtr)(int, int)); // фу, какой синтаксис
```
Мы можем написать следующее:
```c++
bool validate(int a, int b, validateFcn pfcn) // вот это другое дело
```

Также можно использовать `type alias` для создания псевдонима типа указателя\
на функцию:
```c++
using validateFcn = bool(*)(int, int); // type alias

// И тогда точно также
bool validate(int a, int b, validateFcn pfcn)
```

### Использование `std::function` в C++11
```c++
#include <functional>

bool validate(int a, int b, std::function<bool(int, int)> fcn); // указываем
// указатель на функцию с помощью std::function, которая возвращает bool и
// принимает два int-а
```

Тогда код из начала урока примет вид:
```c++
#include <iostream>
#include <functional>

int boo() {
    return 7;
}

int doo() {
    return 8;
}

int main() {
    std::function<int()> fcnPtr; // объявляем указатель на функцию, который
    // возвращает int и не принимает никаких параметров
    fcnPtr = doo; // fcnPtr теперь указывает на функцию doo()
    std::cout << fcnPtr(); // вызываем функцию как обычно. Выведется 8
    
    return 0;
}
```

### Резюме
Указатели на функции полезны, прежде всего, когда вы хотите хранить функции в\
массиве (или в структуре) или когда вам нужно передать одну функцию в качестве\
аргумента другой функции. Поскольку синтаксис объявления указателей на функции\
является несколько уродливым и подвержен ошибкам, то рекомендуется\
использовать `type alias` или `std::function`.

### Тест
**Задание №1.**\
В этот раз мы попытаемся написать версию базового калькулятора с помощью\
указателей на функции.
```c++
#include <iostream>

int getInteger() {
    std::cout << "Enter an integer: ";
    int a;
    std::cin >> a;
    return a;
}

char getOperation() {
    char op;
    do {
        std::cout << "Enter an operation ('+', '-', '*', '/'): ";
        std::cin >> op;
    } while (op != '+' && op != '-' && op != '*' && op != '/');
    return op;
}

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int divide(int a, int b) {
    return a / b;
}

typedef int (*arithmeticFcn)(int, int);

arithmeticFcn getArithmeticFcn(char op) {
    switch (op) {
        default: // функцией по умолчанию будет add()
        case '+':
            return add;
        case '-':
            return subtract;
        case '*':
            return multiply;
        case '/':
            return divide;
    }
}

int main() {
    int a = getInteger();
    char op = getOperation();
    int b = getInteger();
    arithmeticFcn fcn = getArithmeticFcn(op);
    std::cout << a << ' ' << op << ' ' << b << " = " << fcn(a, b) << '\n';
    return 0;
}
```

**Задание №2.**\
Теперь давайте изменим программу, которую мы написали в первом задании,\
чтобы переместить логику из `getArithmeticFcn` в массив.
```c++
#include <iostream>

int getInteger() {
    std::cout << "Enter an integer: ";
    int a;
    std::cin >> a;
    return a;
}

char getOperation() {
    char op;
    do {
        std::cout << "Enter an operation ('+', '-', '*', '/'): ";
        std::cin >> op;
    } while (op != '+' && op != '-' && op != '*' && op != '/');
    return op;
}

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int divide(int a, int b) {
    return a / b;
}

typedef int(*arithmeticFcn)(int, int);

struct arithmeticStruct {
    char op;
    arithmeticFcn fcn;
};
static arithmeticStruct arithmeticArray[]{
        {'+', add},
        {'-', subtract},
        {'*', multiply},
        {'/', divide}
};

arithmeticFcn getArithmeticFcn(char op) {
    for (const auto &arith: arithmeticArray) {
        if (arith.op == op)
            return arith.fcn;
    }
    return add; // функцией по умолчанию будет add()
}

int main() {
    int a = getInteger();
    char op = getOperation();
    int b = getInteger();
    arithmeticFcn fcn = getArithmeticFcn(op);
    std::cout << a << ' ' << op << ' ' << b << " = " << fcn(a, b) << '\n';
    return 0;
}
```