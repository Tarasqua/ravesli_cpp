# Глава №7. Глава №7. Функции в C++

## Содержание
1. [Урок №102. Параметры и аргументы функций](#урок-102-параметры-и-аргументы-функций)
2. [Урок №103. Передача по значению](#урок-103-передача-по-значению)
3. [Урок №104. Передача по ссылке](#урок-104-передача-по-ссылке)
4. [Урок №105. Передача по адресу](#урок-105-передача-по-адресу)
5. [Урок №106. Возврат значений по ссылке, по адресу и по значению](#урок-106-возврат-значений-по-ссылке-по-адресу-и-по-значению)
6. [Урок №107. Встроенные функции](#урок-107-встроенные-функции)
7. [Урок №108. Перегрузка функций](#урок-108-перегрузка-функций)
8. [Урок №109. Параметры по умолчанию](#урок-109-параметры-по-умолчанию)
9. [Урок №110. Указатели на функции](#урок-110-указатели-на-функции)
10. [Урок №111. Стек и Куча](#урок-111-стек-и-куча)
11. [Урок №112. Ёмкость вектора](#урок-112-ёмкость-вектора)
12. [Урок №113. Рекурсия и Числа Фибоначчи](#урок-113-рекурсия-и-числа-фибоначчи)
13. [Урок №114. Обработка ошибок, `cerr` и `exit()`](#урок-114-обработка-ошибок-cerr-и-exit)
14. [Урок №115. `assert` и `static_assert`](#урок-115-assert-и-staticassert)
15. [Урок №116. Аргументы командной строки](#урок-116-аргументы-командной-строки)
16. [Урок №117. Эллипсис](#урок-117-эллипсис)
17. [Урок №118. Лямбда-выражения](#урок-118-лямбда-выражения)
18. [Урок №119. Лямбда-захваты](#урок-119-лямбда-захваты)
19. [Глава №7. Итоговый тест](#глава-7-итоговый-тест)

## [Урок №102. Параметры и аргументы функций](#урок-102-параметры-и-аргументы-функций)
### Параметры vs. Аргументы
**Параметр функции** (или **"формальный параметр"**) — это переменная,\
создаваемая в объявлении функции:
```c++
void boo(int x); // объявление (прототип функции). x - это параметр
void boo(int x) // определение (также объявление). x - это параметр
{
}
```

**Аргумент** (или **"фактический параметр"**) — это значение, которое передает в\
функцию вызывающий объект (caller):
```c++
boo(7); // 7 - это аргумент, который передается в параметр x
boo(y+1); // выражение y+1 - это аргумент, который передается в параметр x
```

## [Урок №103. Передача по значению](#урок-103-передача-по-значению)
По умолчанию, аргументы в C++ передаются по значению. Когда аргумент\
**передается по значению**, то его значение копируется в параметр функции:
```c++
#include <iostream>

void boo(int y) {
    std::cout << "y = " << y << std::endl;
}

int main() {
    boo(7); // 1-й вызов - y = 7
    
    int x = 8;
    boo(x); // 2-й вызов - 7 = 8
    boo(x + 2); // 3-й вызов - y = 10
    
    return 0;
}
```

### Плюсы и минусы передачи по значению
**Плюсы передачи по значению:**
* Аргументы, переданные по значению, могут быть переменными (например,\
  `x`), литералами (например, `8`), выражениями (например, `x + 2`),\
  структурами, классами или перечислителями (т.е. почти всем, чем угодно).
* Аргументы никогда не изменяются функцией, в которую передаются, что\
  предотвращает возникновение побочных эффектов.

**Минусы передачи по значению:**
* Копирование структур и классов может привести к значительному\
  снижению производительности (особенно, когда функция вызывается\
  много раз).

**Когда использовать передачу по значению:**
* При передаче фундаментальных типов данных и перечислителей, когда\
  предполагается, что функция не должна изменять аргумент.

**Когда не использовать передачу по значению:**
* При передаче массивов, структур и классов.

## [Урок №104. Передача по ссылке](#урок-104-передача-по-ссылке)
### Передача по ссылке
При **передаче переменной по ссылке** нужно просто объявить параметры функции\
как ссылки, а не как обычные переменные:
```c++
void func(int &x) { // x - это переменная-ссылка
    x = x + 1;
}
```

### Возврат сразу нескольких значений
Одним из способов возврата сразу нескольких значений является **использование\
ссылок в качестве параметров**:
```c++
#include <iostream>
#include <math.h> // для sin() и cos()

void getSinCos(double degrees, double &sinOut, double &cosOut) {
    // sin() и cos() принимают радианы, а не градусы, поэтому необходима конвертация
    const double pi = 3.14159265358979323846; // значение Пи
    double radians = degrees * pi / 180.0;
    sinOut = sin(radians);
    cosOut = cos(radians);
}

int main() {
    double sin(0.0);
    double cos(0.0);

    // Функция getSinCos() возвратит sin и cos в переменные sin и cos
    getSinCos(30.0, sin, cos);

    std::cout << "The sin is " << sin << '\n'; // The sin is 0.5
    std::cout << "The cos is " << cos << '\n'; // The cos is 0.866025

    return 0;
}
```
Параметры, которые используются только для возврата значений обратно в\
caller, называются **параметрами вывода**.

В caller-е не очевидно, что `sin` и `cos` являются параметрами вывода,\
и они будут изменены функцией. Поэтому **не рекомендуется смешивать параметры\
ввода и вывода** именно по этой причине.

### Передача по константной ссылке
Когда мы знаем, что функция не должна изменять значение аргумента, но\
не хотим использовать передачу по значению, то лучшим решением будет\
использовать **передачу по константной ссылке**.\
Так как константная ссылка — это ссылка на переменную, значение которой\
изменить через эту же ссылку не получится никак. Следовательно, если мы\
используем константную ссылку в качестве параметра, то получаем 100% гарантию\
того, что функция не изменит аргумент:
```c++
void boo(const int &y) { // y - это константная ссылка
    y = 8; // ошибка компиляции: константная ссылка не может изменить свое же значение!
}
```

**Правило: При передаче аргументов по ссылке всегда используйте константные\
ссылки, если вам не нужно, чтобы функция изменяла значения аргументов.**

### Плюсы и минусы передачи по ссылке
**Плюсы передачи по ссылке:**
* Ссылки позволяют функции изменять значение аргумента, что иногда\
  полезно. В противном случае, для гарантии того, что функция не изменит\
  значение аргумента, нужно использовать константные ссылки.
* Поскольку при передаче по ссылке копирования аргументов не происходит,\
  то этот способ гораздо эффективнее и быстрее передачи по значению,\
  особенно при работе с большими структурами или классами.
* Ссылки могут использоваться для возврата сразу нескольких значений из\
  функции (через параметры вывода).

**Минусы передачи по ссылке:**
* Трудно определить, является ли параметр, переданный по неконстантной\
  ссылке, параметром ввода, вывода или того и другого одновременно.\
  Разумное использование const и суффикса Out для внешних переменных\
  решает эту проблему.
* По вызову функции невозможно определить, будет аргумент изменен\
  функцией или нет. Аргумент, переданный по значению или по ссылке,\
  выглядит одинаково. Мы можем определить способ передачи аргумента\
  только просмотрев объявление функции. Это может привести к ситуации,\
  когда программист не сразу поймет, что функция изменяет значение\
  аргумента.

**Когда использовать передачу по ссылке:**
* при передаче структур или классов (используйте const, если нужно только для\
  чтения);
* когда нужно, чтобы функция изменяла значение аргумента.

**Когда не использовать передачу по ссылке:**
* при передаче фундаментальных типов данных (используйте передачу по\
  значению);
* при передаче обычных массивов (используйте передачу по адресу).

## [Урок №105. Передача по адресу](#урок-105-передача-по-адресу)
### Передача по адресу
**Передача аргументов по адресу** — это передача адреса переменной-аргумента (а\
не исходной переменной). Поскольку аргумент является адресом, то параметром\
функции должен быть указатель. Затем функция сможет разыменовать этот\
указатель для доступа или изменения исходного значения:
```c++
#include <iostream>

void boo(int *ptr) {
    *ptr = 7;
}

int main() {
    int value = 4;
    std::cout << "value = " << value << '\n'; // 4
    boo(&value);
    std::cout << "value = " << value << '\n'; // 7

    return 0;
}
```

### Передача по константному адресу
```c++
#include <iostream>

void setToNull(int *tempPtr) {
    // Мы присваиваем tempPtr другое значение (мы не изменяем значение, на которое указывает tempPtr)
    tempPtr = nullptr; // используйте 0, если не поддерживается C++11
}

int main() {
    // Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
    int six = 6;
    int *ptr = &six;

    // Здесь выведется 6
    std::cout << *ptr << "\n";

    // tempPtr получит копию ptr
    setToNull(ptr);

    // ptr до сих пор указывает на переменную six!

    // Здесь выведется 6
    if (ptr)
        std::cout << *ptr << "\n";
    else
        std::cout << " ptr is null";

    return 0;
}
```
В `tempPtr` копируется адрес указателя `ptr`. Несмотря на то, что мы изменили\
`tempPtr` на нулевой указатель (присвоили ему `nullptr`), это никак не повлияло на\
значение, на которое указывает `ptr`.

Обратите внимание, хотя сам адрес передается по значению, вы все равно можете\
разыменовать его для изменения значения исходного аргумента:
* При передаче аргумента по адресу в переменную-параметр функции\
  копируется адрес из аргумента. В этот момент параметр функции и аргумент\
  указывают на одно и то же значение.
* Если параметр функции затем разыменовать для изменения исходного\
  значения, то это приведет к изменению значения, на которое указывает\
  аргумент, поскольку параметр функции и аргумент указывают на одно и то же\
  значение!
* Если параметру функции присвоить другой адрес, то это никак не повлияет на\
  аргумент, поскольку параметр функции является копией, а изменение копии\
  не приводит к изменению оригинала. После изменения адреса параметра\
  функции, параметр функции и аргумент будут указывать на разные значения,\
  поэтому разыменование параметра и дальнейшее его изменение никак не\
  повлияют на значение, на которое указывает аргумент.

```c++
#include <iostream>

void setToSeven(int *tempPtr) {
    *tempPtr = 7; // мы изменяем значение, на которое указывает tempPtr (и ptr тоже)
}

int main() {
    // Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
    int six = 6;
    int *ptr = &six;

    // Здесь выведется 6
    std::cout << *ptr << "\n";

    // tempPtr получит копию ptr
    setToSeven(ptr);

    // tempPtr изменил значение, на которое указывал, на 7

    // Здесь выведется 7
    if (ptr)
        std::cout << *ptr << "\n";
    else
        std::cout << " ptr is null";

    return 0;
}
```

### Передача адресов по ссылке
Изменить адрес, на который указывает аргумент, внутри функции:
```c++
#include <iostream>

// tempPtr теперь является ссылкой на указатель, поэтому любые изменения
// tempPtr приведут и к изменениям исходного аргумента!
void setToNull(int *&tempPtr) {
    tempPtr = nullptr;
}

int main() {
    // Сначала мы присваиваем ptr адрес six, т.е. *ptr = 6
    int six = 6;
    int *ptr = &six;

    // Здесь выведется 6
    std::cout << *ptr;

    // tempPtr является ссылкой на ptr
    setToNull(ptr);

    // ptr было присвоено значение nullptr!
    
    // выведется ptr is null
    if (ptr)
        std::cout << *ptr;
    else
        std::cout << " ptr is null";

    return 0;
}
```

### Плюсы и минусы передачи по адресу
**Плюсы передачи по адресу:**
* Передача по адресу позволяет функции изменить значение аргумента, что\
  иногда полезно. В противном случае, используем const для гарантии того, что\
  функция не изменит аргумент.
* Поскольку копирования аргументов не происходит, то скорость передачи по\
  адресу достаточно высокая, даже если передавать большие структуры или\
  классы.
* Мы можем вернуть сразу несколько значений из функции, используя\
  параметры вывода.

**Минусы передачи по адресу:**
* Все указатели нужно проверять, не являются ли они нулевыми. Попытка\
  разыменовать нулевой указатель приведет к сбою в программе.
* Поскольку разыменование указателя выполняется медленнее, чем доступ к\
  значению напрямую, то доступ к аргументам, переданным по адресу,\
  выполняется также медленнее, чем доступ к аргументам, переданным по\
  значению.

**Когда использовать передачу по адресу:**
* при передаче обычных массивов (если нет никаких проблем с тем, что\
  массивы распадаются в указатели при передаче).

**Когда не использовать передачу по адресу:**
* при передаче структур или классов (используйте передачу по ссылке);
* при передаче фундаментальных типов данных (используйте передачу по\
  значению).

**Правило: Используйте передачу по ссылке, вместо передачи по адресу, когда это\
возможно.**

## [Урок №106. Возврат значений по ссылке, по адресу и по значению](#урок-106-возврат-значений-по-ссылке-по-адресу-и-по-значению)
### Возврат по значению
**Возврат по значению** — это самый простой и безопасный тип возврата. При\
возврате по значению, копия возвращаемого значения передается обратно в caller.
```c++
int doubleValue(int a) {
    int value = a * 3;
    return value; // копия value возвращается здесь
} // value выходит из области видимости здесь
```

**Когда использовать возврат по значению:**
* при возврате переменных, которые были объявлены внутри функции;
* при возврате аргументов функции, которые были переданы в функцию по\
  значению.

**Когда не использовать возврат по значению:**
* при возврате стандартных массивов или указателей (используйте возврат по адресу);
* при возврате больших структур или классов (используйте возврат по ссылке).

### Возврат по адресу
**Возврат по адресу** — это возврат адреса переменной обратно в caller. Подобно\
передаче по адресу, возврат по адресу может возвращать только адрес\
переменной. Литералы и выражения возвращать нельзя, так как они не имеют\
адресов. Поскольку при возврате по адресу просто копируется адрес из функции в\
caller, то этот процесс также очень быстрый.\
Тем не менее, этот способ имеет один **недостаток**, который отсутствует при\
возврате по значению: если вы попытаетесь возвратить адрес локальной\
переменной, то получите неожиданные результаты.
```c++
int* doubleValue(int a) {
    int value = a * 3;
    return &value; // value возвращается по адресу здесь
} // value уничтожается здесь и caller получит адрес освобожденной памяти (висячий указатель)
```

Возврат по адресу часто используется для возврата динамически выделенной\
памяти обратно в caller:
```c++
int *allocateArray(int size) {
    return new int[size];
}

int main() {
    int *array = allocateArray(20);

    // Делаем что-нибудь с array

    delete[] array;

    return 0;
}
```

**Когда использовать возврат по адресу:**
* при возврате динамически выделенной памяти; 
* при возврате аргументов функции, которые были переданы по адресу.

**Когда не использовать возврат по адресу:**
* при возврате переменных, которые были объявлены внутри функции\
  (используйте возврат по значению);
* при возврате большой структуры или класса, который был передан по ссылке\
  (используйте возврат по ссылке).

### Возврат по ссылке
Подобно передаче по ссылке, значения, возвращаемые по ссылке, должны быть\
переменными (вы не сможете вернуть ссылку на литерал или выражение). При\
**возврате по ссылке** в caller возвращается ссылка на переменную. Затем caller может\
её использовать для продолжения изменения переменной, что может быть иногда\
полезно. Этот способ также очень быстрый и при возврате больших структур или\
классов.

Однако, как и при возврате по адресу, вы не должны возвращать локальные\
переменные по ссылке:
```c++
int &doubleValue(int a) {
    int value = a * 3;
    return value; // value возвращается по ссылке здесь
} // // value уничтожается здесь, caller получит ссылку на мусор
```

**Возврат по ссылке** обычно используется для **возврата аргументов, переданных в\
функцию по ссылке**:
```c++
#include <iostream>
#include <array>

// Возвращаем ссылку на элемент массива по индексу index
int& getElement(std::array<int, 20> &array, int index) {
    // Мы знаем, что array[index] не уничтожится, когда мы будем возвращать
    // данные в caller (так как caller сам передал этот array в функцию!)
    // Так что здесь не должно быть никаких проблем с возвратом по ссылке
    return array[index];
}

int main() {
    std::array<int, 20> array{};
    // Присваиваем элементу массива под индексом 15 значение 7
    getElement(array, 15) = 7;
    std::cout << array[15] << '\n'; // 7

    return 0;
}
```

**Когда использовать возврат по ссылке:**
* при возврате ссылки-параметра; 
* при возврате элемента массива, который был передан в функцию; 
* при возврате большой структуры или класса, который не уничтожается в\
  конце функции (например, тот, который был передан в функцию).

**Когда не использовать возврат по ссылке:**
* при возврате переменных, которые были объявлены внутри функции\
  (используйте возврат по значению);
* при возврате стандартного массива или значения указателя (используйте\
  возврат по адресу).

### Смешивание возвращаемых значений и ссылок
Хотя функция может возвращать как значение, так и ссылку, caller может\
неправильно это интерпретировать. Посмотрим, что произойдет при смешивании\
возвращаемых значений и ссылок на значения:
```c++
int returnByValue() {
    return 7;
}

int& returnByReference() {
    static int y = 7; // static гарантирует то, что переменная y не
    // уничтожится, когда выйдет из локальной области видимости
    return y;
}

int main() {
    int value = returnByReference(); // случай A: всё хорошо, обрабатывается
    // как возврат по значению

    int &ref = returnByValue(); // случай B: ошибка компилятора, так как 7 -
    // это r-value, а r-value не может быть привязано к неконстантной ссылке

    const int &cref = returnByValue(); // случай C: всё хорошо, время жизни
    // возвращаемого значения продлевается в соответствии со временем жизни cref
}
```
**В случае A** мы присваиваем ссылку возвращаемого значения переменной, которая\
сама не является ссылкой. Поскольку `value` не является ссылкой, то возвращаемое\
значение просто копируется в `value` так, как если бы `returnByReference()` был\
возвратом по значению.

**В случае B** мы пытаемся инициализировать ссылку `ref` копией возвращаемого\
значения функции `returnByValue()`. Однако, поскольку возвращаемое значение не\
имеет адреса (это r-value), мы получим ошибку компиляции.

**В случае C** мы пытаемся инициализировать константную ссылку `cref` копией\
возвращаемого значения функции `returnByValue()`. Поскольку константные ссылки\
могут быть инициализированы с помощью r-values, то здесь не должно быть\
никаких проблем. Обычно r-values уничтожаются в конце выражения, в котором они\
созданы, однако, при привязке к константной ссылке, время жизни r-value (в\
данном случае, возвращаемого значения функции) продлевается в соответствии со\
временем жизни ссылки (в данном случае, `cref`).

### Резюме
В большинстве случаев идеальным вариантом для использования является возврат\
по значению. Это также самый гибкий и безопасный способ возврата данных\
обратно в вызывающий объект. Однако возврат по ссылке или по адресу также\
может быть полезен при работе с динамически выделенной памятью. При\
использовании возврата по ссылке или по адресу убедитесь, что вы не возвращаете\
ссылку или адрес локальной переменной, которая выйдет из области видимости,\
когда функция завершит свое выполнение!

### Тест
**Задание №1.**\
Функция `sumTo()`, которая принимает целочисленный параметр, а возвращает\
сумму всех чисел между 1 и числом, которое ввел пользователь.
```c++
int sumTo(const int value);
```

**Задание №2.**\
Функция `printAnimalName()`, которая принимает структуру Animal в качестве\
параметра.
```c++
void printAnimalName(const Animal &animal);
```

**Задание №3.**\
Функция `minmax()`, которая принимает два целых числа в качестве входных данных,\
а возвращает наименьшее и наибольшее числа в качестве отдельных параметров.
```c++
void minmax(const int a, const int b, int &minOut, int &maxOut);
```

**Задание №4.**\
Функция `getIndexOfLargestValue()`, которая принимает целочисленный массив (как\
указатель) и его размер, а возвращает индекс наибольшего элемента массива.
```c++
int getIndexOfLargestValue(const int *array, const int length);
```

**Задание №5.**\
Функция `getElement()`, которая принимает целочисленный массив (как указатель) и\
индекс, а возвращает элемент массива по этому индексу (не копию элемента).\
Предполагается, что индекс корректен, а возвращаемое значение — константное.
```c++
const int &getElement(const int *array, const int index);
```

## [Урок №107. Встроенные функции](#урок-107-встроенные-функции)
**Ключевое слово `inline`** используется для запроса, чтобы компилятор рассматривал\
вашу функцию как встроенную. При компиляции вашего кода, все **встроенные функции**\
(англ. "inline functions") раскрываются "на месте", то есть вызов функции\
заменяется копией содержимого самой функции, и ресурсы, которые могли бы быть\
потрачены на вызов этой функции, сохраняются.\
Минусом является лишь увеличение компилируемого кода за счет того, что встроенная\
функция раскрывается в коде при каждом вызове (особенно если она длинная и/или\
её вызывают много раз).
```c++
#include <iostream>
inline int max(int a, int b) {
    return a < b ? b : a;
}

int main() {
    std::cout << max(7, 8) << '\n';
    std::cout << max(5, 4) << '\n';
    
    return 0;
}
```

**Правило: Если вы используете современный компилятор, то нет необходимости\
использовать ключевое слово `inline`.**

## [Урок №108. Перегрузка функций](#урок-108-перегрузка-функций)
**Перегрузка функций** — это возможность определять несколько функций с одним и\
тем же именем, но с разными параметрами:
```c++
int subtract(int a, int b) {
    return a - b;
}

double subtract(double a, double b) {
    return a - b;
}

int subtract(int a, int b); // целочисленная версия
double subtract(double a, double b); // версия типа с плавающей запятой
```

**Тип возврата функции НЕ учитывается при перегрузке функции.**

### Псевдонимы типов в перегрузке функций
Поскольку объявление `typedef` (псевдонима типа) не создает новый тип данных, то\
следующие два объявления функции `print()` считаются идентичными:
```c++
typedef char *string;
void print(string value);
void print(char *value); // ошибка
```

### Вызовы функций
Выполнение вызова перегруженной функции приводит к одному из трех\
возможных результатов:
* **Совпадение найдено.** Вызов разрешен для соответствующей перегруженной\
  функции.
* **Совпадение не найдено.** Аргументы не соответствуют любой из\
  перегруженных функций.
* **Найдены несколько совпадений.** Аргументы соответствуют более чем одной\
  перегруженной функции.

При компиляции перегруженной функции, C++ выполняет следующие шаги для\
определения того, какую версию функции следует вызывать:
1. C++ пытается найти точное совпадение:
    ```c++
    void print(char *value);
    void print(int value);
   
    print(0); // точное совпадение с print(int)
    ```
2. Если точного совпадения не найдено, то C++ пытается найти совпадение\
   путем дальнейшего неявного преобразования типов.
    ```c++
    void print(char *value);
    void print(int value);
    
    print('b'); // совпадение с print(int) после неявного преобразования, поскольку нет print(char)
    ```
3. Если неявное преобразование невозможно, то C++ пытается найти\
   соответствие посредством стандартного преобразования.
    ```c++
    struct Employee; // определение упустим
    void print(float value);
    void print(Employee value);
    
    print('b'); // 'b' конвертируется в соответствие версии print(float)
    ```
4. C++ пытается найти соответствие путем пользовательского преобразования.
    ```c++
    class W; // с пользовательским преобразованием в тип int
    
    void print(float value);
    void print(int value);
    
    W value; // объявляем переменную value типа класса W
    print(value); // value конвертируется в int и, следовательно, соответствует print(int)
    ```
   
### Несколько совпадений
**Неоднозначное совпадение:**
```c++
void print(unsigned int value);
void print(float value);

print('b'); // C++ может преобразовать b как в unsigned int, так и во float
print(0); // та же ситуация
print(3.14159); // По умолчанию все значения-литералы типа с плавающей запятой относятся к 
// типу double, если у них нет окончания f. 3.14159 — это значение типа double, 
// а версии print(double) нет
```

**Решение №1:** Просто определить новую перегруженную функцию, которая\
принимает параметры именно того типа данных, который вы используете в вызове\
функции. Тогда C++ сможет найти точное совпадение.

**Решение №2:** Явно преобразовать с помощью операторов явного преобразования\
неоднозначный параметр(ы) в соответствии с типом функции, которую вы хотите\
вызвать. Например, чтобы вызов `print(0)` соответствовал `print(unsigned int)`,\
вам нужно сделать следующее:
```c++
print(static_cast<unsigned int>(0)); // произойдет вызов print(unsigned int)
```

### Резюме
**Правило: Используйте перегрузку функций для упрощения ваших программ.**

## [Урок №109. Параметры по умолчанию](#урок-109-параметры-по-умолчанию)
**Параметр по умолчанию** (или **«необязательный параметр»**) — это параметр\
функции, который имеет определенное (по умолчанию) значение.
```c++
#include <iostream>

void printValues(int a, int b=5) {
    std::cout << "a: " << a << '\n';
    std::cout << "b: " << b << '\n';
}

int main() {
    printValues(1); // в качестве b будет использоваться значение по умолчанию - 5
    printValues(6, 7); // в качестве b будет использоваться значение, предоставляемое пользователем - 7
}
```

### Несколько параметров по умолчанию
```c++
void printValues(int a=10, int b=11, int c=12) {
    std::cout << "Values: " << a << " " << b << " " << c << '\n'; 
}
```

Правила использования параметров по умолчанию:
1. Все параметры по умолчанию в прототипе или в определении функции должны\
   находиться справа.
    ```c++
    void printValue(int a=5, int b); // не разрешается
    void printValue(int a, int b=5); // правильно
    ```
2. Если имеется более одного параметра по умолчанию, то самым\
   левым параметром по умолчанию должен быть тот, который с наибольшей\
   вероятностью (среди всех остальных параметров) будет явно переопределен\
   пользователем.

### Объявление параметров по умолчанию
Рекомендуется объявлять параметры по умолчанию в предварительном\
объявлении, а не в определении функции, так как предварительные объявления\
можно использовать в нескольких файлах — при таком раскладе параметры по\
умолчанию будет легче увидеть.

**boo.h:**
```c++
#ifndef BOO_H
#define BOO_H
void printValues(int a, int b=15);
#endif
```

**main.cpp:**
```c++
#include "boo.h"
#include <iostream>

void printValues(int a, int b) {
    std::cout << "a: " << a << '\n';
    std::cout << "b: " << b << '\n';
}

int main() {
    printValues(7);
    
    return 0;
}
```

**Правило: Объявляйте параметры по умолчанию в предварительном объявлении\
функции, в противном случае (если функция не имеет предварительного\
объявления) — объявляйте в определении функции.**

### Параметры по умолчанию и перегрузка функций
Функции с параметрами по умолчанию могут быть перегружены:
```c++
// Допускается
void print(std::string string);
void print(char ch=' ');

// Не допускается
void printValues(int a);
void printValues(int a, int b=15);
```

## [Урок №110. Указатели на функции](#урок-110-указатели-на-функции)
### Указатели на функции
```c++
// fcnPtr - это указатель на функцию, которая не принимает никаких аргументов
// и возвращает целочисленное значение и может указывать на любую другую функцию, 
// соответствующую этому типу.
int (*fcnPtr)();

int (*const fcnPtr)(); // константный указатель на функцию
```

### Присваивание функции указателю на функцию
```c++
int boo() {
    return 7;
}

int doo() {
    return 8;
}

int main() {
    int (*fcnPtr)() = boo; // fcnPtr указывает на функцию boo()
    fcnPtr = doo; // fcnPtr теперь указывает на функцию doo()
    
    return 0;
}
```

У указателя на функцию и самой функции должны совпадать тип, параметры и\
тип возвращаемого значения:
```c++
// Прототипы функций
int boo();
double doo();
int moo(int a);

// Присваивание значений указателям на функции
int (*fcnPtr1)() = boo; // ок
int (*fcnPtr2)() = doo; // не ок: тип указателя и тип возврата функции не совпадают!

double (*fcnPtr4)() = doo; // ок
fcnPtr1 = moo; // не ок: fcnPtr1 не имеет параметров, но moo() имеет
int (*fcnPtr3)(int) = moo; // ок
```

### Вызов функции через указатель на функцию
**Через явное разыменование:**
```c++
int boo(int a) {
    return a;
}

int main() {
    int (*fcnPtr)(int) = boo; // присваиваем функцию boo() указателю fcnPtr
    (*fcnPtr)(7); // вызываем функцию boo(7), используя fcnPtr
    
    return 0;
}
```

**Через неявное разыменование:**
```c++
int boo(int a) {
    return a;
}

int main() {
    int (*fcnPtr)(int) = boo; // присваиваем функцию boo() указателю fcnPtr
    fcnPtr(7); // вызываем функцию boo(7), используя fcnPtr
    
    return 0;
}
```

Неявное разыменования выглядит так же, как и обычный вызов функции, так как\
обычные **имена функций являются указателями на функции**.

**Примечание: параметры по умолчанию не могут обрабатываться при вызове функции\
через указатель на функцию; в этом случае вам нужно будет явно передать значения\
для параметров по умолчанию.**

### Передача функций в качестве аргументов другим функциям
Одна из самых полезных вещей, которую вы можете сделать с указателями на\
функции — это передать функцию в качестве аргумента другой функции. Функции,\
используемые в качестве аргументов для других функций, называются **функциями\
обратного вызова**:
```c++
void customSort(int *array, int size, bool (*comparisonFcn)(int, int)) {
    ...
}

bool ascending(int a, int b) {
    return a > b; // меняем местами, если первый элемент больше второго
}

bool descending(int a, int b) {
    return a < b; // меняем местами, если второй элемент больше первого
}

int main() {
    // Сортируем массив в порядке убывания, используя функцию descending()
    customSort(array, 8, descending);
    
    // Сортируем массив в порядке возрастания, используя функцию ascending()
    customSort(array, 8, ascending);
}
```

### Параметры по умолчанию в функциях
```c++
// Сортировка по умолчанию выполняется в порядке возрастания
void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int) = ascending);
```

### Указатели на функции и псевдонимы типов
С помощью `typedefs` мы можем исправить синтаксис указателей на функции:
```c++
typedef bool (*validateFcn)(int, int);
```
Здесь мы определили псевдоним типа под названием `validateFcn`, который\
является указателем на функцию, которая принимает два значения типа `int` и\
возвращает значение типа `bool`.

Теперь вместо написания следующего:
```c++
bool validate(int a, int b, bool (*fcnPtr)(int, int)); // фу, какой синтаксис
```
Мы можем написать следующее:
```c++
bool validate(int a, int b, validateFcn pfcn) // вот это другое дело
```

Также можно использовать `type alias` для создания псевдонима типа указателя\
на функцию:
```c++
using validateFcn = bool(*)(int, int); // type alias

// И тогда точно также
bool validate(int a, int b, validateFcn pfcn)
```

### Использование `std::function` в C++11
```c++
#include <functional>

bool validate(int a, int b, std::function<bool(int, int)> fcn); // указываем
// указатель на функцию с помощью std::function, которая возвращает bool и
// принимает два int-а
```

Тогда код из начала урока примет вид:
```c++
#include <iostream>
#include <functional>

int boo() {
    return 7;
}

int doo() {
    return 8;
}

int main() {
    std::function<int()> fcnPtr; // объявляем указатель на функцию, который
    // возвращает int и не принимает никаких параметров
    fcnPtr = doo; // fcnPtr теперь указывает на функцию doo()
    std::cout << fcnPtr(); // вызываем функцию как обычно. Выведется 8
    
    return 0;
}
```

### Резюме
Указатели на функции полезны, прежде всего, когда вы хотите хранить функции в\
массиве (или в структуре) или когда вам нужно передать одну функцию в качестве\
аргумента другой функции. Поскольку синтаксис объявления указателей на функции\
является несколько уродливым и подвержен ошибкам, то рекомендуется\
использовать `type alias` или `std::function`.

### Тест
**Задание №1.**\
В этот раз мы попытаемся написать версию базового калькулятора с помощью\
указателей на функции.
```c++
#include <iostream>

int getInteger() {
    std::cout << "Enter an integer: ";
    int a;
    std::cin >> a;
    return a;
}

char getOperation() {
    char op;
    do {
        std::cout << "Enter an operation ('+', '-', '*', '/'): ";
        std::cin >> op;
    } while (op != '+' && op != '-' && op != '*' && op != '/');
    return op;
}

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int divide(int a, int b) {
    return a / b;
}

typedef int (*arithmeticFcn)(int, int);

arithmeticFcn getArithmeticFcn(char op) {
    switch (op) {
        default: // функцией по умолчанию будет add()
        case '+':
            return add;
        case '-':
            return subtract;
        case '*':
            return multiply;
        case '/':
            return divide;
    }
}

int main() {
    int a = getInteger();
    char op = getOperation();
    int b = getInteger();
    arithmeticFcn fcn = getArithmeticFcn(op);
    std::cout << a << ' ' << op << ' ' << b << " = " << fcn(a, b) << '\n';
    return 0;
}
```

**Задание №2.**\
Теперь давайте изменим программу, которую мы написали в первом задании,\
чтобы переместить логику из `getArithmeticFcn` в массив.
```c++
#include <iostream>

int getInteger() {
    std::cout << "Enter an integer: ";
    int a;
    std::cin >> a;
    return a;
}

char getOperation() {
    char op;
    do {
        std::cout << "Enter an operation ('+', '-', '*', '/'): ";
        std::cin >> op;
    } while (op != '+' && op != '-' && op != '*' && op != '/');
    return op;
}

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int divide(int a, int b) {
    return a / b;
}

typedef int(*arithmeticFcn)(int, int);

struct arithmeticStruct {
    char op;
    arithmeticFcn fcn;
};
static arithmeticStruct arithmeticArray[]{
        {'+', add},
        {'-', subtract},
        {'*', multiply},
        {'/', divide}
};

arithmeticFcn getArithmeticFcn(char op) {
    for (const auto &arith: arithmeticArray) {
        if (arith.op == op)
            return arith.fcn;
    }
    return add; // функцией по умолчанию будет add()
}

int main() {
    int a = getInteger();
    char op = getOperation();
    int b = getInteger();
    arithmeticFcn fcn = getArithmeticFcn(op);
    std::cout << a << ' ' << op << ' ' << b << " = " << fcn(a, b) << '\n';
    return 0;
}
```

## [Урок №111. Стек и Куча](#урок-111-стек-и-куча)
Память, которую используют программы, состоит из нескольких частей —\
**сегментов**:
* **Сегмент кода** (или «текстовый сегмент»), где находится скомпилированная\
  программа. Обычно доступен только для чтения.
* **Сегмент bss** (или «неинициализированный сегмент данных»), где хранятся\
  глобальные и статические переменные, инициализированные нулем.
* **Сегмент данных** (или «сегмент инициализированных данных»), где хранятся\
  инициализированные глобальные и статические переменные.
* **Куча**, откуда выделяются динамические переменные.
* **Стек вызовов**, где хранятся параметры функции, локальные переменные и\
  другая информация, связанная с функциями.

### Куча
**Сегмент кучи** (или просто **«куча»**) отслеживает память, используемую для\
динамического выделения.

**Куча имеет свои преимущества и недостатки:**
* Выделение памяти в куче сравнительно медленное.
* Выделенная память остается выделенной до тех пор, пока не будет\
  освобождена (остерегайтесь утечек памяти) или пока программа не завершит\
  свое выполнение.
* Доступ к динамически выделенной памяти осуществляется только через\
  указатель. Разыменование указателя происходит медленнее, чем доступ к\
  переменной напрямую.
* Поскольку куча представляет собой большой резервуар памяти, то именно\
  она используется для выделения больших массивов, структур или классов.

### Стек вызовов
**Стек вызовов** (или просто **«стек»**) отслеживает все активные функции (те, которые\
были вызваны, но еще не завершены) от начала программы и до текущей точки\
выполнения, и обрабатывает выделение всех параметров функции и локальных\
переменных.

### Стек как структура данных
**В стеке вы можете:**
* Посмотреть на верхний элемент стека (используя функцию `top()`\
  или `peek()`).
* Вытянуть верхний элемент стека (используя функцию `pop()`).
* Добавить новый элемент поверх стека (используя функцию `push()`).

**Стек** — это структура данных типа **LIFO** (англ. "**L**ast **I**n, **F**irst **O**ut" = \
"Последним пришел, первым ушел").

### Сегмент стека вызовов
«Элементы», которые мы добавляем или вытягиваем из стека, называются\
**фреймами** (или **«кадрами»**) **стека**. **Указатель стека** отслеживает\
вершину стека вызовов.

### Стек вызовов на практике
**Последовательность шагов, выполняемых при вызове функции:**
* Программа сталкивается с вызовом функции.
* Создается фрейм стека, который помещается в стек. Он состоит из:
  * адреса инструкции, который находится за вызовом функции (так\
    называемый **«обратный адрес»**). Так процессор запоминает, куда ему\
    возвращаться после выполнения функции;
  * аргументов функции;
  * памяти для локальных переменных;
  * сохраненных копий всех регистров, модифицированных функцией,\
    которые необходимо будет восстановить после того, как функция\
    завершит свое выполнение.
* Процессор переходит к точке начала выполнения функции.
* Инструкции внутри функции начинают выполняться.

**После завершения функции, выполняются следующие шаги:**
* Регистры восстанавливаются из стека вызовов.
* Фрейм стека вытягивается из стека. Освобождается память, которая была\
  выделена для всех локальных переменных и аргументов.
* Обрабатывается возвращаемое значение.
* ЦП возобновляет выполнение кода (исходя из обратного адреса).

### Переполнение стека
**Переполнение стека** (англ. **"stack overflow"**) происходит, когда запрашиваемой\
памяти нет в наличии (вся память уже занята).

**Стек имеет свои преимущества и недостатки:**
* Выделение памяти в стеке происходит сравнительно быстро.
* Память, выделенная в стеке, остается в области видимости до тех пор, пока\
  находится в стеке. Она уничтожается при выходе из стека.
* Вся память, выделенная в стеке, обрабатывается во время компиляции,\
  следовательно, доступ к этой памяти осуществляется напрямую через\
  переменные.
* Поскольку размер стека является относительно небольшим, то не\
  рекомендуется делать что-либо, что съест много памяти стека (например,\
  передача по значению или создание локальных переменных больших\
  массивов или других затратных структур данных).

## [Урок №112. Ёмкость вектора](#урок-112-ёмкость-вектора)
### Длина vs. Ёмкость
В отличие от фиксированного массива или `std::array`, которые запоминают\
только свою длину, `std::vector` имеет два отдельных свойства:
* **Длина в `std::vector`** — это количество фактически используемых элементов.
* **Ёмкость** (или **"вместимость"**) в `std::vector` — это количество выделенных\
  элементов.

```c++
std::vector<int> array {0, 1, 2, 3};
array.resize(6); // устанавливаем длину, равную 6

std::cout << array.size() << '\n'; // длина - 6
std::cout << array.capacity() << '\n'; // ёмкость - 6 
```

**Ёмкость всегда должна быть не меньше длины массива** (но может быть и больше),\
иначе доступ к элементам в конце массива будет за пределами выделенной памяти!

```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> array;
    array = { 0, 1, 2, 3, 4, 5 }; // ок, длина array равна 6
    std::cout << array.size() << " " << array.capacity() << '\n'; // 6 6
    array = { 8, 7, 6, 5 }; // ок, длина array теперь равна 4!
    std::cout << array.size() << " " << array.capacity() << '\n'; // 4 6 (активны только 4 элемента)

    return 0;
}
```

### Оператор индекса и функция `at()`
**Вектор не будет изменять свой размер из-за вызова оператора\
индекса или функции `at()`**

### `std::vector` в качестве стека
**3 ключевые функции вектора**, которые соответствуют 3-м ключевым\
операциям стека:
* **функция `push_back()`** — добавляет элемент в стек;
* **функция `back()`** — возвращает значение верхнего элемента стека;
* **функция `pop_back()`** — вытягивает элемент из стека.

```c++
#include <iostream>
#include <vector>

void printStack(const std::vector<int> &stack) {
    for (const auto &element: stack)
        std::cout << element << ' ';
    std::cout << "(cap " << stack.capacity() << " length " << stack.size() << ")\n";
}

int main() {
    std::vector<int> stack;
    printStack(stack); // (cap 0 length 0)

    stack.push_back(7); // функция push_back() добавляет элемент в стек
    printStack(stack); // 7 (cap 1 length 1)

    stack.push_back(4);
    printStack(stack); // 7 4 (cap 2 length 2)

    stack.push_back(1);
    printStack(stack); // 7 4 1 (cap 4 length 3)

    std::cout << "top: " << stack.back() << '\n'; // функция back() возвращает последний элемент - 1

    stack.pop_back(); // функция pop_back() вытягивает элемент из стека
    printStack(stack); // 7 4 (cap 4 length 2)

    stack.pop_back();
    printStack(stack); // 7 (cap 4 length 1)

    stack.pop_back();
    printStack(stack); // (cap 4 length 0)

    return 0;
}
```

Поскольку изменение размера вектора является затратной операцией, то мы\
можем сообщить вектору выделить заранее заданный объем ёмкости, используя\
**функцию `reserve()`**:
```c++
#include <iostream>
#include <vector>

void printStack(const std::vector<int> &stack) {
    for (const auto &element: stack)
        std::cout << element << ' ';
    std::cout << "(cap " << stack.capacity() << " length " << stack.size() << ")\n";
}

int main() {
    std::vector<int> stack;
    stack.reserve(7);
    printStack(stack); // (cap 7 length 0)

    stack.push_back(7); // функция push_back() добавляет элемент в стек
    printStack(stack); // 7 (cap 7 length 1)

    stack.push_back(4);
    printStack(stack); // 7 4 (cap 7 length 2)

    stack.push_back(1);
    printStack(stack); // 7 4 1 (cap 7 length 3)

    std::cout << "top: " << stack.back() << '\n'; // функция back() возвращает последний элемент - 1

    stack.pop_back(); // функция pop_back() вытягивает элемент из стека
    printStack(stack); // 7 4 (cap 7 length 2)

    stack.pop_back();
    printStack(stack); // 7 (cap 7 length 1)

    stack.pop_back();
    printStack(stack); // (cap 7 length 0)

    return 0;
}
```

### Дополнительная ёмкость
```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vect = { 0, 1, 2, 3, 4, 5 };
    std::cout << "size: " << vect.size() << " cap: " << vect.capacity() << '\n'; // size: 6 cap: 6
    vect.push_back(6); // добавляем другой элемент
    std::cout << "size: " << vect.size() << " cap: " << vect.capacity() << '\n'; // size: 7 cap: 12 (с запасом)
    
    return 0;
}
```

## [Урок №113. Рекурсия и Числа Фибоначчи](#урок-113-рекурсия-и-числа-фибоначчи)
**Рекурсивная функция** (или просто **"рекурсия"**) в языке C++ — это функция,\
которая вызывает сама себя. Например:

### Условие завершения рекурсии
**Условие завершения рекурсии** — это условие, которое, при его выполнении,\
остановит вызов рекурсивной функции самой себя.
```c++
// Возвращаем сумму всех чисел между 1 и value
int sumCount(int value) {
    if (value <= 0)
        return 0; // базовый случай (условие завершения)
    else if (value == 1)
        return 1; // базовый случай (условие завершения)
    else
        return sumCount(value - 1) + value; // рекурсивный вызов функции
}
```

### Рекурсивные алгоритмы
Случай, когда алгоритм при определенных данных ввода производит\
предсказуемые данные вывода, называется **базовым случаем**.

### Числа Фибоначчи
```
F(n) = 0, если n = 0
1, если n = 1
f(n-1) + f(n-2), если n > 1
```

```c++
#include <iostream>

int fibonacci(int number) {
    if (number == 0)
        return 0; // базовый случай (условие завершения)
    if (number == 1)
        return 1; // базовый случай (условие завершения)
    return fibonacci(number - 1) + fibonacci(number - 2);
}

// Выводим первые 13 чисел Фибоначчи
int main() {
    for (int count = 0; count < 13; ++count)
        std::cout << fibonacci(count) << " "; // 0 1 1 2 3 5 8 13 21 34 55 89 144
    return 0;
}
```

### Рекурсия vs. Итерации
**Совет:** Если рекурсивный алгоритм проще реализовать, то имеет смысл начать с\
рекурсии, а затем уже оптимизировать код в итеративный алгоритм.

**Правило: Рекомендуется использовать итерацию, вместо рекурсии, но в тех\
случаях, когда это действительно практичнее.**

### Тест
**Задание №1.**\
**Факториал целого числа N** определяется как умножение всех чисел между 1 и N (0!\
= 1). Напишите рекурсивную функцию factorial(), которая возвращает факториал\
ввода. Протестируйте её с помощью первых 8 чисел.
```c++
#include <iostream>

int factorial(int n) {
    if (n < 1)
        return 1;
    else
        return factorial(n - 1) * n;
}

int main() {
    for (int count = 0; count < 8; ++count)
        std::cout << factorial(count) << '\n';
}
```

**Задание №2.**\
Напишите рекурсивную функцию, которая принимает целое число в качестве\
входных данных и возвращает сумму всех чисел этого значения (например, 482 =\
4 + 8 + 2 = 14). Протестируйте вашу программу, используя число\
83569 (результатом должно быть 31).
```c++
#include <iostream>

int sumNumbers(int x) {
    if (x < 10)
        return x;
    else
        return sumNumbers(x / 10) + x % 10;
}

int main() {
    std::cout << sumNumbers(83569) << std::endl; // 31
}
```

**Задание №3.**\
Это уже немного сложнее. Напишите программу, которая просит пользователя\
ввести целое число, а затем использует рекурсивную функцию для вывода\
бинарного представления этого числа. Предполагается, что число, которое введет\
пользователь, является положительным.
```c++
#include <iostream>

void printBinary(int x) {
    if (x == 0) // Условие завершения
        return;
    printBinary(x / 2); // Рекурсия к следующему биту
    std::cout << x % 2; // Выводим остаток (в обратном порядке)
}

int main() {
    int x;
    std::cout << "Enter an integer: ";
    std::cin >> x;
    printBinary(x);
}
```

**Задание №4.**\
Используя программу из задания №3, обработайте случай, когда пользователь ввел\
`0` или отрицательное число, например:
```
Enter an integer: -14
11111111111111111111111111110010
```
```c++
#include <iostream>

void printBinaryDigits(unsigned int n) {
    if (n == 0) // Условие завершения
        return;
    printBinaryDigits(n / 2);
    std::cout << n % 2;
}

void printBinary(int n) {
    if (n == 0)
        std::cout << '0'; // выводим "0", если n == 0
    else
        printBinaryDigits(static_cast<unsigned int>(n));
}

int main() {
    int x;
    std::cout << "Enter an integer: ";
    std::cin >> x;
    printBinary(x);
}
```

## [Урок №114. Обработка ошибок, `cerr` и `exit()`](#урок-114-обработка-ошибок-cerr-и-exit)
### Семантические ошибки
**Семантическая** (или **"смысловая"**) **ошибка** возникает, когда код синтаксически\
правильный, но выполняет не то, что нужно программисту.

### Обработка ложных предположений
**Повторный ввод данных:**
```c++
#include <iostream>
#include <string>

int main() {
    std::string hello = "Hello, world!";
    int index;

    do {
        std::cout << "Enter an index: ";
        std::cin >> index;
        // Обрабатываем случай, когда пользователь ввел нецелочисленное значение
        if (std::cin.fail()) {
            std::cin.clear();
            std::cin.ignore(32767, '\n');
            index = -1; // убеждаемся, что index имеет недопустимое значение, чтобы цикл продолжался
            continue; // этот continue может показаться здесь лишним, но он явно указывает на
            // готовность прекратить выполнение этой итерации цикла
        }
    } while (index < 0 || index >= hello.size()); // обрабатываем случай,
    // когда пользователь ввел значение вне диапазона
    std::cout << "Letter #" << index << " is " << hello[index] << std::endl;

    return 0;
}
```

**`exit()` - для немедленного завершения программы и возврата кода ошибки:**
```c++
#include <cstdlib> // для exit()
#include <array>

int getArrayValue(const std::array<int, 20> &array, int index) {
    // Используем условие if для обнаружения ложного предположения
    if (index < 0 || index >= array.size())
        exit(2); // завершаем программу и возвращаем код ошибки 2 обратно в ОС

    return array[index];
}
```

**`cerr` целенаправленно используется для вывода сообщений об ошибках**, тогда\
как `cout` — для вывода всего остального:
```c++
void printString(const char *cstring) {
    // Выводим cstring при условии, что он не нулевой
    if (cstring)
        std::cout << cstring;
    else
        std::cerr << "function printString() received a null parameter";
}
```

## [Урок №115. `assert` и `static_assert`](#урок-115-assert-и-staticassert)
### Стейтмент `assert`
**Стейтмент `assert`** (или **"оператор проверочного утверждения"**) в языке C++ — это\
макрос препроцессора, который обрабатывает условное выражение во время\
выполнения. Если условное выражение истинно, то стейтмент `assert` ничего не\
делает. Если же оно ложное, то выводится сообщение об ошибке, и программа\
завершается:
```c++
#include <cassert> // для assert()

int getArrayValue(const std::array<int, 10> &array, int index) {
    // Предполагается, что значение index-а находится между 0 и 8
    assert(index >= 0 && index <= 8);
    return array[index];
}

// ravesli: /home/tarasqua/work/ravesli/main.cpp:9: 
// int getArrayValue(const std::array<int, 10>&, int): Assertion `index >= 0 && index <= 8' failed.
```

Также можно и выводить сообщения для уточнения ошибки:
```c++
assert(found && "Animal could not be found in database"); // так как строка - всегда true, а выражение - нет
// и если мы имеем false && true -> false
```

### `NDEBUG`
В языке C++ есть возможность отключить все assert-ы в релизном коде —\
использовать директиву `#define NDEBUG`:
```c++
#define NDEBUG

// Все стейтменты assert будут проигнорированы аж до самого конца этого файла
// В Clion в релизе включается по дефолту
```

### `static_assert`
В отличие от `assert`, который срабатывает во время выполнения программы,\
`static_assert` срабатывает во время компиляции, вызывая ошибку компилятора,\
если условие не является истинным. Если условие ложное, то выводится\
диагностическое сообщение:
```c++
static_assert(sizeof(long) == 8, "long must be 8 bytes");
static_assert(sizeof(int) == 4, "int must be 4 bytes");

int main() {
    return 0;
}
// static assertion failed: long must be 8 bytes
```

## [Урок №116. Аргументы командной строки](#урок-116-аргументы-командной-строки)
**Аргументы командной строки** — это необязательные строковые аргументы,\
передаваемые операционной системой в программу при её запуске.

### Передача аргументов командной строки
```c++
int main(int argc, char *argv[]) // предпочтительнее
// Или
int main(int argc, char** argv)
```

`argc` (англ. "**arg**ument **c**ount" = "количество аргументов") — это целочисленный\
параметр, содержащий количество аргументов, переданных в программу. `argc`\
всегда будет как минимум один, так как первым аргументом всегда является имя\
самой программы. Каждый аргумент командной строки, который предоставляет\
пользователь, заставит `argc` увеличиться на единицу.

`argv` (англ. "**arg**ument **v**alues" = "значения аргументов") — это место, где хранятся\
фактические значения аргументов. Хотя объявление `argv` выглядит немного\
пугающе, но это всего лишь массив строк C-style. Длиной этого массива является `argc`.

```c++
// выводим все значения командной строки
#include <iostream>

int main(int argc, char *argv[]) {
    std::cout << "There are " << argc << " arguments:\n"; // There are 1 arguments:

    // Перебираем каждый аргумент и выводим его порядковый номер и значение
    for (int count=0; count < argc; ++count) // Нулевой параметр — это путь и имя текущей программы
        std::cout << count << " " << argv[count] << '\n'; // 0 /home/tarasqua/work/ravesli/cmake-build-debug/ravesli

    return 0;
}
```

### Обработка числовых аргументов
**Аргументы командной строки всегда передаются в качестве строк.**

Конвертация аргумента из строки в число:
```c++
#include <sstream> // для std::stringstream
// создаем переменную stringstream с именем convert, инициализируя её значением argv[1]
std::stringstream convert(argv[1]);

int myint;
if (!(convert >> myint)) // выполняем конвертацию
    myint = 0; // если конвертация терпит неудачу, то присваиваем myint значение по умолчанию
```

## [Урок №117. Эллипсис](#урок-117-эллипсис)
### Эллипсис
```
тип_возврата имя_функции(список_аргументов, ...)
```
**Эллипсис** (англ. **"ellipsis"**), который представлен в виде многоточия `…` в языке C++,\
всегда должен быть последним параметром в функции.
```c++
#include <iostream>
#include <cstdarg> // требуется для использования эллипсиса

// Эллипсис должен быть последним параметром.
// Переменная count - это количество переданных аргументов
double findAverage(int count, ...) {
    double sum = 0;
    // Мы получаем доступ к эллипсису через va_list, поэтому объявляем
    // переменную этого типа
    va_list list;
    // Инициализируем va_list, используя va_start. Первый параметр – это
    // список, который нужно инициализировать.
    // Второй параметр - это последний параметр, который не является эллипсисом
    va_start(list, count);
    // Перебираем каждый из аргументов эллипсиса
    for (int arg = 0; arg < count; ++arg)
        // Используем va_arg для получения параметров из эллипсиса.
        // Первый параметр - это va_list, который мы используем.
        // Второй параметр - это ожидаемый тип параметров
        sum += va_arg(list, int);

    // Выполняем очистку va_list, когда уже сделали всё необходимое
    va_end(list);
    return sum / count;
}

int main() {
    std::cout << findAverage(4, 1, 2, 3, 4) << '\n'; // 2.5
    std::cout << findAverage(5, 1, 2, 3, 4, 5) << '\n'; // 3
}
```

## [Урок №118. Лямбда-выражения](#урок-118-лямбда-выражения)
### Введение в лямбда-выражения
**Лямбда-выражение** (или просто **«лямбда»**) **в программировании позволяет\
определить анонимную функцию внутри другой функции.**

**Лямбда-выражения имеют следующий синтаксис** (поля captureClause и параметры могут быть пустыми):
```
[ captureClause ] ( параметры ) -> возвращаемыйТип
{
стейтменты;
}
```

Тривиальное определение лямбды:
```c++
#include <iostream>

int main() {
    []() {}; // определяем лямбда-выражение без captureClause, параметров и возвращаемого типа
    return 0;
}
```

Нахождение слова `nut` в списке:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

bool containsNut(std::string_view str) {
    // std::string_view::find возвращает std::string_view::npos, если он не нашел подстроку.
    // В противном случае, он возвращает индекс, где происходит вхождение подстроки в строку str
    return (str.find("nut") != std::string_view::npos);
}

int main() {
    std::array<std::string_view, 4> arr{"apple", "banana", "walnut", "lemon"};
    // Определяем функцию непосредственно в том месте, где собираемся её использовать, 
    // вместо использования containsNut
    auto found{std::find_if(
            arr.begin(), arr.end(),
            [](std::string_view str) // вот наша лямбда, без поля captureClause
            {
                return (str.find("nut") != std::string_view::npos);
            })
    };

    if (found == arr.end())
        std::cout << "No nuts\n";
    else
        std::cout << "Found " << *found << '\n';

    return 0;
}
```

### Тип лямбда-выражений
В примере, приведенном выше, мы определили лямбду прямо в том месте, где она\
была нам нужна. Такое использование лямбда-выражения иногда еще называют\
**функциональным литералом**.

Объявление лямбда-переменной:
```c++
// Мы можем хранить лямбду в именованной переменной и передавать её в
// функцию в качестве параметра
auto isEven{
        [](int i) {
            return ((i % 2) == 0);
        }
};

std::array<int, 4> array{1, 5, 8, 12};
return std::all_of(array.begin(), array.end(), isEven);
```

**Для продвинутых читателей:** На самом деле, лямбды не являются функциями\
(что и помогает им избегать ограничений C++, которые накладываются на\
использование вложенных функций). Лямбды являются особым типом объектов,\
который называется функтором. **Функторы** — это объекты, содержащие\
перегруженный `operator()`, который и делает их вызываемыми подобно обычным\
функциям.

Если лямбда ничего не захватывает, то мы можем использовать обычный указатель\
на функцию. Как только лямбда что-либо захватывает, указатель на функцию\
больше не будет работать. Однако `std::function` может использоваться для лямбд,\
даже если они что-то захватывают:
```c++
#include <functional>

int main() {
    // Обычный указатель на функцию. Лямбда не может ничего захватить
    double (*addNumbers1)(double, double){
            [](double a, double b) {
                return (a + b);
            }
    };
    addNumbers1(1, 2); // 3

    // Используем std::function. Лямбда может захватывать переменные
    std::function addNumbers2{
            [](double a, double b) {
                return (a + b);
            }
    };
    addNumbers2(3, 4); // 7

    // Используем auto. Храним лямбду с её реальным типом
    auto addNumbers3{
            [](double a, double b) {
                return (a + b);
            }
    };
    addNumbers3(5, 6); // 11

    return 0;
}
```

В тех случаях, когда фактический тип лямбды неизвестен мы не можем использовать `auto`:
```c++
#include <functional>
#include <iostream>

// Мы не знаем, чем будет fn. std::function работает с обычными функциями и лямбдами
void repeat(int repetitions, const std::function<void(int)> &fn) {
    for (int i{0}; i < repetitions; ++i) {
        fn(i);
    }
}

int main() {
    repeat(3, [](int i) {
        std::cout << i << '\n'; // 0 1 2
    });

    return 0;
}
```

**Правило: Используйте `auto` при инициализации переменных с помощью лямбд и\
`std::function`, если вы не можете инициализировать переменную с помощью лямбд.**

### Общие/Обобщённые лямбды
Поскольку лямбды с одним или несколькими параметрами типа auto потенциально\
могут работать с большим количество типов данных, то они называются **общими**\
(или **«обобщёнными»** от англ. "generic lambdas") **лямбдами**.

```c++
#include <algorithm>
#include <array>
#include <iostream>

int main() {

    std::array months{
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
    };
    // Поиск двух последовательных месяцев, которые начинаются с одинаковой буквы
    auto sameLetter{
            std::adjacent_find(
                    months.begin(), months.end(),
                    [](const auto &a, const auto &b) { // использование константной ссылки и auto
                        return (a[0] == b[0]);
                    })};
    // Убеждаемся, что эти два месяца были найдены
    if (sameLetter != months.end()) {
        std::cout << *sameLetter << " and " << *std::next(sameLetter) << " start with the same letter\n";
    } // June and July start with the same letter
    
    // Подсчитываем количество месяцев с названиями в 5 букв
    auto fiveLetterMonths{
            std::count_if(months.begin(), months.end(),
                          [](std::string_view str) { // явно определяем тип, так как в противном случае, 
                                                    // через auto будет выведен тип const char*
                              return (str.length() == 5);
                          })};
    std::cout << "There are " << fiveLetterMonths << " months with 5 letters\n";

    return 0;
}
```

### Общие лямбды и статические переменные
**Для каждого отдельного типа, выводимого с помощью `auto`, будет сгенерирована\
уникальная лямбда:**
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

int main() {
    // Выводим значение и подсчитываем, сколько раз будет вызван print с определенным типом входных данных
    auto print{
            [](auto value) {
                static int callCount{0};
                std::cout << callCount++ << ": " << value << '\n';
            }
    };

    print("hello"); // 0: hello
    print("world"); // 1: world

    print(1); // 0: 1
    print(2); // 1: 2

    print("ding dong"); // 2: ding dong

    return 0;
}
```

Если бы мы хотели, чтобы `callCount` был общим для лямбд, то нам пришлось бы\
объявить его вне лямбды и захватить его по ссылке, чтобы он мог быть изменен\
лямбдой.
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

int main() {
    int callCount{0};
    auto print{
            [](auto value, int &callCount) {
                std::cout << callCount++ << ": " << value << '\n';
            }
    };

    print("hello", callCount); // 0: hello
    print("world", callCount); // 1: world

    print(1, callCount); // 2: 1
    print(2, callCount); // 3: 2

    print("ding dong", callCount); // 4: ding dong

    return 0;
}
```

### Вывод возвращаемого типа и возвращаемые типы `trailing`
**Все возвращаемые стейтменты внутри лямбды должны возвращать значения\
одного и того же типа:**
```c++
#include <iostream>

int main() {
    auto divide{
        [](int x, int y, bool bInteger) { // примечание: Не указан тип
        // возвращаемого значения
        if (bInteger)
            return x / y;
        else
            return static_cast<double>(x) / y; // ОШИБКА: Тип возвращаемого
            // значения не совпадает с предыдущим возвращаемым типом
    }};

    std::cout << divide(3, 2, true) << '\n';
    std::cout << divide(3, 2, false) << '\n';

    return 0;
}
```

В данном случае мы можем явно указать тип возвращаемого значения для лямбды и\
позволить компилятору выполнить неявные преобразования:
```c++
#include <iostream>

int main() {
    auto divide{
        [](int x, int y, bool bInteger) -> double { // примечание: Не указан тип
        // возвращаемого значения
        if (bInteger)
            return x / y;
        else
            return static_cast<double>(x) / y; // ОШИБКА: Тип возвращаемого
            // значения не совпадает с предыдущим возвращаемым типом
    }};

    std::cout << divide(3, 2, true) << '\n';
    std::cout << divide(3, 2, false) << '\n';

    return 0;
}
```

### Тест
**Задание №1.**\
Создайте структуру `Student`, которая будет хранить имя и баллы студента.\
Создайте массив студентов и используйте функцию `std::max_element()` для поиска\
студента с наибольшими баллами, а затем выведите на экран имя найденного\
студента. Функция `std::max_element() `принимает `begin` и `end` списка, и функцию с\
двумя параметрами, которая возвращает `true`, если первый аргумент меньше\
второго.
```c++
#include <array>
#include <iostream>
#include <string>
#include <algorithm>

struct Student {
    std::string name{};
    int points{};
};

int main() {
    std::array<Student, 8> arr{
            {{"Albert", 3},
             {"Ben", 5},
             {"Christine", 2},
             {"Dan", 8},
             {"Enchilada", 4},
             {"Francis", 1},
             {"Greg", 3},
             {"Hagrid", 5}}
    };

    auto best{std::max_element(
            arr.begin(), arr.end(),
            [](const auto &a, const auto &b) {
                return (a.points < b.points);
            })
    };
    std::cout << best->name << " is the best student\n"; // Dan is the best student
    return 0;
}
```

**Задание №2.**\
Используйте `std::sort()` и лямбду в следующем коде для сортировки времен года по\
возрастанию средней температуры:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

struct Season {
    std::string_view name{};
    double averageTemperature{};
};

int main() {
    std::array<Season, 4> seasons{
            {{"Spring", 285.0},
             {"Summer", 296.0},
             {"Fall", 288.0},
             {"Winter", 263.0}}
    };

    // Лямбде не нужно даже ничего захватывать, потому что порядок зависит только от
    // элементов массива, которые мы получаем в качестве параметров.
    // Мы можем сравнить averageTemperature двух аргументов для сортировки массива
    std::sort(
            seasons.begin(), seasons.end(),
            [](const auto &a, const auto &b) {
                return (a.averageTemperature < b.averageTemperature);
            });
    for (const auto &season: seasons) {
        std::cout << season.name << ' '; // Winter Spring Fall Summer
    }
    return 0;
}
```

## [Урок №119. Лямбда-захваты](#урок-119-лямбда-захваты)
### Введение в лямбда-захваты
Поле `capture clause` используется для того, чтобы предоставить (косвенно)\
лямбде доступ к переменным из окружающей области видимости, к которым она\
обычно не имеет доступ. Всё, что нам нужно для этого сделать, так это перечислить\
в поле capture clause объекты, к которым мы хотим получить доступ внутри\
лямбды.\
Тогда код для нахождения подстроки, но с введенным значением для поиска пользователем,\
будет выглядеть так:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>
#include <string>

int main() {
    std::array<std::string_view, 4> arr{"apple", "banana", "walnut", "lemon"};
    // Просим пользователя ввести объект для поиска
    std::cout << "search for: "; // nana
    std::string search{};
    std::cin >> search;

    auto found{
            std::find_if(
                    arr.begin(), arr.end(),
                    [&search](std::string_view str) { // Захват переменной search
                        // Ищем значение переменной search, вместо подстроки "nut"
                        return (str.find(search) != std::string_view::npos);
                    })
    };

    if (found == arr.end()) {
        std::cout << "Not found\n";
    } else {

        std::cout << "Found " << *found << '\n'; // Found banana
    }

    return 0;
}
```

### Суть работы лямбда-захватов
**Ключевой момент: Переменные, захваченные лямбдой, являются клонами\
переменных из внешней области видимости, а не фактическими «внешними»\
переменными.**

**Для продвинутых читателей:** Когда компилятор обнаруживает определение\
лямбды, он создает для нее определение как для пользовательского объекта.\
Каждая захваченная переменная становится элементом данных этого объекта. Во\
время выполнения программы, при обнаружении определения лямбды, создается\
экземпляр объекта лямбды и в этот момент инициализируются члены лямбды.

### Захваты переменных и `const`
По умолчанию **переменные захватываются как константные значения**. Это означает,\
что при создании лямбды, она захватывает константную копию переменной из\
внешней области видимости, что означает, что значения этих переменных лямбда\
изменить не может.

### Захват по значению
Чтобы разрешить изменения значения переменных, которые были захвачены по\
значению, мы можем пометить лямбду как `mutable`. **Ключевое слово `mutable`**\
удаляет спецификатор const со всех переменных, захваченных по значению:
```c++
#include <iostream>

int main() {
    int ammo{10};
    auto shoot{
            [ammo]() mutable { // Добавляем ключевое слово mutable после списка параметров
                --ammo; // Теперь нам разрешено изменять значение переменной ammo
                std::cout << "Pew! " << ammo << " shot(s) left.\n";
            }
    };
    shoot(); // Pew! 9 shot(s) left.
    shoot(); // Pew! 8 shot(s) left.
    std::cout << ammo << " shot(s) left\n"; // 10 shot(s) left

    return 0;
}
```
При вызове лямбда захватила копию переменной `ammo`. Затем, когда лямбда\
уменьшает значение переменной `ammo` с 10 до 9 и до 8, то, на самом деле,\
она уменьшает значение копии, а не исходной переменной.

### Захват по ссылке
Подобно тому, как функции могут изменять значения аргументов, передаваемых им\
по ссылке, мы также можем захватывать переменные по ссылке, чтобы позволить\
нашей лямбде влиять на значения аргументов.

Чтобы захватить переменную по ссылке, мы должны добавить знак амперсанда (`&`)\
к имени переменной, которую хотим захватить. В отличие от переменных, которые\
захватываются по значению, переменные, которые захватываются по ссылке, не\
являются константными (если только переменная, которую они захватывают, не\
является изначально `const`):
```c++
#include <iostream>

int main() {
    int ammo{10};
    auto shoot{
            [&ammo]() { // &ammo означает, что переменная ammo захватывается по ссылке
                --ammo; // Изменения текущей переменной ammo приведут к изменению переменной ammo из блока main()
                std::cout << "Pew! " << ammo << " shot(s) left.\n";
            }
    };
    shoot(); // Pew! 9 shot(s) left.
    shoot(); // Pew! 8 shot(s) left.
    std::cout << ammo << " shot(s) left\n"; // 8 shot(s) left

    return 0;
}
```

Теперь давайте воспользуемся захватом по ссылке, чтобы подсчитать, сколько\
сравнений делает алгоритм `std::sort()` при сортировке массива:
```c++
#include <algorithm>
#include <array>
#include <iostream>
#include <string>

struct Car {
    std::string make{};
    std::string model{};
};

int main() {
    std::array<Car, 3> cars{
            {{"Volkswagen", "Golf"},
             {"Toyota", "Corolla"},
             {"Honda", "Civic"}
            }};
    int comparisons{0};
    std::sort(
            cars.begin(), cars.end(),
            // Захват переменной comparisons по ссылке
            [&comparisons](const auto &a, const auto &b) {
                // Мы захватили переменную comparisons по ссылке, а это означает, что
                // мы можем изменять её без использования спецификатора mutable
                ++comparisons;
                // Сортировка машин по марке
                return (a.make < b.make);
            });

    std::cout << "Comparisons: " << comparisons << '\n'; // 2
    for (const auto &car: cars) {
        std::cout << car.make << ' ' << car.model << ';' << ' '; // Honda Civic; Toyota Corolla; Volkswagen Golf
    }

    return 0;
}
```

### Захват нескольких переменных
```c++
int health{ 33 };
int armor{ 100 };
std::vector<CEnemy> enemies{};

// Захватываем переменные health и armor по значению, а enemies – по ссылке
[health, armor, &enemies](){};
```

### Захваты по умолчанию
**Захват по умолчанию захватывает все переменные, упомянутые в лямбде.** Если\
используется захват по умолчанию, то переменные, не упомянутые в лямбде, не\
будут захвачены.

Чтобы захватить **все задействованные переменные по значению**, используйте `=` в\
качестве значения для захвата. Чтобы захватить в**се задействованные переменные\
по ссылке**, используйте `&` в качестве значения для захвата.
```c++
#include <array>
#include <iostream>
#include <algorithm>

int main() {
    std::array areas{100, 25, 121, 40, 56};

    int width{};
    int height{};

    std::cout << "Enter width and height: ";
    std::cin >> width >> height;

    auto found{std::find_if(
            areas.begin(), areas.end(),
            [=](int knownArea) { // выполняется захват по умолчанию по значению переменных width и height
                return (width * height == knownArea); // потому что они здесь упомянуты
            })};

    if (found == areas.end()) {
        std::cout << "I don't know this area :(\n";
    } else {
        std::cout << "Area found :)\n";
    }

    return 0;
}
```

Захваты по умолчанию могут быть смешаны с обычными захватами. Вполне\
допускается захватить некоторые переменные по значению, а другие — по ссылке,\
но при этом каждая переменная может быть захвачена только один раз:
```c++
int health{ 33 };
int armor{ 100 };
std::vector<CEnemy> enemies{};

// Захватываем переменные health и armor по значению, а enemies – по ссылке
[health, armor, &enemies](){};

// Захватываем переменную enemies по ссылке, а все остальные – по значению
[=, &enemies](){};

// Захватываем переменную armor по значению, а все остальные – по ссылке
[&, armor](){};

// Запрещено, так как мы уже определили захват по ссылке для всех переменных
[&, &armor](){};

// Запрещено, так как мы уже определили захват по значению для всех переменных
[=, armor](){};

// Запрещено, так как переменная armor используется дважды
[armor, &health, &armor](){};

// Запрещено, так как захват по умолчанию должен быть первым элементом в списке захвата
[armor, &](){};
```

### Определение новых переменных в лямбда-захвате
```c++
#include <array>
#include <iostream>
#include <algorithm>

int main() {
    std::array areas{100, 25, 121, 40, 56};
    int width{};
    int height{};
    std::cout << "Enter width and height: ";
    std::cin >> width >> height;

    // Мы храним переменную areas, но пользователь ввел width и height.
    // Прежде, чем выполнить операцию поиска, мы должны вычислить значение площади (area)
    auto found{std::find_if(
            areas.begin(), areas.end(),
            // Объявляем новую переменную, которая видима только для лямбды.
            // Тип переменной userArea автоматически выведен как тип int
            [userArea {width * height}](int knownArea) { // userArea будет определена единожды - 
                return (userArea == knownArea);         // во время определения лямбды
            })
    };
    if (found == areas.end()) {
        std::cout << "I don't know this area :(\n";
    } else {
        std::cout << "Area found :)\n";
    }

    return 0;
}
```

**Совет:** Инициализируйте переменные в захвате только в том случае, если их\
значения не являются слишком большими и их тип очевиден. В противном случае,\
лучше всего определить переменную вне лямбды, а затем захватить её.

### Непреднамеренные копии лямбд
**Тип `std::ref`** (как часть заголовочного файла functional), который позволяет\
нам передавать обычный тип, как если бы это была ссылка. Обёртывая нашу лямбду в\
`std::ref` всякий раз, когда кто-либо пытается сделать копию нашей лямбды, он\
будет делать копию ссылки, а не фактического объекта:
```c++
#include <iostream>
#include <functional>

void invoke(const std::function<void(void)> &fn) {
    fn();
}

int main() {
    int i{0};

    // Выполняем инкремент и выводим на экран локальную копию переменной i
    auto count{[i]() mutable {
        std::cout << ++i << '\n';
    }};

    // std::ref(count) гарантирует, что count рассматривается, как ссылка.
    // Таким образом, всё, что пытается скопировать count, фактически является
    // ссылкой, гарантируя тем самым существование только одного объекта count
    invoke(std::ref(count)); // 1
    invoke(std::ref(count)); // 2
    invoke(std::ref(count)); // 3
    
    return 0;
}
```

**Правило: Стандартные библиотечные функции могут копировать\
функциональные объекты (напомним, что лямбды принадлежат к категории\
функциональных объектов). Если вы хотите использовать лямбду вместе с\
изменяемыми захваченными переменными, то передавайте их по ссылке с\
помощью `std::ref`.**

### Тест
**Задание №3.**
```c++
#include <algorithm> // для std::generate(), std::find() и std::min_element()
#include <cmath> // для std::abs()
#include <ctime>
#include <iostream>
#include <random>
#include <vector>

using list_type = std::vector<int>;
namespace config {
    constexpr int multiplierMin{2};
    constexpr int multiplierMax{4};
    constexpr int maximumWrongAnswer{4};
}

int getRandomInt(int min, int max) {
    static std::mt19937 mt{static_cast<std::mt19937::result_type>(std::time(nullptr))};
    return std::uniform_int_distribution{min, max}(mt);
}

// Генерируем количество чисел, указанное в count, начиная со start*start, и
// умножаем каждое число в квадрате на множитель (multiplier)
list_type generateNumbers(int start, int count, int multiplier) {
    list_type numbers(static_cast<list_type::size_type>(count));
    int i{start};
    for (auto &number: numbers) {
        number = ((i * i) * multiplier);
        ++i;
    }
    return numbers;
}

// Просим пользователя ввести стартовое число и общее количество чисел, а затем
// вызываем generateNumbers()
list_type generateUserNumbers(int multiplier) {
    int start{};
    int count{};
    std::cout << "Start where? ";
    std::cin >> start;
    std::cout << "How many? ";
    std::cin >> count;
    // Здесь пропущена проверка пользовательского ввода. Все функции
    // подразумевают корректный пользовательский ввод
    return generateNumbers(start, count, multiplier);
}

int getUserGuess() {
    int guess{};
    std::cout << "> ";
    std::cin >> guess;
    return guess;
}

// Ищем значение guess в numbers и удаляем его.
// Возвращаем true, если значение было найдено, в противном случае – возвращаем false
bool findAndRemove(list_type &numbers, int guess) {
    if (auto found{std::find(
                numbers.begin(), numbers.end(), guess)};
            found == numbers.end()) {
        return false;
    } else {
        numbers.erase(found);
        return true;
    }
}

// Находим значение в numbers, которое ближе всего к guess
int findClosestNumber(const list_type &numbers, int guess) {
    return *std::min_element(
            numbers.begin(), numbers.end(),
            [=](int a, int b) {
                return (std::abs(a - guess) < std::abs(b - guess));
            });
}

void printTask(list_type::size_type count, int multiplier) {
    std::cout << "I generated " << count
              << " square numbers. Do you know what each number is after multiplying it by "
              << multiplier << "?\n";
}

// Вызывается, когда пользователь угадывает число
void printSuccess(list_type::size_type numbersLeft) {
    std::cout << "Nice! ";
    if (numbersLeft == 0) {
        std::cout << "You found all numbers, good job!\n";
    } else {
        std::cout << numbersLeft << " number(s) left.\n";
    }
}

// Вызывается, когда пользователь указывает число, которого нет в numbers
void printFailure(const list_type &numbers, int guess) {
    int closest{findClosestNumber(numbers, guess)};
    std::cout << guess << " is wrong!";
    if (std::abs(closest - guess) <= config::maximumWrongAnswer) {
        std::cout << " Try " << closest << " next time.\n";
    } else {
        std::cout << '\n';
    }
}

// Возвращаем false, если игра окончена, в противном случае - возвращаем true
bool playRound(list_type &numbers) {
    int guess{getUserGuess()};
    if (findAndRemove(numbers, guess)) {
        printSuccess(numbers.size());
        return !numbers.empty();
    } else {
        printFailure(numbers, guess);
        return false;
    }
}

int main() {
    int multiplier{getRandomInt(config::multiplierMin, config::multiplierMax)};
    list_type numbers{generateUserNumbers(multiplier)};
    printTask(numbers.size(), multiplier);
    while (playRound(numbers));
    return 0;
}
```

## [Глава №7. Итоговый тест](#глава-7-итоговый-тест)
### Теория
Аргументы функций могут передаваться по значению, по ссылке или по адресу.\
Используйте:
* **передачу по значению** для фундаментальных типов данных и\
  перечислителей;
* **передачу по (константной) ссылке** для структур, классов или в тех случаях,\
  когда нужно, чтобы функция изменяла значение аргумента;
* **передачу по адресу** для указателей или обычных массивов.

В большинстве случаев используется **возврат по значению**, однако **возврат по\
ссылке** или **по адресу** также может быть полезен при работе с динамически\
выделенными массивами, структурами или классами. Если используете возврат по\
ссылке или по адресу, то убедитесь, что не возвращаете чего-то, что выйдет из\
локальной области видимости.

С помощью **встроенных функций** вызов функции можно заменить на\
непосредственный код этой функции.

**Перегрузка функций** позволяет создать несколько функций с одним и тем же\
именем, но при условии, что параметры этих функций будут разные. Возвращаемое\
значение не считается параметром.

**Параметр по умолчанию** — это параметр функции, который имеет значение по\
умолчанию. Если caller не передает значение для параметра, то будет\
использоваться значение по умолчанию. У вас может быть несколько параметров со\
значениями по умолчанию. Они всегда должны находиться справа от обычных\
параметров. Параметр по умолчанию может быть установлен только в одном месте.\
Обычно его размещают в предварительном объявлении функции. Если же\
предварительного объявления нет, то его размещают в определении функции.

**Указатели на функции** позволяют передать одну функцию в качестве аргумента\
другой функции.

Динамическая память выделяется из **кучи**.

**Стек вызовов** отслеживает все активные функции (те, которые были вызваны, но\
еще не завершены) от начала программы и до текущей точки выполнения. Стек\
имеет ограниченный размер.

`std::vector` можно использовать в качестве стека.

**Рекурсивная функция** — это функция, которая вызывает сама себя. Для всех\
рекурсивных функций требуется условие завершения.

**Семантическая ошибка** возникает, когда код синтаксически правильный, но\
выполняет не то, что нужно программисту. Среди семантических ошибок\
распространены **логические ошибки** и **ложные предположения**.

Стейтмент `assert` используется для обнаружения ложных предположений, но его\
недостаток заключается в том, что при ложном утверждении выполнение\
программы немедленно прекращается.

**Аргументы командной строки** позволяют пользователям или другим программам\
передавать данные в программу при её запуске. Аргументы командной строки\
всегда являются строками C-style и для использования числовых значений вам\
нужно будет конвертировать строки в числовые типы данных.

**Эллипсис** позволяет передать переменную, указывающую на количество всех\
передаваемых аргументов, в функцию. Однако при таком раскладе игнорируется\
проверка типов, что крайне нежелательно и может привести к проблемам.

### Тест
**Задание №3.**\
a) Итеративная реализация:
```c++
// array - это массив, в котором мы проводим поиски.
// target - это искомое значение.
// min - это индекс минимальной границы массива, в котором мы осуществляем поиск.
// max - это индекс максимальной границы массива, в котором мы осуществляем поиск.
// Функция binarySearch() должна возвращать индекс искомого значения, если он
// обнаружен. В противном случае, возвращаем -1
int binarySearch(int *array, int target, int min, int max) {
    while (min <= max) {
        int midpoint = min + ((max - min) / 2); // такой способ вычисления середины массива избегает вероятность
        // возникновения переполнения
        if (array[midpoint] > target) {
            // Если array[midpoint] > target, то тогда понимаем, 
            // что искомое число не находится в правой половине массива.
            // Мы можем использовать midpoint - 1 в качестве индекса максимальной границы, 
            // так как в следующей итерации этот индекс вычислять не нужно
            max = midpoint - 1;
        } else if (array[midpoint] < target) {
            // Если array[midpoint] < target, то тогда понимаем, 
            // что искомое число не находится в левой половине массива.
            // Мы можем использовать midpoint + 1 в качестве индекса минимальной границы, 
            // так как в следующей итерации этот индекс вычислять не нужно
            min = midpoint + 1;
        } else
            return midpoint;
    }
    return -1;
}
```

b) Рекурсивная реализация:
```c++
// array - это массив, в котором мы проводим поиски.
// target - это искомое значение.
// min - это индекс минимальной границы массива, в котором мы осуществляем поиск.
// max - это индекс максимальной границы массива, в котором мы осуществляем поиск.
// Функция binarySearch() должна возвращать индекс искомого значения, если он
// обнаружен. В противном случае, возвращаем -1
int binarySearch(int *array, int target, int min, int max) {
    if (min > max)
        return -1;
    // такой способ вычисления середины массива избегает вероятность возникновения переполнения
    int midpoint = min + ((max - min) / 2); 
    if (array[midpoint] > target) {
        return binarySearch(array, target, min, midpoint - 1);
    } else if (array[midpoint] < target) {
        return binarySearch(array, target, midpoint + 1, max);
    } else
        return midpoint;
}
```