## Урок 42. Арифметические операторы

**`static_cast\<type>(expression)` для конвертации типов данных**
```c++
int main() {
int x = 7;
int y = 4;

std::cout << "int / int = " << x / y << "\n";  // int / int = 1
std::cout << "double / int = " << static_cast<double>(x) / y << "\n";  // double / int = 1.75
std::cout << "int / double = " << x / static_cast<double>(y) << "\n";  // int / double = 1.75
std::cout << "double / double = " << static_cast<double>(x) / static_cast<double>(y) << "\n";  // double / double = 1.75

return 0;
}
```

## Урок 43. Инкремент, декремент и побочные эффекты

```c++
// Префикс
// значение сначала увеличивается, а затем уже вычисляется
int x = 5;
int y = ++x;  // x = 6 и 6 присваивается y
```

```c++
// Постфикс
// Компилятор создает временную копию переменной x, увеличивает оригинальный x,
// а затем возвращает копию. Только после возврата копия x удаляется 
int x = 5;
int y = x++;  // x = 6, но переменной y присваивается 5
```

```c++
int add(int x, int y){
    return x + y;
}

int main() {
    int x = 5;
    std::cout << add(x, x++);  // 11
    std::cout << add(x, ++x);  // 12
    
    return 0;
}
```

```c++
int main(){
    int x = 1;
    x = x++;
    std::cout << x;  // 1
    
    return 0;
}
```

## Урок №44. Условный тернарный оператор, оператор `sizeof` и Запятая

```c++
z = (a, b); // сначала вычисляется выражение (a, b), которое равняется значению b, а затем результат присваивается переменной z
z = a, b; // вычисляется как "(z = a), b", поэтому переменной z присваивается значение a, переменная b - игнорируется
```

Условный (тернарный) оператор (обозначается как `?:`) является единственным тернарным\
оператором в языке С++, который работает с 3-мя операндами.

```c++
    c ? x : y  // Если c — ненулевое значение (true), то вычисляется x, в противном случае — y
```

Оператор ?: предоставляет сокращенный способ (альтернативу) ветвления if/else.\
Стейтменты if/else:

```c++
if (условие)
    выражение;
else
    другое_выражение;
```

Можно записать как:

```c++
(условие) ? выражение : другое_выражение;
```

Еще примеры:

```c++
// Привычный способ
if (x > y)
larger = x;
else
larger = y;

// Через тернарный оператор
larger = (x > y) ? x : y;
```

Помните, что оператор ?: имеет очень низкий приоритет, из-за этого его следует
записывать в круглых скобках.

```c++
int x = 0, y = 2;
std::cout << ((x > y) ? x : y);  // 2
std::cout << (x > y) ? x : y;  // 0
```

## Урок №45. Операторы сравнения

```c++
#include <iostream>

int main() {
    double d1(100 - 99.99); // должно быть 0.01, но = 0.0100000000000005116
    double d2(10 - 9.99); // должно быть 0.01, но = 0.0099999999999997868
    
    if (d1 == d2)
        std::cout << "d1 == d2" << "\n";
    else if (d1 > d2)
        std::cout << "d1 > d2" << "\n";
    else if (d1 < d2)
        std::cout << "d1 < d2" << "\n";
    return 0;
    
    >> d1 > d2
}
```

Не рекомендуется использовать операторы == или != с числами типа с плавающей точкой.\
Вместо них следует использовать функцию, которая вычисляет, насколько эквивалентны эти два
значения.

```c++
#include <cmath> // для функции fabs()

// Возвращаем true, если разница между a и b в пределах процента эпсилона
// epsilon вводится в процентах
bool approximatelyEqual(double a, double b, double epsilon) {
    return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
```

Но и функция approximatelyEqual() тоже не идеальна, особенно, когда дело доходит
до чисел, близких к нулю

```c++
// Значение a очень близко к 1.0, но, из-за ошибок округления, чуть меньше 1.0
double a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
// давайте сравним значение a - 1.0 (почти 0.0) с 0.0
std::cout << approximatelyEqual(a - 1.0, 0.0, 1e-8)

>> 0  // Математика просто ломается, когда дело доходит до нулей
```

Но и этого можно избежать, используя как абсолютный эпсилон (то, что мы делали\
в первом способе), так и относительный (способ Кнута) вместе:

```c++
// Возвращаем true, если разница между a и b меньше absEpsilon или в пределах relEpsilon
bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon) {
// Проверяем числа на равенство их друг другу - это нужно в тех случаях, 
// когда сравниваемые числа являются нулевыми или "около нуля"
double diff = fabs(a - b);
if (diff <= absEpsilon)
return true;
// В противном случае, возвращаемся к алгоритму Кнута
return diff <= ((fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * relEpsilon);
}
```

Тогда:

```c++
double a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
std::cout << approximatelyEqual(a, 1.0, 1e-8);  // сравниваем "почти 1.0" с 1.0
std::cout << approximatelyEqual(a - 1.0, 0.0, 1e-8) << "\n"; // сравниваем "почти 0.0" с 0.0
std::cout << approximatelyEqualAbsRel(a - 1.0, 0.0, 1e-12, 1e-8) << "\n"; // сравниваем "почти 0.0" с 0.0

>> 1
>> 0
>> 1
```

## Урок №46. Логические операторы: И, ИЛИ, НЕ

### Логический оператор НЕ

```c++
if (!(x == y))
    std::cout << "x != y";
```

Любое ненулевое целое значение в логическом контексте является
true. Так как `х = 5`, то `х` вычисляется как `true`, а вот `!x = false`, т.е. `0`.

### Логический оператор ИЛИ

```c++
if (value == 0 || value == 1 || value == 2 || value == 3)
    std::cout << "You picked 0, 1, 2, or 3" << std::endl;
```

### Логический оператор И

```c++
if (value > 10 && value < 20)
    std::cout << "Your value is between 10 and 20" << std::endl;
```

### Использование логических операторов И/ИЛИ

**Приоритет логического И выше приоритета ИЛИ**

Рассмотрим следующее выражение: `value1 || value2 && value3`. Поскольку
приоритет логического И выше, то обрабатываться выражение будет так:\
`value1 || (value2 && value3)`\
А не так:\
`(value1 || value2) && value3`

**Законы Де Моргана** гласят, что `!(x && y)` эквивалентно `!x || !y`,
`а !(x || y)` эквивалентно `!x && !y`.

## Урок №48. Побитовые операторы

### Побитовый сдвиг влево (`<<`) и побитовый сдвиг вправо (`>>`)

```
// сдвиг влева
3 = 0011
3 << 1 = 0110 = 6
3 << 2 = 1100 = 12
3 << 3 = 1000 = 8

// сдвиг вправо
12 = 1100
12 >> 1 = 0110 = 6
12 >> 2 = 0011 = 3
12 >> 3 = 0001 = 1
```

```c++
int main() {
    unsigned int x = 4;
    x = x << 1;  // оператор << используется для побитового сдвига влево
    std::cout << x; // оператор << используется для вывода данных в консоль
    return 0;
}

>> 8
```

### Побитовый оператор НЕ

Результаты побитового НЕ зависят от размера типа данных.

```
// размер типа данных составляет 4 бита
4 = 0100
~ 4 = 1011 (двоичное) = 11 (десятичное)

// размер типа данных составляет 8 бит
4 = 0000 0100
~ 4 = 1111 1011 (двоичное) = 251 (десятичное)
```

### Побитовые операторы И, ИЛИ и исключающее ИЛИ (XOR)

Если хоть один бит в столбце равен 1, то результат целого столбца — 1

```
// 2 числа
0 1 0 1 // 5
0 1 1 0 // 6
-------
0 1 1 1 // 7

// 3 числа
0 0 0 1 // 1
0 1 0 0 // 4
0 1 1 0 // 6
--------
0 1 1 1 // 7
```

Побитовое И работает аналогично логическому И — возвращается true, только если
оба бита в столбце равны 1

```
0 1 0 1 // 5
0 1 1 0 // 6
--------
0 1 0 0 // 4

0 0 0 1 // 1
0 0 1 1 // 3
0 1 1 1 // 7
--------
0 0 0 1 // 1
```

При обработке двух операндов, исключающее ИЛИ возвращает true (1),\
только если один и только один из операндов является истинным (1).\
Если таких нет или все операнды равны 1, то результатом будет false (0).

```
0 1 1 0 // 6
0 0 1 1 // 3
-------
0 1 0 1 // 5
```

Если единиц в столбце чётное количество, то результатом будет 0, если же нечётное\
количество, то результат — 1.

```
0 0 0 1 // 1
0 0 1 1 // 3
0 1 1 1 // 7
--------
0 1 0 1 // 5
```

### Побитовые операторы присваивания

Вместо `х = х << 1;` мы можем написать `х <<= 1;`

## Урок №49. Битовые флаги и битовые маски

```c++
// Определяем 8 отдельных битовых флагов (они могут представлять всё, что вы захотите).
// Обратите внимание, в C++11 лучше использовать "uint8_t" вместо "unsigned char"
const unsigned char option1 = 0x01; // шестнадцатеричный литерал для 0000 0001
const unsigned char option2 = 0x02; // шестнадцатеричный литерал для 0000 0010
const unsigned char option3 = 0x04; // шестнадцатеричный литерал для 0000 0100
const unsigned char option4 = 0x08; // шестнадцатеричный литерал для 0000 1000
const unsigned char option5 = 0x10; // шестнадцатеричный литерал для 0001 0000
const unsigned char option6 = 0x20; // шестнадцатеричный литерал для 0010 0000
const unsigned char option7 = 0x40; // шестнадцатеричный литерал для 0100 0000
const unsigned char option8 = 0x80; // шестнадцатеричный литерал для 1000 0000

// Байтовое значения для хранения комбинаций из 8 возможных вариантов
unsigned char myflags = 0; // все флаги/параметры отключены до старта
```

Чтобы узнать битовое состояние, используется побитовое И:

```c++
if (myflags & option4) ... // если option4 установлено - что-нибудь делаем
```

Чтобы включить биты, используется побитовое ИЛИ:

```c++
myflags |= option4; // включаем option4
myflags |= (option4 | option5); // включаем option4 и option5
```

Чтобы выключить биты, используется побитовое И с инвертированным литералом:

```c++
myflags &= ~option4; // выключаем option4
myflags &= ~(option4 | option5); // выключаем option4 и option5
```

Для переключения между состояниями бит, используется побитовое исключающее ИЛИ (XOR):

```c++
myflags ^= option4; // включаем или выключаем option4
myflags ^= (option4 | option5); // изменяем состояния option4 и option5
```

### Битовые флаги полезны, если:

#### Если у вас много идентичных битовых флагов

Вместо одной переменной `myflags`, рассмотрим случай, когда у вас есть две\
переменные: `myflags1` и `myflags2`, каждая из которых может хранить 8\
значений. Если вы определите их как два отдельных логических набора, то вам\
потребуется 16 логических значений и, таким образом, 16 байт. Однако с\
использованием битовых флагов вам потребуется только 10 байт (8 для\
определения параметров и 1 для каждой переменной `myflags`). А вот если у вас\
будет 100 переменных `myflags`, то, используя битовые флаги, вам потребуется 108\
байт вместо 800. Чем больше идентичных переменных вам нужно, тем более\
значительной будет экономия памяти.

#### Если есть функция, которая на вход принимает большое количество данных

Представьте, что у вас есть функция, которая может принимать любую\
комбинацию из 32 различных вариантов. Одним из способов написания такой\
функции является использование 32 отдельных логических параметров:
```c++
void someFunction(bool option1, bool option2, bool option3, bool option4,
bool option5, bool option6, bool option7, bool option8, bool option9, bool
option10, bool option11, bool option12, bool option13, bool option14, bool
option15, bool option16, bool option17, bool option18, bool option19, bool
option20, bool option21, bool option22, bool option23, bool option24, bool
option25, bool option26, bool option27, bool option28, bool option29, bool
option30, bool option31, bool option32);

someFunction(false, false, false, false, false, false, false, false, false,
true, false, false, false, false, false, false, false, false, false, false,
false, false, false, false, false, false, false, false, false, false, false,
true);
```

А вот если определить функцию с помощью битовых флагов:

```c++
void someFunction(unsigned int options);
```

То можно выбирать и передавать только нужные параметры:

```c++
someFunction(option10 | option32);
```

Кроме того, что это читабельнее, это также эффективнее и производительнее, так\
как включает только 2 операции (1 побитовое ИЛИ и 1 передача параметров)

### Введение в `std::bitset`

Для его использования необходимо подключить заголовочный файл bitset, а затем\
определить переменную типа std::bitset, указав необходимое количество бит. Она\
должна быть константой типа compile time.

```c++
#include <bitset>

std::bitset<8> bits; // нам нужно 8 бит
```

При желании std::bitset можно инициализировать начальным набором значений:

```c++
#include <bitset>

std::bitset<8> bits(option1 | option2) ; // начнем с включенных option1 и option2
std::bitset<8> morebits(0x2) ; // начнем с битового шаблона 0000 0010
```

В `std::bitset` есть 4 основные функции:

- функция `test()` — позволяет узнать значение бита (0 или 1).
- функция `set()` — позволяет включить биты (если они уже включены, то ничего не произойдет).
- функция `reset()` — позволяет выключить биты (если они уже выключены, то ничего не произойдет).
- функция `flip()` — позволяет изменить значения бит на противоположные (с 0 на 1 или с 1 на 0).

Пример использования:

```c++
#include <iostream>
#include <bitset>

// Обратите внимание, используя std::bitset, наши options соответствуют порядковым номерам бит, а не их значениям
const int option_1 = 0;
const int option_2 = 1;
const int option_3 = 2;
const int option_4 = 3;
const int option_5 = 4;
const int option_6 = 5;
const int option_7 = 6;
const int option_8 = 7;

int main() {
    // Помните, что отсчет бит начинается не с 1, а с 0
    std::bitset<8> bits(0x2); // нам нужно 8 бит, начнем с битового шаблона 0000 0010
    bits.set(option_5); // включаем 4-й бит - его значение изменится на 1 (теперь мы имеем 0001 0010)
    bits.flip(option_6); // изменяем значения 5-го бита на противоположное (теперь мы имеем 0011 0010)
    bits.reset(option_6); // выключаем 5-й бит - его значение снова 0 (теперь мы имеем 0001 0010)
    
    std::cout << "Bit 4 has value: " << bits.test(option_5) << '\n';
    std::cout << "Bit 5 has value: " << bits.test(option_6) << '\n';
    std::cout << "All the bits: " << bits << '\n';
    
    return 0;
}

>> Bit 4 has value: 1
>> Bit 5 has value: 0
>> All the bits: 00010010
```

### Битовые маски

Когда мы соединяем отдельные биты вместе, в целях их модификации как группы,\
то это называется битовой маской.

```c++
#include <iostream>

int main() {
    const unsigned int lowMask = 0xF; // битовая маска для хранения последних4 бит (шестнадцатеричный литерал для 0000 0000 0000 1111)
    
    std::cout << "Enter an integer: ";
    int num;
    std::cin >> num;
    
    num &= lowMask; // удаляем первые биты, оставляя последние 4
    
    std::cout << "The 4 low bits have value: " << num << '\n';
    
    return 0;
}

>> Enter an integer: 151
<< The 4 low bits have value: 7
```

`151` в десятичной системе равно `1001 0111` в двоичной. `lowMask` — это `0000
1111` в 8-битной двоичной системе. `1001 0111 & 0000 1111 = 0000 0111`,
что равно десятичному `7`.

### Пример с RGBA

Следующая программа просит пользователя ввести 32-битное шестнадцатеричное\
значение, а затем извлекает 8-битные цветовые значения R, G, B и A:

```c++
#include <iostream>

int main() {
    const unsigned int redBits = 0xFF000000;
    const unsigned int greenBits = 0x00FF0000;
    const unsigned int blueBits = 0x0000FF00;
    const unsigned int alphaBits = 0x000000FF;
    
    std::cout << "Enter a 32-
    bit RGBA color value in hexadecimal (e.g. FF7F3300): ";
    unsigned int pixel;
    std::cin >> std::hex >> pixel; // std::hex позволяет вводить шестнадцатеричные значения
    
    // Используем побитовое И для изоляции красных пикселей, а затем сдвигаем значение вправо в диапазон 0-255
    unsigned char red = (pixel & redBits) >> 24;
    unsigned char green = (pixel & greenBits) >> 16;
    unsigned char blue = (pixel & blueBits) >> 8;
    unsigned char alpha = pixel & alphaBits;
    
    std::cout << "Your color contains:\n";
    std::cout << static_cast<int>(red) << " of 255 red\n";
    std::cout << static_cast<int>(green) << " of 255 green\n";
    std::cout << static_cast<int>(blue) << " of 255 blue\n";
    std::cout << static_cast<int>(alpha) << " of 255 alpha\n";
    
    return 0;
}
```

Результат выполнения программы:

```c++
<< Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300):
>> FF7F3300
<< Your color contains:
<< 255 of 255 red
<< 127 of 255 green
<< 51 of 255 blue
<< 0 of 255 alpha
```

### Тест

Есть следующий фрагмент кода:

```c++
int main() {
    unsigned char option_viewed = 0x01;
    unsigned char option_edited = 0x02;
    unsigned char option_favorited = 0x04;
    unsigned char option_shared = 0x08;
    unsigned char option_deleted = 0x80;
    
    unsigned char myArticleFlags;
    
    return 0;
}
```

№1. Добавьте строку кода, чтобы пометить статью как уже прочитанную (option_viewed).\
`myArticleFlags |= option_viewed;`

№2. Добавьте строку кода, чтобы проверить, была ли статья удалена (option_deleted).\
`if (myArticleFlags & option_deleted) …`

№3. Добавьте строку кода, чтобы открепить статью от закрепленного места (option_favorited).\
`myArticleFlags &= ~option_favorited;`

№4. Почему следующие две строки идентичны?

```c++
myflags &= ~(option4 | option5); // выключаем option4 и option5
myflags &= ~option4 & ~option5; // выключаем option4 и option5
```

Закон Де Моргана.

# Глава №4.

## Урок №50. Блоки стейтментов (составные операторы)

**Блоки стейтментов** (или **"составные операторы"**) — это группа стейтментов,\
которые обрабатываются компилятором как одна инструкция. Блок начинается с\
символа `{` и заканчивается символом `}`, стейтменты находятся внутри. Блоки могут\
использоваться в любом месте, где разрешено использовать один стейтмент. В\
конце составного оператора точка с запятой не ставится.

### Вложенные блоки

При использовании вложенных блоков, блок, который содержит внутри себя другой\
блок, называется **внешним блоком**, а тот, который содержится внутри этого блока\
— **внутренний/вложенный блок**.

```c++
int add(int x, int y) { // начало блока
    return x + y;
} // конец блока

int main() { // начало внешнего блока
    // Несколько стейтментов
    int value {};
    
    { // начало внутреннего/вложенного блока
    add(3, 4);
    } // конец внутреннего/вложенного блока
    
    return 0;
} // конец внешнего блока
```

### Количество уровней вложенности блоков

**Уровень вложенности функции** (или **"глубина вложенности функции"**) — это\
максимальное количество блоков, которые могут находиться в любой точке\
функции (включая внешний блок). В вышеприведенной функции есть 4 блока, но\
уровень вложенности равен 3.

```c++
#include <iostream>

int main() { // 1-й уровень вложенности блоков
    std::cout << "Enter an integer: ";
    int value {};
    std::cin >> value;
    
    if (value > 0) { // 2-й уровень вложенности блоков
        if ((value % 2) == 0) { // 3-й уровень вложенности блоков
                std::cout << value << " is positive and even\n";
            }
            else
            { // также 3-й уровень вложенности блоков
                std::cout << value << " is positive and odd\n";
            }
    }
    
    return 0;
}
```

## Урок №51. Локальные переменные, область видимости и продолжительность жизни

**Область видимости** определяет, где можно использовать переменную. **Продолжительность жизни**\
(или **"время жизни"**) определяет, где переменная создается и где уничтожается.

Переменные, определенные внутри блока, называются **локальными\
переменными**. Локальные переменные имеют **автоматическую\
продолжительность жизни**: они создаются (и инициализируются, если\
необходимо) в точке определения и уничтожаются при выходе из блока. Локальные\
переменные имеют **локальную область видимости** (или **"блочную"**), т.е. они входят\
в область видимости с точки объявления и выходят в самом конце блока, в котором\
определены.

```c++
#include <iostream>

int main() { // начало внешнего блока
    int x(5);
    
    { // начало вложенного блока
        int y(7);
        // Мы можем использовать x и y здесь
        std::cout << x << " + " << y << " = " << x + y;
    } // переменная y уничтожается здесь
    
    // Переменную y здесь нельзя использовать, поскольку она уже уничтожена!
    
    return 0;
} // переменная x уничтожается здесь
```

### Сокрытие имен
Переменная внутри вложенного блока может иметь то же имя, что и переменная\
внутри внешнего блока. Когда подобное случается, то переменная во вложенном\
(внутреннем) блоке «скрывает» внешнюю переменную. Это называется **сокрытием имен**:

```c++
#include <iostream>

int main() { // внешний блок
    int oranges(5); // внешняя переменная oranges

    if (oranges >= 5) // относится к внешней oranges
    { // вложенный блок
        int oranges; // скрывается внешняя переменная oranges
        // Идентификатор oranges теперь относится к вложенной переменной oranges.
        // Внешняя переменная oranges временно скрыта
        oranges = 10; // здесь мы присваиваем значение 10 вложенной переменной oranges, не внешней!

        std::cout << oranges << std::endl; // выводим значение вложенной переменной oranges
    } // вложенная переменная oranges уничтожается

    // Идентификатор oranges опять относится к внешней переменной oranges

    std::cout << oranges << std::endl; // выводим значение внешней переменной oranges

    return 0;
}  // внешняя переменная oranges уничтожается

<< 10
<< 5
```

**Правило: Избегайте использования вложенных переменных с именами,
идентичными именам внешних переменных.**

### Область видимости переменных
**Правило: Определяйте переменные в наиболее ограниченной области видимости.**
```c++
#include <iostream>

int main() {
    // Не определяйте x здесь
    {
        // Переменная x используется только внутри этого блока, поэтому определяем её здесь
        int x(7);
        std::cout << x;
    }
    // В противном случае, переменная x может быть использована и здесь
    
    return 0;
}
```

### Кириллица
`setlocale(LC_ALL, "rus");`

### Резюме
Область видимости определяет, где переменная доступна для использования.\
Продолжительность жизни переменной определяет, когда переменная\
создается и когда уничтожается.

Локальные переменные имеют локальную (блочную) область видимости, доступ\
к ним осуществляется только внутри блока, в котором они определены.

Локальные переменные имеют автоматическую продолжительность жизни, что\
означает, что они создаются в точке определения и уничтожаются в конце блока,\
в котором определены.

## Урок №52. Глобальные переменные
**Глобальными** называются переменные, которые объявлены вне блока. Они имеют\
**статическую продолжительность жизни**, т.е. создаются при запуске программы и\
уничтожаются при её завершении. Глобальные переменные имеют **глобальную\
область видимости** (или **"файловую область видимости"**), т.е. их можно\
использовать в любом месте файла, после их объявления.

### Определение глобальных переменных
С помощью оператора разрешения области видимости (`::`), компилятору\
можно сообщить, какую версию переменной вы хотите использовать: глобальную\
или локальную.
```c++
#include <iostream>

int value(4); // глобальная переменная

int main() {
    int value = 8; // эта переменная (локальная) скрывает значение глобальной переменной
    value++; // увеличивается локальная переменная value (не глобальная)
    ::value--; // уменьшается глобальная переменная value (не локальная)
    
    std::cout << "Global value: " << ::value << "\n";
    std::cout << "Local value: " << value << "\n";
    
    return 0;
} // локальная переменная уничтожается

<< Global value: 3
<< Local value: 9
```

Использовать одинаковые имена для локальных и глобальных переменных — это\
прямой путь к проблемам и ошибкам, поэтому подобное делать не рекомендуется.\
Многие разработчики добавляют к глобальным переменным префикс `g_`.

### Ключевые слова `static` и `extern`
Связь переменной определяет, относятся ли несколько упоминаний одного\
идентификатора к одной и той же переменной или нет.

Переменная без связей — это переменная с локальной областью видимости,\
которая относится только к блоку, в котором она определена.

Переменная, имеющая внутренние связи, называется **внутренней переменной** (или\
**"статической переменной"**). Она может использоваться в любом месте файла, в\
котором определена, но не относится к чему-либо вне этого файла.

Переменная, имеющая внешние связи, называется **внешней переменной**. Она\
может использоваться как в файле, в котором определена, так и в других файлах.

**Ключевое слово `static` нужно**, чтобы сделать глобальную переменную внутренней\
(которую можно использовать только внутри одного файла):
```c++
#include <iostream>

// g_x - это статическая глобальная переменная, 
// которую можно использовать только внутри этого файла
static int g_x; 

int main() {
    return 0;
}
```

**Ключевое слово `extern` нужно**, чтобы сделать глобальную переменную внешней\
(которую можно использовать в любом файле программы):
```c++
#include <iostream>

// g_y - это внешняя глобальная переменная и её можно
// использовать и в других файлах программы
extern double g_y(9.8);

int main() {
    return 0;
}
```
По умолчанию, неконстантные переменные, объявленные вне блока, считаются\
внешними. Однако константные переменные, объявленные вне блока, считаются\
внутренними.

### Предварительные объявления переменных с использованием extern
Чтобы использовать внешнюю глобальную переменную, которая была\
объявлена в другом файле, нужно записать предварительное объявление\
переменной с использованием ключевого слова extern (без инициализируемого значения):

**global.cpp:**
```c++
// Определяем две глобальные переменные
int g_m; // неконстантные глобальные переменные имеют внешнюю связь по умолчанию

int g_n(3); // неконстантные глобальные переменные имеют внешнюю связь по умолчанию
// g_m и g_n можно использовать в любом месте этого файла
```
**main.cpp:**
```c++
#include <iostream>

extern int g_m; // предварительное объявление g_m. Теперь g_m можно использовать в любом месте этого файла

int main() {
    extern int g_n; // предварительное объявление g_n. Теперь g_n можно использовать только внутри main()
    
    g_m = 4;
    std::cout << g_n;3
    
    return 0;
}

<< 3
```
Если предварительное объявление находится вне блока, то оно применяется ко всему файлу.\
Если же внутри блока, то оно применяется только к нему.

Если переменная объявлена с помощью ключевого слова static, то получить доступ к\
ней с помощью предварительного объявления не получится:

**constants.cpp:**
```c++
static const double g_gravity(9.8);
```

**main.cpp:**
```c++
#include <iostream>

// не найдет g_gravity в constants.cpp, так как g_gravity является внутренней переменной
extern const double g_gravity; 

int main() {
    // вызовет ошибку компиляции, так как переменная g_gravity не была определена для использования в main.cpp
    std:: cout << g_gravity; 
    
    return 0;
}
```

### Связи функций
Функции имеют такие же свойства связи, что и переменные. По умолчанию они\
имеют внешнюю связь, которую можно сменить на внутреннюю с помощью\
ключевого слова `static`:
```c++
// Эта функция определена как static и может быть использована только внутри этого файла.
// Попытки доступа к ней через прототип функции будут безуспешными
static int add(int a, int b) {
    return a + b;
}
```
Предварительные объявления функций не нуждаются в ключевом слове extern.

### Глобальные символьные константы
**constants.cpp:**
```c++
namespace Constants {
    // Фактические глобальные переменные
    extern const double pi(3.14159);
    extern const double avogadro(6.0221413e23);
    extern const double my_gravity(9.2);
}
```

**constants.h:**
```c++
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace Constants {
// Только предварительные объявления
extern const double pi;
extern const double avogadro;
extern const double my_gravity;
}

#endif
```

**Их использование в коде остается неизменным:**
```c++
#include "constants.h"

//...
double circumference = 2 * radius * Constants::pi;
//...
```
Теперь определение символьных констант выполняется только один раз (в\
constants.cpp). Любые изменения, сделанные в constants.cpp, потребуют\
перекомпиляции только (одного) этого файла.

Но есть и обратная сторона медали: такие константы больше не будут считаться\
константами типа `compile-time` и, поэтому, не смогут использоваться где-либо, где\
потребуется константа такого типа.

Поскольку глобальные символьные константы должны находиться в отдельном\
пространстве имен и быть доступными только для чтения, то использовать префикс\
`g_` уже не обязательно.

### Резюме

- Глобальные переменные имеют глобальную область видимости и могут\
  использоваться в любом месте программы. Подобно функциям, вы должны\
  использовать предварительные объявления (с ключевым словом extern),\
  чтобы использовать глобальную переменную, определенную в другом файле.
- По умолчанию, глобальные неконстантные переменные имеют внешнюю\
  связь. Вы можете использовать ключевое слово static, чтобы сделать их\
  внутренними.
- По умолчанию, глобальные константные переменные имеют внутреннюю\
  связь. Вы можете использовать ключевое слово extern, чтобы сделать их\
  внешними.
- Используйте префикс `g_` для идентификации ваших неконстантных\
  глобальных переменных.

### Тест
В чём разница между областью видимости, продолжительностью жизни и связью\
переменных? Какие типы продолжительности жизни, области видимости и связи\
имеют глобальные переменные?

- Область видимости определяет, где переменная доступна для\
  использования. Продолжительность жизни определяет, где переменная\
  создается и где уничтожается. Связь определяет, может ли переменная\
  использоваться в другом файле или нет.
- Глобальные переменные имеют глобальную область видимости (или\
  «файловую область видимости»), что означает, что они доступны из точки\
  объявления до конца файла, в котором объявлены.
- Глобальные переменные имеют статическую продолжительность жизни,\
  что означает, что они создаются при запуске программы и уничтожаются\
  при её завершении.
- Глобальные переменные могут иметь либо внутреннюю, либо внешнюю\
  связь (это можно изменить через использование ключевых слов static и\
  extern, соответственно).

## Урок №53. Почему глобальные переменные – зло?
### Почему (неконстантные) глобальные переменные — это зло?
Их значения могут изменять любые вызываемые функции, при этом вы можете этого и не знать:
```c++
#include <iostream>

// Объявление глобальной переменной
int g_mode;

void doSomething() {
    g_mode = 2; // присваиваем глобальной переменной g_mode значение 2
}

int main() {
    // Примечание: Здесь мы присваиваем глобальной переменной
    // g_mode значение 1. Это не объявление локальной переменной g_mode!
    g_mode = 1; 
    
    doSomething();
    
    // Программист по-прежнему ожидает, что g_mode будет 1.
    // Но функция doSomething() изменила значение этой переменной на 2!
    
    if (g_mode == 1)
        std::cout << "No threat detected.\n";
    else
        std::cout << "Launching nuclear missiles...\n";
    
    return 0;
}

<< Launching nuclear missiles...
```
**Правило: Вместо глобальных переменных используйте локальные (когда это целесообразно).**

### Резюме
Избегайте использования неконстантных глобальных переменных, насколько это\
возможно! Если же используете, то используйте их максимально разумно и\
осторожно.

## Урок №54. Статические переменные
Использование **ключевого слова** `static` с локальными переменными изменяет их\
свойство продолжительности жизни с автоматического на статическое (или\
"фиксированное"). **Статическая переменная** (или **«переменная со статической\
продолжительностью жизни»**) сохраняет свое значение даже после выхода из\
блока, в котором она определена. То есть она создается (и инициализируется)\
только один раз, а затем сохраняется на протяжении выполнения всей программы.
```c++
#include <iostream>

void incrementAndPrint() {
    static int s_value = 1; // переменная s_value является статической
    ++s_value;
    std::cout << s_value << std::endl;
} // переменная s_value не уничтожается здесь, но становится недоступной

int main() {
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();
    
    return 0;
}

<< 2
<< 3
<< 4
```
Поскольку переменная `s_value` объявлена статической (с помощью ключевого\
слова `static`), то она создается и инициализируется только один раз. Кроме того,\
выходя из области видимости, она не уничтожается. Каждый раз, при вызове\
функции `incrementAndPrint()`, значение `s_value` увеличивается.

Так же, как мы используем префикс `g_` с глобальными переменными, префикс `s_`\
принято использовать со статическими переменными. Обратите внимание,\
внутренние глобальные переменные (которые объявлены с использованием static)\
остаются с префиксом `g_`, а не с префиксом `s_`.

```c++
// присвоение каждому объекту отдельный уникальный идентификационный номер
int generateID() {
  static int s_itemID = 0;
  return s_itemID++;
}
```
`s_itemID` — это локальная переменная, то она не может быть «изменена» другими функциями

**Статические переменные** имеют некоторые преимущества глобальных переменных\
(они не уничтожаются до завершения программы), сохраняя при этом локальную\
область видимости. Таким образом, они намного безопаснее для использования,\
нежели глобальные переменные.

### Тест
Какой эффект от добавления ключевого слова static к глобальной переменной?\
Какое влияние оно имеет на локальную переменную?

Добавляя ключевое слово static к глобальной переменной, мы определяем её\
как внутреннюю, то есть такую, которую нельзя экспортировать и использовать в\
других файлах.\
В случае с локальной переменной, добавление static определяет её как\
статическую, то есть она создается и инициализируется только один раз, и не\
уничтожается до самого конца программы.

## Урок №55. Связи, область видимости и продолжительность жизни
### Область видимости
**Область видимости** идентификатора определяет, где он доступен для\
использования. К идентификатору, который находится вне области видимости,\
доступ закрыт.
- Переменные с **локальной/блочной областью видимости** доступны только в
  пределах блока, в котором они объявлены. Это:
  - локальные переменные;
  - параметры функции.
- Переменные с **глобальной/файловой областью видимости** доступны в
  любом месте файла. Это:
  - глобальные переменные.

### Продолжительность жизни
**Продолжительность жизни** переменной определяет, где она создается и где
уничтожается.
- Переменные с **автоматической продолжительностью жизни** создаются в\
  точке определения и уничтожаются при выходе из блока, в котором
  определены. Это:
  - обычные локальные переменные.
- Переменные **со статической продолжительностью жизни** создаются, когда\
  программа запускается, и уничтожаются при её завершении. Это:
  - глобальные переменные;
  - статические локальные переменные.
- Переменные с **динамической продолжительностью жизни** создаются и\
  уничтожаются по запросу программиста. Это:
  - динамические переменные (о них мы поговорим на соответствующем уроке).

### Связи
**Связь** идентификатора определяет, относятся ли несколько упоминаний одного\
идентификатора к одному и тому же идентификатору или нет.

- Идентификаторы **без связей** — это идентификаторы, которые ссылаются сами\
  на себя. Это:
  - обычные локальные переменные;
  - пользовательские типы данных, такие как enum, typedef и классы,\
    объявленные внутри блока (об этом детально поговорим на\
    соответствующих уроках).

- Идентификаторы с **внутренней связью** доступны в любом месте файла, в\
  котором они объявлены. Это:
  - статические глобальные переменные (инициализированные или неинициализированные);
  - константные глобальные переменные;
  - статические функции (о них поговорим чуть позже).

- Идентификаторы с **внешней связью** доступны как в любом месте файла, в\
  котором они объявлены, так и в других файлах (через предварительное\
  объявление). Это:
  - обычные функции;
  - неконстантные глобальные переменные (инициализированные или неинициализированные);
  - внешние константные глобальные переменные;
  - определяемые пользователем типы данных, такие как enum, typedef и\
    классы с глобальной областью видимости (о них мы поговорим чуть позже).

Идентификаторы с внешней связью могут вызвать ошибку дублирования\
определений, если определения скомпилированы в более чем одном файле .cpp.

Функции по умолчанию имеют внешнюю связь, что можно изменить с помощью\
ключевого слова static (на внутреннюю связь).

## Урок №56. Пространства имен
**Конфликт имен** возникает, когда два одинаковых идентификатора находятся в
одной области видимости, и компилятор не может понять, какой из этих двух
следует использовать в конкретной ситуации.

### Что такое пространство имен?
**Пространство имен** определяет область кода, в которой гарантируется
уникальность всех идентификаторов. По умолчанию, глобальные переменные и
обычные функции определены в **глобальном пространстве** имен.

Собственные пространства имен через **ключевое слово `namespace`**. 
Всё, что объявлено внутри пользовательского пространства имен, — 
принадлежит только этому пространству имен (а не глобальному).

**boo.h:**
```c++
namespace Boo {
    // Эта версия doOperation() принадлежит пространству имен Boo
  int doOperation(int a, int b) {
    return a + b;
  }   
}
```
**xoo.h:**
```c++
namespace Doo {
    // Эта версия doOperation() принадлежит пространству имен Doo
  int doOperation(int a, int b) {
    return a - b;
  }   
}
```
**main.cpp:**
```c++
#include <iostream>
#include "boo.h"
#include "doo.h"

int main() {
    std::cout << doOperation(5, 4);
    return 0;
}

<< error C2065: 'doOperation' : undeclared identifier
```
Существует два разных способа сообщить компилятору, какую версию `doOperation()`\
следует использовать: через оператор разрешения области видимости или с\
помощью using-стейтментов (следующий урок).

### Доступ к пространству имен через оператор разрешения области видимости (`::`)
Сообщим компилятору использовать версию `doOperation()` из пространства имен `Boo`:
```c++
#include <iostream>
#include "boo.h"
#include "doo.h"

int main(void) {
  std::cout << Boo::doOperation(5, 4);
  std::cout << Doo::doOperation(5, 4);
  return 0;
}

<< 9
<< 1
```
Также этот оператор можно использовать без какого-либо префикса (например,\
`::doOperation`). В таком случае мы ссылаемся на глобальное пространство имен.

### Пространства имен с одинаковыми названиями
Допускается объявление пространств имен в нескольких местах (либо в нескольких\
файлах, либо в нескольких местах внутри одного файла). Всё, что находится внутри\
одного блока имен, считается частью только этого блока.

**add.h:**
```c++
namespace DoMath {
    // Функция add() является частью пространства имен DoMath
    int add(int x, int y) {
        return x + y;
    }
}
```
**subtract.h:**
```c++
namespace DoMath {
    // Функция subtract() является частью пространства имен DoMath
    int subtract(int x, int y) {
        return x - y;
    }
}
```

**main.cpp:**
```c++
#include <iostream>
#include "add.h" // импортируем DoMath::add()
#include "subtract.h" // импортируем DoMath::subtract()

int main() {
    std::cout << DoMath::add(5, 4) << '\n';
    std::cout << DoMath::subtract(5, 4) << '\n';
    return 0;
}

<< 9
<< 1
```

### Псевдонимы и вложенные пространства имен
Одни пространства имен могут быть вложены в другие пространства имен:
```c++
#include <iostream>

namespace Boo {
    namespace Doo {
        const int g_x = 7;
    }
}

int main() {
    std::cout << Boo::Doo::g_x;
    return 0;
}
```
Поскольку Doo находится внутри Boo, то доступ к `g_x` осуществляется через `Boo::Doo::g_x`.

Так как это не всегда удобно и эффективно, то C++ позволяет создавать псевдонимы
для пространств имен:
```c++
#include <iostream>

namespace Boo {
    namespace Doo {
        const int g_x = 7;
    }
}

namespace Foo = Boo::Doo;  // Foo теперь считается как Boo::Doo

int main() {
    std::cout << Foo::g_x;  // это, на самом деле, Boo::Doo::g_x
    return 0;
}
```
**Вложенность пространств имен использовать не рекомендуется.**

## Урок №57. using-стейтменты
### Использование "using-объявления"
Строка using `std::cout;` сообщает компилятору, что мы будем использовать\
объект `cout` из пространства имен `std`. И каждый раз, когда компилятор будет\
сталкиваться с `cout`, он будет понимать, что это `std::cout`.
```c++
#include <iostream>

int main() {
  using std::cout; // «using-объявление» сообщает компилятору, что cout следует обрабатывать, как std::cout
  cout << "Hello, world!"; // и никакого префикса std:: уже здесь не нужно!
  return 0;
}
```

### Использование "using-директивы"
`using namespace std;` сообщает компилятору, что мы хотим использовать всё, \
что находится в пространстве имен `std`, так что, если компилятор найдет имя, \
которое не сможет распознать, он будет проверять его наличие в пространстве имен `std`.
```c++
#include <iostream>

int main() {
    // «using-директива» сообщает компилятору, что мы используем все объекты из пространства имен std!
  using namespace std; 
  cout << "Hello, world!"; // и никакого префикса std:: уже здесь не нужно!
  return 0;
}
```
**Совет: Старайтесь избегать использования "using-директивы" (насколько это возможно).**

### Пример конфликта c "using-директивой"
**Неверный способ:**
```c++
#include <iostream>

int cout() {  // объявляем нашу собственную функцию "cout"
    return 4;
}

int main() {
  // делаем std::cout доступным по "cout"  
  using namespace std;
  // какой cout компилятор здесь должен использовать? 
  cout << "Hello, world!"; 
  
  return 0;
}
```
**Верный способ:**
```c++
// Добавить префикс std:: к cout:
std::cout << "Hello, world!"; // сообщаем компилятору, что хотим использовать std::cout

// Использовать бы "using-объявление" вместо "using-директивы":
using std::cout; // сообщаем компилятору, что cout означает std::cout
cout << "Hello, world!"; // так что здесь следует использовать std::cou
```
**Правило: Никогда не используйте using-стейтменты вне тела функций.**

### Отмена/замена using-стейтментов
Как только один using-стейтмент был объявлен, его невозможно отменить или\
заменить другим using-стейтментом в пределах области видимости, в которой он\
был объявлен. Например:
```c++
int main() {
  using namespace Boo;
  // Отменить «использование пространства имен Boo» здесь невозможно!
  // Также нет никакого способа заменить «using namespace Boo» на другой using-стейтмент
  
  return 0;
} // действие using namespace Boo заканчивается здесь
```
Лучшее, что вы можете сделать — это намеренно ограничить область применения\
using-стейтментов с самого начала, используя правила локальной области видимости:
```c++
int main() {
  {
    using namespace Boo;
    // Здесь всё относится к пространству имен Boo::
  } // действие using namespace Boo заканчивается здесь
  
  {
    using namespace Foo;
    // Здесь всё относится к пространству имен Foo::
  } // действие using namespace Foo заканчивается здесь
  
  return 0;
}
```

## Урок №58. Неявное преобразование типов данных
### Преобразование типов
Процесс конвертации значений из одного типа данных в другой называется **преобразованием типов**.

Преобразование типов **может** выполняться в следующих случаях:
- Случай №1: Присваивание или инициализация переменной значением другого типа данных:
  ```c++
  double k(4)  // инициализация переменной типа double целым числом 4
  k = 7; // присваиваем переменной типа double целое число 7
  ```
- Случай №2: Передача значения в функцию, где тип параметра — другой:
  ```c++
  void doSomething(long l){
  }
  doSomething(4);  // передача числа 4 (тип int) в функцию с параметром типа long
  ```
- Случай №3: Возврат из функции, где тип возвращаемого значения — другой:
  ```c++
  float doSomething(){
    return 4.0;  // передача значения 4.0 (тип double) из функции, которая возвращает float
  }
  ```
- Случай №4: Использование бинарного оператора с операндами разных типов:
  ```c++
  double division = 5.0 / 4; // операция деления со значениями типов double и int
  ```

**Есть 2 основных способа преобразования типов:**
- **Неявное преобразование типов**, когда компилятор автоматически\
  конвертирует один фундаментальный тип данных в другой.
- **Явное преобразование типов**, когда разработчик использует один из\
  операторов явного преобразования для выполнения конвертации объекта из\
  одного типа данных в другой.

### Неявное преобразование типов
**Неявное преобразование типов** (или "автоматическое преобразование типов")\
выполняется всякий раз, когда требуется один фундаментальный тип данных, но\
предоставляется другой, и пользователь не указывает компилятору, как выполнить\
конвертацию (не использует явное преобразование типов через операторы явного\
преобразования).

Есть 2 основных способа неявного преобразования типов:
- числовое расширение;
- числовая конверсия.

### Числовое расширение
Когда значение из одного типа данных конвертируется в другой тип данных\
побольше (по размеру и по диапазону значений), то это называется **числовым\
расширением**:
```c++
long l(65); // расширяем значение типа int (65) в тип long
double d(0.11f); // расширяем значение типа float (0.11) в тип double
```

В языке C++ есть два варианта расширений:
- **Интегральное расширение** (или "целочисленное расширение"). Включает в\
  себя преобразование целочисленных типов, меньших, чем int (bool, char,\
  unsigned char, signed char, unsigned short, signed short) в int (если это\
  возможно) или unsigned int.
- **Расширение типа с плавающей точкой**. Конвертация из типа float в тип double.

**Важно: Числовые расширения всегда безопасны и не приводят к потере данных.**

### Числовые конверсии
Когда мы конвертируем значение из более крупного типа данных в аналогичный, но\
более мелкий тип данных, или конвертация происходит между разными типами\
данных, то это называется **числовой конверсией**.
```c++
double d = 4; // конвертируем 4 (тип int) в double
short s = 3; // конвертируем 3 (тип int) в short
```

В этом примере мы присвоили огромное целочисленное значение типа `int`\
переменной типа `char` (диапазон которого составляет от -128 до 127).\
Это приведет к переполнению и следующему результату:
```c++
#include <iostream>

int main() {
  int i = 30000;
  char c = i;
  std::cout << static_cast<int>(c);
  
  return 0;
}

<< 48
```

Однако, если число подходит по диапазону, конвертация пройдет успешно.
```c++
#include <iostream>

int main() {
  int i = 3;
  short s = i; // конвертируем значение типа int в тип short
  std::cout << s << std::endl;
  
  double d = 0.1234;
  float f = d; // конвертируем значение типа double в тип float
  std::cout << f << std::endl;
  
  return 0;
}

<< 3
<< 0.1234
```

В случаях со значениями типа с плавающей точкой могут произойти округления\
из-за худшей точности в меньших типах. Например:
```c++
#include <iostream>
#include <iomanip> // для std::setprecision()
int main() {
  float f = 0.123456789; // значение типа double - 0.123456789 имеет 9 значащих цифр, но float может хранить только 7
  std::cout << std::setprecision(9) << f; // std::setprecision определен в заголовочном файле iomanip
  
  return 0;
}

<< 0.123456791
```

`std::setprecision(n)` устанавливает параметр точности потока `out` или `in` равным `n`:
```c++
#include <numbers>
int main() {
    constexpr long double pi {std::numbers::pi_v<long double>};
    std::cout << std::setprecision(3) << pi << '\n';
    std::cout << std::setprecision(19) << pi << '\n';
    return 0;
}

<< 3.14
<< 3.141592653589793239
```

Конвертируя из `float` в `int`, любая дробь отбрасывается:
```c++
#include <iostream>

int main() {
    int i = 4.6;
    std::cout << i;
    
    return 0;
}

<< 4
```

### Обработка арифметических выражений
Оператор `typeid`, чтобы узнать решающий тип в выражении.
```c++
#include <iostream>
#include <typeinfo> // для typeid

int main() {
  short x(3);
  short y(6);
  std::cout << typeid(x + y).name() << " " << x + y << std::endl; // вычисляем решающий тип данных в выражении x + y
}

<< int 9
```

Здесь значение signed int (10) подвергается расширению в unsigned int (которое\
имеет более высокий приоритет), и выражение вычисляется как unsigned int. А\
поскольку unsigned — это только положительные числа, то происходит\
переполнение, и мы имеем то, что имеем:
```c++
#include <iostream>
int main()
{
  std::cout << 5u - 10; // 5u означает значение 5 типа unsigned int
  return 0;
}

<< 4294967291
```
Это одна из тех многих веских причин избегать использования типа unsigned int вообще.

## Урок №59. Явное преобразование типов данных
### Операторы явного преобразования типов данных
В языке C++ есть 5 видов **операций явного преобразования типов**:
- конвертация C-style;
- применение оператора static_cast;
- применение оператора const_cast;
- применение оператора dynamic_cast;
- применение оператора reinterpret_cast.

**Правило: Избегайте использования const_cast и reinterpret_cast, если у вас нет на
это веских причин.**

### Конвертация `C-style`
```c++
int i1 = 11;
int i2 = 3;
// т.к. i1 станет типа float, то i2 также затем автоматически преобразуется в тип float
float x = float(i1) / i2;
```
**Правило: Не используйте конвертацию C-style.**

### Оператор `static_cast`
Оператор `static_cast` лучше всего использовать для конвертации одного\
фундаментального типа данных в другой:
```c++
int i1 = 11;
int i2 = 3;
float x = static_cast<float>(i1) / i2;
```
Основным преимуществом оператора `static_cast` является проверка его выполнения\
компилятором во время компиляции, что усложняет возможность возникновения\
непреднамеренных проблем.

### Использование операторов явного преобразования в неявном преобразовании
Чтобы сообщить компилятору, что вы намеренно делаете что-то, что потенциально опасно, 
используйте оператор `static_cast`:
```c++
int i = 49;
char ch = static_cast<char>(i);

int i = 90;
i = static_cast<int>(i / 3.6);
```

### Резюме
Преобразования типов данных следует избегать, если это вообще возможно,\
поскольку всякий раз, когда выполняется подобное изменение, есть вероятность\
возникновения непредвиденных проблем. Но очень часто случаются ситуации,\
когда этого не избежать. Поэтому в таких случаях лучше использовать оператор\
`static_cast` вместо конвертации `C-style`.

### Тест
В чём разница между явным и неявным преобразованием типов данных?

Неявное преобразование происходит, когда компилятор ожидает значение\
одного типа, но получает значение другого типа.

Явное преобразование происходит, когда программист использует оператор\
явного преобразования для конвертации значения из одного типа данных в\
другой.

## Урок №60. Введение в `std::string`
### Тип данных string
```c++
#include <iostream>
#include <string>

int main() {
    std::string name{"Kirill"};
    std::cout << name;
    return 0;
}

<< Kirill
```

**Ввод строк через `std::cin`:**
```c++
#include <iostream>
#include <string>

int main() {
  std::cout << "Enter your full name: ";
  std::string myName;
  // это будет работать не так, как ожидается, поскольку извлечение 
  // данных из потока std::cin останавливается на первом пробеле
  std::cin >> myName; 
  
  std::cout << "Enter your age: ";
  std::string myAge;
  std::cin >> myAge;
  
  std::cout << "Your name is " << myName << " and your age is " << myAge;
}

<< Enter your full name: 
>> Kirill Tarasov
<< Enter your age: Your name is Kirill and your age is Tarasov
```

### Использование `std::getline()`
`std::getline()` используется, чтобы извлечь полную строку из входного потока данных (вместе с пробелами).\
Она принимает два параметра: первый — `std::cin`, второй — переменная типа `string`.
```c++
#include <iostream>
#include <string>

int main() {
    std::cout << "Enter your full name: ";
    std::string myName;
    std::getline(std::cin, myName); // полностью извлекаем строку в переменную myName

    std::cout << "Enter your age: ";
    std::string myAge;
    std::getline(std::cin, myAge); // полностью извлекаем строку в переменную myAge
    std::cout << "Your name is " << myName << " and your age is " << myAge;

    return 0;
}

<< Enter your full name:
>> Kirill Tarasiv
<< Enter your age: 
>> 22
<< Your name is Kirill Tarasiv and your age is 22
```

### Использование `std::getline()` c `std::cin`
Когда вы вводите числовое значение, поток `cin` захватывает вместе с вашим числом и\
символ новой строки. Поэтому, когда мы ввели `2`, `cin` фактически получил `2\n`.\
Затем он извлек значение `2` в переменную, оставляя `\n` (символ новой строки) во\
входном потоке. Затем, когда `std::getline()` извлекает данные для `myName`, он видит\
в потоке `\n` и думает, что мы, должно быть, ввели просто пустую строку.
```c++
#include <iostream>
#include <string>

int main() {
    std::cout << "Pick 1 or 2: ";
    int choice;
    std::cin >> choice;

    std::cout << "Now enter your name: ";
    std::string myName;
    std::getline(std::cin, myName);

    std::cout << "Hello, " << myName << ", you picked " << choice << '\n';
    
    return 0;
}
<< Pick 1 or 2: 
>> 2
<< Now enter your name: Hello, , you picked 2
```

Хорошей практикой является удалять из входного потока данных символ новой\
строки. Это можно сделать следующим образом:
```c++
// 32767 вводится для пропуска определенного количества символов перед 
// указанным разделителем, в данном случае - символом новой строки "\n"
std::cin.ignore(32767, '\n');
```

Если мы вставим эту строку непосредственно после получения входных данных, то\
символ новой строки будет удален из входного потока, и программа будет работать\
должным образом:
```c++
#include <iostream>
#include <string>

int main() {
    std::cout << "Pick 1 or 2: ";
    int choice;
    std::cin >> choice;
    
    std::cin.ignore(32767, '\n'); // удаляем символ новой строки из входного потока данных
    
    std::cout << "Now enter your name: ";
    std::string myName;
    std::getline(std::cin, myName);

    std::cout << "Hello, " << myName << ", you picked " << choice << '\n';
    
    return 0;
}

<< Pick 1 or 2: 
>> 2
<< Now enter your name:
>> Kirill Tarasov
<< Hello, Kirill Tarasov, you picked 2
```

**Правило: При вводе числовых значений не забывайте удалять символ новой\
строки из входного потока данных с помощью `std::cin.ignore()`.**

### Добавление строк
Оператор `+` для объединения двух строк или оператор `+=` для добавления одной строки к другой.
```c++
#include <iostream>
#include <string>

int main() {
    std::string x("44");
    std::string y("12");
    
    std::cout << x + y << "\n"; // объединяем строки x и y (а не складываем числа)
    x += " cats";
    std::cout << x;

    return 0;
}

<< 4412
<< 44 cats
```

### Длина строк
Для определения длины строки используется метод `.length()`:
```c++
std::string myName{"Kirill"};
std::cout << myName.length();

<< 6
```

### Тест
Напишите программу, которая просит у пользователя ввести его имя, фамилию и\
возраст. В результате, укажите пользователю, сколько лет он прожил на каждую\
букву из его имени и фамилии (чтобы было проще, учитывайте также пробелы).

```c++
#include <iostream>
#include <string>

int main()
{
    std::cout << "Enter your full name: ";
    std::string myName;
    std::getline(std::cin, myName); // извлекаем целую строку из входного потока в переменную myName
    std::cout << "Enter your age: ";
    // переменная myAge должна быть типа int, а не типа string, чтобы мы могли проводить с ней арифметические операции
    int myAge; 
    std::cin >> myAge;
    int letters = myName.length(); // вычисляем длину переменной myName (учитывая пробелы)
    // используем оператор static_cast, чтобы изменить тип переменной myAge на double, 
    // дабы сохранить дробную часть при целочисленном делении
    double agePerLetter = static_cast<double>(myAge) / letters; 
    std::cout << "You've lived " << agePerLetter << " years for each letter in your name.\n";
    
    return 0;
}

<< Enter your full name: 
>> Kirill Tarasov
<< Enter your age: 
>> 22
<< Youve lived 1.57143 years for each letter in your name.
```

### Урок №61. Перечисления
#### Перечисляемые типы
**Перечисление** (или **"перечисляемый тип"**) — это тип данных, где любое значение
(или **"перечислитель"**) определяется как символьная константа. Объявить
перечисление можно с помощью **ключевого слова `enum`**. Например:
```c++
// Объявляем новое перечисление Colors
enum Colors {
    // Ниже находятся перечислители - все возможные значения этого типа данных
    // Каждый перечислитель отделяется запятой (НЕ точкой с запятой)
    COLOR_RED,
    COLOR_BROWN,
    COLOR_GRAY,
    COLOR_WHITE,
    COLOR_PINK,
    COLOR_ORANGE,
    COLOR_BLUE,
    COLOR_PURPLE, // конечная запятая разрешена
}; // однако сам enum должен заканчиваться точкой с запятой

// Определяем несколько переменных перечисляемого типа Colors
Colors paint = COLOR_RED;
Colors house(COLOR_GRAY); 
```

### Имена перечислений
Так как перечислители вместе с перечислением находятся в едином пространстве имен, то\
имена перечислителей не могут повторяться в разных перечислениях:

```c++
enum Colors {
    YELLOW,
    BLACK, // BLACK находится в глобальном пространстве имен
    PINK
};

enum Feelings {
    SAD,
    ANGRY,
    BLACK // получим ошибку, так как BLACK уже используется в enum Colors
}; 
```

### Значения перечислителей
Каждому перечислителю автоматически присваивается целочисленное значение в\
зависимости от его позиции в списке перечисления. По умолчанию, первому\
перечислителю присваивается целое число `0`, а каждому следующему — на\
единицу больше, чем предыдущему:
```c++
#include <iostream>

enum Colors {
    COLOR_YELLOW, // присваивается 0
    COLOR_WHITE, // присваивается 1
    COLOR_ORANGE, // присваивается 2
    COLOR_GREEN, // присваивается 3
    COLOR_RED, // присваивается 4
    COLOR_GRAY, // присваивается 5
    COLOR_PURPLE, // присваивается 6
    COLOR_BROWN // присваивается 7
};

int main() {
    Colors paint(COLOR_RED);
    std::cout << paint;
    
    return 0;
} 

<< 4
```

```c++
// Определяем новый перечисляемый тип Animals
enum Animals {
    ANIMAL_PIG = -4,
    ANIMAL_LION, // присваивается -3
    ANIMAL_CAT, // присваивается -2
    ANIMAL_HORSE = 6,
    ANIMAL_ZEBRA = 6, // имеет то же значение, что и ANIMAL_HORSE
    ANIMAL_COW // присваивается 7
}; 
```

**Совет: Не присваивайте свои значения перечислителям.**

**Правило: Не присваивайте одинаковые значения двум перечислителям в одном\
перечислении, если на это нет веской причины.**

### Обработка перечислений
Компилятор не будет неявно конвертировать целочисленное значение в значение\
перечислителя:
```c++
Animals animal = 7; // приведет к ошибке компиляции
```

Тем не менее, вы можете сделать подобное с помощью оператора `static_cast`:
```c++
Colors color = static_cast<Colors>(5); // но так делать не рекомендуется 
```

Компилятор также не позволит вам вводить перечислители через `std::cin`:
```c++
enum Colors {
    ...
};
int main() {
    Colors color;
    std::cin >> color; // приведет к ошибке компиляции
    
    return 0;
}
```

Однако, вы можете ввести целое число, а затем использовать оператор `static_cast`,\
чтобы поместить целочисленное значение в перечисляемый тип:
```c++
int inputColor; 
std::cin >> inputColor;

Colors color = static_cast<Colors>(inputColor); 
```

попытка присвоить перечислитель из одного перечисления перечислителю из\
другого — вызовет ошибку компиляции:
```c++
Animals animal = COLOR_BLUE; // приведет к ошибке компиляции
```

Как и в случае с константами, **перечисления отображаются в отладчике**, что делает\
их еще более полезными.

### Польза от перечислений
```c++
enum ParseResult {
    SUCCESS = 0,
    ERROR_OPENING_FILE = -1,
    ERROR_PARSING_FILE = -2,
    ERROR_READING_FILE = -3
};

ParseResult readFileContents() {
    if (!openFile())
        return ERROR_OPENING_FILE;
    if (!parseFile())
        return ERROR_PARSING_FILE;
    if (!readfile())
        return ERROR_READING_FILE;
    
    return SUCCESS; // если всё прошло успешно
}

int main() {
    if (readFileContents() == SUCCESS) {
        // Делаем что-нибудь
    }
    else {
        // Выводим сообщение об ошибке
    } 
}
```

```c++
#include <iostream>
#include <string>

enum ItemType {
    ITEMTYPE_GUN,
    ITEMTYPE_ARBALET,
    ITEMTYPE_SWORD
};

std::string getItemName(ItemType itemType) {
    if (itemType == ITEMTYPE_GUN)
        return std::string("Gun");
    if (itemType == ITEMTYPE_ARBALET)
        return std::string("Arbalet");
    if (itemType == ITEMTYPE_SWORD)
        return std::string("Sword");
}

int main() {
    // ItemType - это перечисляемый тип, который мы объявили выше.
    // itemType (с маленькой i) - это имя переменной, которую мы определяем ниже (типа ItemType).
    // ITEMTYPE_GUN - это значение перечислителя, которое мы присваиваем переменной itemType
    ItemType itemType(ITEMTYPE_GUN);
    
    std::cout << "You are carrying a " << getItemName(itemType) << "\n";
    
    return 0;
}

<< You are carrying a Gun
```

### Тест
**Задание №1.**\
Напишите перечисление со следующими перечислителями: `ogre`, `goblin`,\
`skeleton`, `orc` и `troll`.
```c++
enum MonsterType {
    MONSTER_OGRE,
    MONSTER_GOBLIN,
    MONSTER_SKELETON,
    MONSTER_ORC,
    MONSTER_TROLL
}; 
```

**Задание №2.**\
Объявите переменную перечисляемого типа, который вы определили в задании
№1, и присвойте ей значение ogre.
```c++
MonsterType eMonsterType = MONSTER_OGRE; 
```

**Задание №3 (сразу ответы).**\
Перечислителям можно:
- присваивать целочисленные значения;
- не присваивать значения; Перечислителю без значения будет неявно присвоено\
  целочисленное значение предыдущего перечислителя +1. Если\
  предыдущего перечислителя нет, то тогда присвоится значение 0.
- присваивать значения предыдущих перечислителей (например, COLOR_BLUE\
  = COLOR_GRAY). Поскольку значениями перечислителей являются целые числа, а\
  целые числа можно присвоить перечислителям, то одни перечислители\
  могут быть присвоены другим перечислителям (хотя этого лучше\
  избегать).

Перечислители могут быть:
- отрицательными;
- не уникальными.


## Урок №62. Классы enum
```c++
#include <iostream>

int main() {
    enum Fruits {
        LEMON, // LEMON находится внутри той же области видимости, что и Fruits
        KIWI    
    };
    
    enum Colors {
        PINK, // PINK находится внутри той же области видимости, что и Colors
        GRAY
    };
    
    Fruits fruit = LEMON; // Fruits и LEMON доступны в одной области видимости (добавлять префикс не нужно)
    Colors color = PINK; // Colors и PINK доступны в одной области видимости (добавлять префикс не нужно)
    
    if (fruit == color) // компилятор будет сравнивать эти переменные как целые числа
        std::cout << "fruit and color are equal\n"; // и обнаружит, что они равны!
    else
        std::cout << "fruit and color are not equal\n";
    
    return 0;
}

<< fruit and color are equal
```

Для решения этой проблемы в C++11 добавили **классы `enum`** (или **"перечисления с\
областью видимости"**), которые добавляют перечислениям, как вы уже могли\
понять, локальную область видимости со всеми её правилами. Для создания такого\
класса нужно просто добавить **ключевое слово `class`** сразу после enum.
```c++
#include <iostream>

int main() {
    enum class Fruits {
        LEMON, // LEMON находится внутри той же области видимости, что и Fruits
        KIWI    
    };
    
    enum class Colors {
        PINK, // PINK находится внутри той же области видимости, что и Colors
        GRAY
    };
    
    Fruits fruit = Fruits::LEMON; // LEMON напрямую не доступен, мы должны использовать Fruits::LEMON
    Colors color = Colors::PINK; // то же и тут
    
    if (fruit == color) // ошибка компиляции, поскольку компилятор не знает, как сравнивать разные типы: Fruits и Colors 
        std::cout << "fruit and color are equal\n";
    else
        std::cout << "fruit and color are not equal\n";
    
    return 0;
}

<< no known conversion for argument 2 from 'main()::Colors' to 'main()::Fruits'
```
Строгие правила типов классов enum означают, что каждый класс `enum` считается\
уникальным типом. Это означает, что компилятор не сможет сравнивать\
перечислители из разных перечислений. Если вы попытаетесь это сделать,\
компилятор выдаст ошибку.

## Урок №63. Псевдонимы типов: typedef и type alias
**Ключевое слово `typedef`** позволяет программисту создать псевдоним для любого\
типа данных и использовать его вместо фактического имени типа.
```c++
typedef double time_t; // используем time_t в качестве псевдонима для типа double

// Следующие два стейтмента эквивалентны
double howMuch;
time_t howMuch;
```
Обычно к псевдонимам typedef добавляют окончание `_t`, указывая, таким образом,\
что идентификатором является тип, а не переменная.

### `typedef` и читабельность кода
Мы видим, что возвращаемым значением является целое число, но что оно означает?
```c++
int GradeTest();
```

С использованием возвращаемого типа `testScore_t` становится очевидным, что\
функция возвращает тип, значением которого является результат теста:
```c++
typedef int testScore_t;
testScore_t GradeTest();
```

### `typedef` и поддержка кода
`typedef` также позволяет изменить базовый тип объекта без внесения изменений в\
большое количество кода. Например, если вы использовали тип `short` для хранения\
идентификационного номера учащегося, но потом решили, что лучше использовать\
тип `long`, с `typedef` же всё, что вам нужно сделать, — это изменить объявление\
`typedef short studentID_t` на `typedef long studentID_t`.

### `typedef` и кроссплатформенность
Поскольку `char`, `short`, `int` и `long` не указывают свой размер, то для\
кроссплатформенных программ довольно часто используется `typedef` для\
определения псевдонимов, которые включают размер типа данных в битах.\
Например, `int8_t` — это 8-битный `signed int`, `int16_t` — это 16-битный `signed int`, а\
`int32_t` — это 32-битный `signed int`.

### `typedef` и упрощение сложного
С помощью `typedef` вы можете давать простые имена сложным типам данных,\
что сделает их проще как для использования, так и для понимания.
```c++
// используем pairlist_t в качестве псевдонима для этого длиннющего типа данных
typedef std::vector<std::pair<std::string, int>> pairlist_t; 

pairlist_t pairlist; // объявляем pairlist_t

boolean hasAttribute(pairlist_t pairlist) // используем pairlist_t в качестве типа параметра функции
{
// Что-то делаем
}
```

### `type alias`
С помощью `type alias` мы пишем имя, которое затем используется как\
синоним конкретного типа данных (т.е. принцип тот же, но синтаксис более удобен):
```c++
typedef double time_t; // используем time_t в качестве псевдонима для типа double

using time_t = double; // используем time_t в качестве псевдонима для типа double
```
**Правило: Используйте type alias вместо typedef, если ваш компилятор
поддерживает C++11.**

### Тест

**Задание №1.**\
Используя следующий прототип функции:\
`int editData();`\
Преобразуйте тип возвращаемого значения `int` в `status_t`, используя ключевое слово\
`typedef`.

```c++
typedef int status_t;
status_t editData();
```

**Задание №2.**\
Используя прототип функции из задания №1, преобразуйте тип возвращаемого\
значения `int` в `status_t`, используя ключевое слово `using` (C++11).

```c++
using status_t = int;
status_t editData();
```

## Урок №64. Структуры
**Структура позволяет сгруппировать переменные разных типов в единое целое.**

### Объявление и определение структур
```c++
struct Employee {
    short id;  // член (поле) структуры
    int age;
    double salary;
};

Employee john;
Employee james;
```

### Доступ к членам структур
```c++
Employee john; // создаем отдельную структуру Employee для John-а
john.id = 8; // присваиваем значение члену id структуры john
john.age = 27; // присваиваем значение члену age структуры john
john.salary = 32.17; // присваиваем значение члену salary структуры john

Employee james; // создаем отдельную структуру Employee для James-а
james.id = 9; // присваиваем значение члену id структуры james
james.age = 30; // присваиваем значение члену age структуры james
james.salary = 28.35; // присваиваем значение члену salary структуры james
```

### Инициализация структур
**Список инициализаторов:**
```c++
struct Employee {
    short id;
    int age;
    double salary;
};

// Так:
Employee john = { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
// Или так (uniform-инициализация):
Employee james{6, 29}; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)
```

### C++11/14: Инициализация нестатических членов структур
В C++11 добавили возможность присваивать нестатическим (обычным) членам\
структуры значения по умолчанию. Например:
```c++
#include <iostream>

struct Triangle {
    double length = 2.0;
    double width = 2.0;
};

int main() {
    Triangle z; // длина = 2.0, ширина = 2.0
    z.length = 3.0; // вы также можете присваивать членам структуры и другие значения
    
    Triangle b{ 3.0, 3.0 }; // uniform-инициализация также доступна
    return 0;
}
```

### Структуры и функции
Большим преимуществом использования структур является возможность передать всю структуру\
в функцию, которая должна работать с её членами:
```c++
#include <iostream>

struct Employee {
    short id;
    int age;
    double salary;
};

void printInformation(Employee employee) {
    std::cout << "ID: " << employee.id << "\n";
    std::cout << "Age: " << employee.age << "\n";
    std::cout << "Salary: " << employee.salary << "\n";
}

int main() {
    Employee john = { 21, 27, 28.45 };
    Employee james = { 22, 29, 19.29 };
    
    // Выводим информацию о John-е
    printInformation(john);
    std::cout << "\n";
    
    // Выводим информацию о James-е
    printInformation(james);
    
    return 0;
}

<< ID: 21
<< Age: 27
<< Salary: 28.45
<< ID: 22
<< Age: 29
<< Salary: 19.29
```

Функция также может возвращать структуру:
```c++
#include <iostream>

struct Point3d {
    double x;
    double y;
    double z;
};

Point3d getZeroPoint() {
    Point3d temp = { 0.0, 0.0, 0.0 };
    return temp;
}

int main() {
    Point3d zero = getZeroPoint();
    
    if (zero.x == 0.0 && zero.y == 0.0 && zero.z == 0.0)
        std::cout << "The point is zero\n";
    else
        std::cout << "The point is not zero\n";
    
    return 0;
}

<< The point is zero
```

### Вложенные структуры
```c++
#include <iostream>

struct Employee {
    short id;
    int age;
    double salary;
};

struct Company {
    Employee CEO; // Employee - это структура внутри структуры Company
    int numberOfEmployees;
};

int main() {
    Company myCompany = {{ 3, 35, 55000.0f }, 7 };
    std::cout << myCompany.CEO.salary;

    return 0;
}

<< 55000
```

### Размер структур
На большинстве платформ тип `short` занимает 2 байта, тип `int` — 4 байта, а тип `double` — 8 байт.\
Следовательно, ожидается, что `Employee` будет занимать 2 + 4 + 8 = 14 байт. Чтобы узнать\
точный размер `Employee`, мы можем воспользоваться оператором `sizeof`:
```c++
#include <iostream>

struct Employee {
    short id;
    int age;
    double salary;
};

int main() {
    std::cout << "The size of Employee is " << sizeof(Employee) << "\n";
    
    return 0;
}

<< The size of Employee is 16
```
Оказывается, мы можем сказать только, что размер структуры будет, _по крайней\
мере_, не меньше суммы размеров всех её членов. По соображениям производительности\
компилятор иногда может добавлять "пробелы/промежутки" в структуры.

### Тест 
**Задание №1**
У вас есть веб-сайт и вы хотите отслеживать, сколько денег вы зарабатываете в день\
от размещенной на нем рекламы. Объявите структуру `Advertising`, которая будет\
отслеживать:
* сколько объявлений вы показали посетителям (1);
* сколько процентов посетителей нажали на объявления (2);
* сколько вы заработали в среднем за каждое нажатие на объявления (3).

Значения этих трех полей должен вводить пользователь. Передайте структуру\
`Advertising` в функцию, которая выведет каждое из этих значений, а затем
подсчитает, сколько всего денег вы заработали за день (перемножьте все 3 поля).

```c++
#include <iostream>

// Сначала объявляем структуру Advertising
struct Advertising {
    int adsShown;
    double clickThroughRatePercentage;
    double averageEarningsPerClick;
};

void printAdvertising(Advertising ad) {
    using namespace std;
    cout << "Number of ads shown: " << ad.adsShown << endl;
    cout << "Click through rate: " << ad.clickThroughRatePercentage << endl;
    cout << "Average earnings per click: $" << ad.averageEarningsPerClick << endl;
    // Следующая строка кода разбита из-за своей длины.
    // Мы делим ad.clickThroughRatePercentage на 100, так как пользователь указывает проценты, а не готовое число
    cout << "Total Earnings: $" <<
         (ad.adsShown * ad.clickThroughRatePercentage / 100 *
          ad.averageEarningsPerClick) << endl;
}
int main() {
    using namespace std;
    // Объявляем переменную структуры Advertising
    Advertising ad{};
    cout << "How many ads were shown today? ";
    cin >> ad.adsShown;
    cout << "What percentage of users clicked on the ads? ";
    cin >> ad.clickThroughRatePercentage;
    cout << "What was the average earnings per click? ";
    cin >> ad.averageEarningsPerClick;
    printAdvertising(ad);
    
    return 0;
}

<< How many ads were shown today? 200
<< What percentage of users clicked on the ads? 45
<< What was the average earnings per click? 2
<< Number of ads shown: 200
<< Click through rate: 45
<< Average earnings per click: $2
<< Total Earnings: $180

```

**Задание №2**
Создайте структуру для хранения дробных чисел. Структура должна иметь 2 члена:\
целочисленный числитель и целочисленный знаменатель. Объявите две дробные\
переменные и получите их значения от пользователя. Напишите функцию `multiply()`\
(параметрами которой будут эти две переменные), которая будет перемножать эти\
числа и выводить результат в виде десятичного числа.

```c++
#include <iostream>

struct Fractional {
    int numerator;
    int denominator;
};

void multiply(Fractional d1, Fractional d2) {
    using namespace std;
    // Не забываем об операторе static_cast, иначе компилятор выполнит целочисленное деление!
    cout << static_cast<float>(d1.numerator * d2.numerator) /
            (d1.denominator * d2.denominator);
}

int main() {
    using namespace std;
    // Определяем первую переменную-дробь
    Fractional d1{};
    cout << "Input the first numerator: ";
    cin >> d1.numerator;
    cout << "Input the first denominator: ";
    cin >> d1.denominator;

    // Определяем вторую переменную-дробь
    Fractional d2{};
    cout << "Input the second numerator: ";
    cin >> d2.numerator;
    cout << "Input the second denominator: ";
    cin >> d2.denominator;
    multiply(d1, d2);

    return 0;
}

<< Input the first numerator: 12
<< Input the first denominator: 5
<< Input the second numerator: 14
<< Input the second denominator: 3
<< 11.2
```

## Урок №65. Вывод типов: ключевое слово auto
Начиная с C++11, **ключевое слово `auto`** при инициализации переменной может\
использоваться вместо типа переменной, чтобы сообщить компилятору, что он\
должен присвоить тип переменной исходя из инициализируемого значения. Это\
называется **выводом типа** (или **"автоматическим определением типа данных\
компилятором"**).
```c++
auto x = 4.0; // 4.0 - это литерал типа double, поэтому и x должен быть типа double
auto y = 3 + 4; // выражение 3 + 4 обрабатывается как целочисленное, поэтому и переменная y должна быть типа int
```

В C++14 функционал ключевого слова auto был расширен до автоматического\
определения типа возвращаемого значения функции. Хотя это может показаться\ 
удобным, так делать не рекомендуется:
```c++
auto subtract(int a, int b) {
    return a - b;
}

int main() {
    auto result = subtract(4, 3); 
    return 0;
}
```
**Обратите внимание, это работает только с инициализированными переменными.**

### trailing-синтаксис в C++11
**Синтаксис типа возвращаемого значения `trailing` (или просто "trailing-синтаксис")**
```c++
// Обычное объявление функции:
int subtract(int a, int b);

// В C++11 это можно записать как:
auto subtract(int a, int b) -> int;
```

```c++
auto subtract(int a, int b) -> int;
auto divide(double a, double b) -> double;
auto printThis() -> void;
auto calculateResult(int a, double x) -> std::string;
```

### Резюме 
Начиная с C++11 ключевое слово `auto` может использоваться вместо типа\
переменной при инициализации для выполнения вывода типа. Во всех других\
случаях использования ключевого слова auto следует избегать, если на это нет\
веских причин.

## Глава №4. Итоговый тест
### Теория
**Блок стейтментов** (или **"составной оператор"**) обрабатывается компилятором так,\
как если бы это был один стейтмент. Составные операторы помещаются в фигурные\
скобки `{` и `}` и используются почти везде.

**Локальные переменные** создаются в точке определения и уничтожаются при\
выходе из блока, в котором они объявлены. Доступ к ним возможен только внутри\
этого же блока.

**Глобальные переменные** создаются, когда программа запускается, и\
уничтожаются, когда она завершает свое выполнение. Они могут использоваться в\
любом месте программы. Неконстантные глобальные переменные следует\
избегать, потому что это — зло.

**Ключевое слово `static`** может использоваться для преобразования глобальной\
переменной во внутреннюю (с внутренней связью), чтобы её можно было\
использовать только в том файле, в котором она объявлена. Также ключевое слово\
`static` используют для указания того, что локальная переменная должна иметь\
статическую продолжительность жизни. А это означает, что она будет сохранять\
свое значение даже после выхода из своей области видимости.

**Пространство имен** — это область, в которой гарантируется уникальность всех\
имен. Отличный способ избежать конфликтов имен. Не используйте using-\
стейтменты вне тела функций.

**Неявное преобразование типов данных** происходит, когда один тип данных\
конвертируется в другой тип без использования одного из операторов явного\
преобразования. Явное преобразование типа происходит, когда один тип данных\
конвертируется в другой с помощью одного из операторов явного преобразования.\
В некоторых случаях это абсолютно безопасно, в других случаях данные могут быть\
потеряны. Избегайте использования конвертации `C-style`, вместо нее используйте\
оператор `static_cast`.

`std::string` — это простой способ работы с текстовыми строками (текст помещается в\
двойные кавычки).

**Перечисления** позволяют создавать собственные (пользовательские) типы данных.\
**Классы enum** — это те же перечисления, но надежнее и безопаснее. Используйте их\
вместо обычных перечислений, если ваш компилятор поддерживает C++11.

`typedef` позволяет создавать псевдонимы для типов данных. Целочисленные типы\
данных с фиксированным размером реализованы с помощью `typedef`. Псевдонимы\
типов полезны для присваивания простых имен сложным типам данных.

И, наконец, **структуры**. Они позволяют сгруппировать отдельные переменные в\
единое целое. Доступ к членам структуры осуществляется через оператор выбора\
членов (`.`). Объектно-ориентированное программирование в значительной степени\
основывается именно на структурах, поэтому, если вы изучили только одну вещь из\
этой главы, то лучше, чтобы это были структуры.

### Тест
При разработке игры мы решили, что в ней должны быть монстры, потому что всем\
нравится сражаться с монстрами. Объявите структуру, которая представляет вашего\
монстра. Монстр может быть разным: `ogre`, `goblin`, `skeleton`, `orc` и `troll`. Если\
ваш компилятор поддерживает C++11, то используйте классы `enum`, если нет —\
обычные перечисления.

Каждый монстр также должен иметь имя (используйте `std::string`) и количество\
здоровья, которое отображает, сколько урона он может получить, прежде чем\
умрет. Напишите функцию `printMonster()`, которая выведет все члены структуры.\
Объявите монстров типа `goblin` и `orc`, инициализируйте их, используя список\
инициализаторов, и передайте в функцию `printMonster()`.

Пример результата выполнения вашей программы:\
`This Goblin is named John and has 170 health.`\
`This Orc is named James and has 35 health.`

```c++
#include <iostream>
#include <string>

// Определяем класс enum с типами монстров
enum class MonsterType {
    OGRE,
    GOBLIN,
    SKELETON,
    ORC,
    TROLL
};

// Наша структура представляет одного монстра
struct Monster {
    MonsterType type;
    std::string name;
    int health;
};

// Возвращаем тип монстра в виде строки
std::string getMonsterTypeString(Monster monster) {
    if (monster.type == MonsterType::OGRE)
        return "Ogre";
    if (monster.type == MonsterType::GOBLIN)
        return "Goblin";
    if (monster.type == MonsterType::SKELETON)
        return "Skeleton";
    if (monster.type == MonsterType::ORC)
        return "Orc";
    if (monster.type == MonsterType::TROLL)
        return "Troll";
    return "Unknown";
}

// Выводим информацию о монстре
void printMonster(Monster monster) {
    std::cout << "This " << getMonsterTypeString(monster);
    std::cout << " is named " << monster.name << " and has "<< monster.health
              << " health.\n";
}

int main() {
    Monster goblin { MonsterType::GOBLIN, "John", 170 };
    Monster orc { MonsterType::ORC, "James", 35 };
    printMonster(goblin);
    printMonster(orc);

    return 0;
}

<< This Goblin is named John and has 170 health.
<< This Orc is named James and has 35 health.
```

# Глава №5.
## Урок №66. Операторы управления потоком выполнения программ
### Остановка
```c++
#include <iostream>
#include <cstdlib> // для функции exit()

int main() {
    std::cout << 5;
    exit(0); // завершаем выполнение программы и возвращаем 0 обратно в операционную систему
    
    // Следующие стейтменты никогда не выполнятся
    std::cout << 3;
    
    return 0;
}
```

### Прыжок
Следующим оператором управления порядком выполнения программы является\
**прыжок** (или **"переход"**). Он безоговорочно сообщает компилятору во время\
выполнения перейти от одного стейтмента к другому, т.е. выполнить прыжок.\
**Ключевые слова `goto`, `break` и `continue`** являются разными типами прыжков.

### Условные ветвления
**Условное ветвление** заставляет программу изменить свой порядок выполнения,\
основываясь на значении результата выражения.\
**Ключевое слово switch** также предоставляет механизм для выполнения условного\
ветвления.

### Циклы
**Цикл** заставляет программу многократно выполнять определенное количество\
стейтментов до тех пор, пока заданное условие не станет ложным.

**В языке C++ есть 4 типа циклов:**
* цикл while;
* цикл do while;
* цикл for;
* цикл foreach (добавили в C++11).

### Исключения
**Исключения** предлагают механизм обработки ошибок, возникающих в функции.


## Урок №67. Операторы условного ветвления `if/else`
### Использование нескольких операций в ветвлениях `if/else`
```c++
if (expression) {
    ...
    ...
    ...
}
else {
    ...
    ...
    ...
}
```

### Связывание стейтментов `if`
```c++
if (expression1)
    ...
else if (expression2)
    ...
else
    ...
```

### Вложенные ветвления `if/else`
Используя блоки стейтментов, мы уточняем, к какому `if` следует прикреплять\
определенный `else`. Без блоков оператор `else` будет прикрепляться к ближайшему\
незакрытому оператору `if`.
```c++
#include <iostream>

int main() {
    std::cout << "Enter a number: ";
    int a;
    std::cin >> a;
    
    if (a > 15) {
        if (a < 25)
            std::cout << a << " is between 15 and 25\n";
    }
    else // относится к внешнему оператору if
        std::cout << a << " is less than 15\n";
    
    return 0;
}
```

### Использование логических операторов в ветвлениях `if/else`
Также вы можете проверить сразу несколько условий в ветвлениях `if/else`, используя\
логические операторы:
```c++
if (expression1 && expression2) {  // логическое И
    ...
}
else if (expression1 || expression2) {  // логическое ИЛИ
    ...
}
else {
    ...
}
```

### Основные использования ветвлений `if/else`
**Ранние возвраты:**
```c++
#include <iostream>

enum class ErrorCode {
ERROR_SUCCESS = 0,
ERROR_NEGATIVE_NUMBER = -1
};

ErrorCode doSomething(int value) {
    // Если параметром value является отрицательное число,
    if (value < 0)
        // то сразу же возвращаем код ошибки
        return ErrorCode::ERROR_NEGATIVE_NUMBER;
    
    // Что-нибудь делаем
    
    return ErrorCode::ERROR_SUCCESS;
}
```

```c++
int min(int a, int b) {
    return (a > b) ? b : a;
}
```

### Нулевые стейтменты
Также в C++ можно не указывать основную часть оператора `if`. Такие стейтменты\
называются **нулевыми стейтментами** (или **"null-стейтментами"**)
```c++
if (a > 15)
    ; // это нулевой стейтмент
```

**Предупреждение:** Всегда проверяйте, не "закрыли" ли вы случайно оператор `if`\
точкой с запятой.

## Урок №68. Оператор `switch`
```c++
#include <iostream>

enum Colors {
    COLOR_GRAY,
    COLOR_PINK,
    COLOR_BLUE,
    COLOR_PURPLE,
    COLOR_RED
};

void printColor(Colors color) {
    switch (color) {
        case COLOR_GRAY:
            std::cout << "Gray";
            break;
        case COLOR_PINK:
            std::cout << "Pink";
            break;
        case COLOR_BLUE:
            std::cout << "Blue";
            break;
        case COLOR_PURPLE:
            std::cout << "Purple";
            break;
        case COLOR_RED:
            std::cout << "Red";
            break;
        default:
            std::cout << "Unknown";
            break;
    }
}

int main() {
    printColor(Colors::COLOR_BLUE);

    return 0;
}
```

### Лейблы case
Можно использовать **сразу несколько кейсов** для одного выражения. Следующая\
функция использует несколько кейсов для проверки, соответствует ли параметр `p`\
числу из ASCII-таблицы:
```c++
#include <iostream>

bool isDigit(char p) {
    switch (p)
    {
        case '0': // если p = 0
        case '1': // если p = 1
        case '2': // если p = 2
        case '3': // если p = 3
        case '4': // если p = 4
        case '5': // если p = 5
        case '6': // если p = 6
        case '7': // если p = 7
        case '8': // если p = 8
        case '9': // если p = 9
            return true; // возвращаем true
        default: // в противном случае, возвращаем false
            return false;
    }
}

int main() {
    std::cout << isDigit('2');
    return 0;
}

<< 1
```

### Лейбл по умолчанию
Второй тип лейбла — это **лейбл по умолчанию** (так называемый **"default case"**),
который объявляется с использованием **ключевого слова default**.


### `switch` и `fall-through`
Когда кейс совпал (или выполняется `default`), то выполнение начинается с\
первого стейтмента, который находится после соответствующего кейса и\
продолжается до тех пор, пока не будет выполнено одно из следующих условий\
завершения:
```c++
switch (2) {
        case 1: // Не совпадает!
            std::cout << 1 << '\n'; // пропускается
        case 2: // Совпало!
            std::cout << 2 << '\n'; // выполнение кода начинается здесь
        case 3:
            std::cout << 3 << '\n'; // это также выполнится
        case 4:
            std::cout << 4 << '\n'; // и это
        default:
            std::cout << 5 << '\n'; // и это
    }

<< 2
<< 3
<< 4
<< 5
```
Когда выполнение переходит из одного кейса в следующий, то это называется **fall-through**.

### `switch` и оператор `break`
Оператор `break` (объявленный с использованием ключевого слова `break`) сообщает
компилятору, что мы уже сделали всё, что хотели с определенным `switch` (или
циклом `while`, `do while` или `for`) и больше не намерены с ним работать.
```c++
switch (2) {
        case 1: // Не совпадает!
            std::cout << 1 << '\n'; // пропускается
            break;
        case 2: // Совпало!
            std::cout << 2 << '\n'; // выполнение кода начинается здесь
            break;  // оператор break завершает выполнение switch-а
        case 3:
            std::cout << 3 << '\n';
            break;
        case 4:
            std::cout << 4 << '\n';
            break;
        default:
            std::cout << 5 << '\n';
            break;
    }
    
<< 2
```

### Несколько стейтментов внутри блока `switch`
```c++
switch (2) {
        case 2:
            std::cout << 2 << '\n';
            doSomething();
            std::cout << 4 << '\n';
            break;
        default:
            std::cout << "default case" << '\n';
            break;
    }
```

### Объявление переменной и её инициализация внутри `case`
Обратите внимание, что, хотя переменная `z` была определена в первом кейсе, она\
также используется и во втором кейсе. Все кейсы считаются частью одной и той же\
области видимости, поэтому, объявив переменную в одном кейсе, мы можем\
спокойно использовать её без объявления и в других кейсах.
```c++
switch (x) {
        case 1:
            int z; // ок, объявление разрешено
            z = 5; // ок, операция присваивания разрешена
            break;
        case 2:
            z = 6; // ок, переменная z была объявлена выше, поэтому мы можем использовать её здесь
            break;
        case 3:
            int c = 4; // нельзя, вы не можете инициализировать переменные внутри case
            break;
        default:
            std::cout << "default case" << std::endl;
            break;
    }
```

**Правило: Если нужно инициализировать и/или объявить переменные внутри\
кейса — используйте блоки стейтментов.**
```c++
switch (1) {
    case 1: { // обратите внимание, здесь указан блок
        int z = 5; // хорошо, переменные можно инициализировать внутри блока, который находится внутри кейса
        std::cout << z;
        break;
    }
    default:
        std::cout << "default case" << std::endl;
        break;
}
```

### Тест
**Задание №1.**\
Напишите функцию `calculate()`, которая принимает две переменные типа `int` и одну\
переменную типа `char`, которая, в свою очередь, представляет одну из следующих\
математических операций: `+`, `-`, `*`, `/` или `%` (остаток от числа). Используйте `switch`\
для выполнения соответствующей математической операции над целыми числами,\
а результат возвращайте обратно в `main()`. Если в функцию передается\
недействительный математический оператор, то функция должна выводить ошибку.\
С оператором деления выполняйте целочисленное деление.

```c++
#include <iostream>

int calculate(int x, int y, char op) {
    switch (op) {
        case '+':
            return x + y;
        case '-':
            return x - y;
        case '*':
            return x * y;
        case '/':
            return x / y;
        case '%':
            return x % y;
        default:
            std::cout << "calculate(): Unhandled case\n";
            return 0;
    }
}

int main() {
    std::cout << "Enter an integer: ";
    int x;
    std::cin >> x;
    std::cout << "Enter another integer: ";
    int y;
    std::cin >> y;
    std::cout << "Enter a mathematical operator (+, -, *, /, or %): ";
    char op;
    std::cin >> op;
    std::cout << x << " " << op << " " << y << " is " << calculate(x, y, op) << "\n";
    
    return 0;
}
```

**Задание №2.**\
Определите перечисление (или класс `enum`) `Animal`, которое содержит следующих\
животных: `pig`, `chicken`, `goat`, `cat`, `dog` и `ostrich`. Напишите функцию\
`getAnimalName()`, которая принимает параметр `Animal` и использует `switch` для\
возврата типа животного в качестве строки. Напишите еще одну функцию —\
`printNumberOfLegs()`, которая использует `switch` для вывода количества лап\
соответствующего типа животного. Убедитесь, что обе функции имеют кейс `default`,\
который выводит сообщение об ошибке. Вызовите `printNumberOfLegs()` в `main()`,\
используя в качестве параметров `cat` и `chicken`.

```c++
#include <iostream>
#include <string>

enum Animal {
    ANIMAL_PIG,
    ANIMAL_CHICKEN,
    ANIMAL_GOAT,
    ANIMAL_CAT,
    ANIMAL_DOG,
    ANIMAL_OSTRICH
};

std::string getAnimalName(Animal animal) {
    switch (animal) {
        case ANIMAL_CHICKEN:
            return "chicken";
        case ANIMAL_OSTRICH:
            return "ostrich";
        case ANIMAL_PIG:
            return "pig";
        case ANIMAL_GOAT:
            return "goat";
        case ANIMAL_CAT:
            return "cat";
        case ANIMAL_DOG:
            return "dog";
        default:
            return "getAnimalName(): Unhandled enumerator";
    }
}

void printNumberOfLegs(Animal animal) {
    std::cout << "A " << getAnimalName(animal) << " has ";
    switch (animal) {
        case ANIMAL_CHICKEN:
        case ANIMAL_OSTRICH:
            std::cout << "2";
            break;
        case ANIMAL_PIG:
        case ANIMAL_GOAT:
        case ANIMAL_CAT:
        case ANIMAL_DOG:
            std::cout << "4";
            break;
        default:
            std::cout << "printNumberOfLegs(): Unhandled enumerator";
            break;
    }
    std::cout << " legs.\n";
}

int main() {
    printNumberOfLegs(ANIMAL_CAT);
    printNumberOfLegs(ANIMAL_CHICKEN);
    
    return 0;
}

<< A cat has 4 legs.
<< A chicken has 2 legs.
```

## Урок №69. Оператор `goto`
**Оператор `goto`** – это оператор управления потоком выполнения программ, который\
заставляет центральный процессор выполнить переход из одного участка кода в\
другой (осуществить прыжок). Другой участок кода идентифицируется с помощью\
**лейбла**. Например:
```c++
#include <iostream>
#include <cmath> // для функции sqrt()

int main() {
    double z;
    tryAgain: // это лейбл
    std::cout << "Enter a non-negative number: ";
    std::cin >> z;

    if (z < 0.0)
        goto tryAgain; // а это оператор goto
    std::cout << "The sqrt of " << z << " is " << sqrt(z) << std::endl;

    return 0;
}

<< Enter a non-negative number: -5
<< Enter a non-negative number: 2
<< The sqrt of 2 is 1.41421
```

Ранее мы рассматривали два типа области видимости: локальная (или "блочная") и\
глобальная (или "файловая"). Лейблы используют третий тип области видимости:\
**область видимости функции**. Оператор `goto` и соответствующий лейбл должны\
находиться в одной и той же функции.

Существуют некоторые ограничения на использование операторов `goto`. Например,\
вы не сможете перепрыгнуть вперед через переменную, которая\
инициализирована в том же блоке, что и `goto`:
```c++
int main() {
    goto skip; // прыжок вперед недопустим
    int z = 7;
    skip: // лейбл
    z += 4; // какое значение будет в этой переменной?
    return 0;
}
```

**Спагетти-код** — это код, порядок выполнения которого напоминает тарелку\
со спагетти (всё запутано и закручено), что крайне затрудняет следование\
порядку и понимание логики выполнения такого кода.

**Правило: Избегайте использования операторов goto, если на это нет веских
причин.**

## Урок №70. Цикл `while`
```c++
while (expression)
    ...
```

### Бесконечные циклы
```c++
while (1) {  // или while (true)
    // Этот цикл будет выполняться бесконечно
}
```

### Счетчик цикла `while`
Счетчик цикла — это целочисленная переменная, которая объявляется с единственной целью:\
считать, сколько раз выполнился цикл.

**Правило: Всегда используйте тип `signed int` для счетчиков цикла.**

### Итерации
Каждое выполнение цикла называется **итерацией** (или **"повтором"**).

**Не фундаментальные типы (такие как структуры или классы) переменных лучше\
определять перед циклом.**

### Тест
**Задание №1. (ответ)**\
Переменные нужно объявлять максимально близко к их первому использованию.

**Задание №2.**\
Напишите программу, которая выводит буквы английского алфавита от `a` до `z`\
вместе с кодами из ASCII-таблицы.

```c++
#include <iostream>

int main() {
    char mychar = 'a';
    while (mychar <= 'z') {
        std::cout << mychar << " " << static_cast<int>(mychar) << "\n";
        ++mychar;
    }
    
    return 0;
}
```

**Задание №3.**\
Измените программу из последнего подраздела «Вложенные циклы» так, чтобы она\
выводила следующее:
```c++
#include <iostream>

int main() {
    int outer = 5;
    while (outer >= 1) {
        int inner = outer;
        while (inner >= 1)
            std::cout << inner-- << " ";
        // Вставляем символ новой строки в конце каждого ряда
        std::cout << "\n";
        --outer;
    }
    
    return 0;
}
```

**Задание №4.**\
Теперь сделайте так, чтобы цифры выводились следующим образом (используя\
программу из предыдущего задания):
```c++
#include <iostream>

int main() {
    // Цикл с 1 до 5
    int outer = 1;
    while (outer <= 5) {
        // Числа в рядах появляются в порядке убывания, поэтому цикл начинаем с 5 и до 1
        int inner = 5;
        while (inner >= 1) {
            // Первое число в любом ряде совпадает с номером этого ряда, поэтому числа должны
            // выводиться только если <= номера ряда (в противном случае, выводится пробел)
            if (inner <= outer)
                std::cout << inner << " ";
            else
                std::cout << " "; // вставляем дополнительные пробелы
            --inner;
        }
        // Этот ряд вывели, переходим к следующему
        std::cout << "\n";
        ++outer;
    }
    
    return 0;
}
```

## Урок №71. Цикл `do while`
**Синтаксис `do while` в языке C++:**
```c++
do
    ...;
while (expression);
```

## Урок №72. Цикл `for`
### Цикл `for`
```c++
for (объявление переменных; условие; инкремент/декремент счетчика)
    ...;
```

Переменные, определенные внутри цикла `for`, имеют специальный тип области\
видимости: **область видимости цикла**. Такие переменные существуют только\
внутри цикла и недоступны за его пределами.

### Выполнение цикла `for`
```c++
#include <iostream>

int main() {
    for (int count = 0; count < 10; ++count)
        std::cout << count << " ";

    return 0;
}
```

### Пропущенные выражения в цикле
```c++
#include <iostream>

int main() {
    int count = 0;
    for (; count < 10; ) {
        std::cout << count << " ";
        ++count;
    }
    
    return 0;
}
```

```c++
for (;;)  // бесконечный цикл
    ...;
```

### Объявления переменных в цикле `for`
```c++
#include <iostream>

int main() {
    for (int aaa = 0, bbb = 9; aaa < 10; ++aaa, --bbb)
        std::cout << aaa << " " << bbb << std::endl;

    return 0;
}

<< 0 9
<< 1 8
<< 2 7
<< 3 6
<< 4 5
<< 5 4
<< 6 3
<< 7 2
<< 8 1
<< 9 0
```

### Тест
**Задание №1.**\
Напишите цикл `for`, который выводит каждое четное число в диапазоне от 0 до 20.
```c++
#include <iostream>

int main() {
    for (int count = 0; count <= 20; count += 2)
        std::cout << count << std::endl;
    
    return 0;
}
```

**Задание №2.**\
Напишите функцию `sumTo()`, которая принимает целочисленный параметр с именем
`value` и возвращает сумму всех чисел от `1` до значения `value`.
```c++
int sumTo(int value) {
    int total(0);
    for (int count=1; count <= value; ++count)
        total += count;
    
    return total;
}
```

## Урок №73. Операторы `break` и `continue`
### Оператор `break`
```c++
#include <iostream>

int main() {
    while (true) {  // бесконечный цикл
        std::cout << "Enter 0 to exit or anything else to continue: ";
        int val;
        std::cin >> val;
        // Выходим из цикла, если пользователь ввел 0
        if (val == 0)
            break;
    }
    std::cout << "We're out!\n";

    return 0;
}
```

### Оператор `continue`
Оператор `continue` позволяет сразу перейти в конец тела цикла, пропуская весь код,
который находится под ним.
```c++
#include <iostream>

int main() {
    int count(0);
    do {
        if (count == 5)
            continue; // переходим в конец тела цикла
        std::cout << count << " ";
    // Точка выполнения после оператора continue перемещается сюда
    } while (++count < 10); // этот код выполняется, так как он находится вне тела цикла

    return 0;
}

<< 0 1 2 3 4 6 7 8 9
```

## Урок №74. Генерация случайных чисел
### Генератор псевдослучайных чисел
**Генератор псевдослучайных чисел** (сокр. "**ГПСЧ**") — это программа, которая\
принимает стартовое/начальное значение и выполняет с ним определенные\
математические операции, чтобы конвертировать его в другое число, которое\
совсем не связано со стартовым.
```c++
unsigned int PRNG() {
    // Наше стартовое число - 4 541
    static unsigned int seed = 4541;

    // Берем стартовое число и, с его помощью, генерируем новое значение.
    // Из-за использования очень больших чисел (и переполнения) угадать следующее число
    // исходя из предыдущего - очень сложно
    seed = (8253729 * seed + 2396403);

    // Берем стартовое число и возвращаем значение в диапазоне от 0 до 32767
    return seed % 32768;
}
```

### Функции `srand()` и `rand()`
`cstdlib`:
* **Функция `srand()`** устанавливает передаваемое пользователем значение в
  качестве стартового. `srand()` следует вызывать только один раз — в начале
  программы (обычно в верхней части функции `main()`).
* **Функция `rand()`** генерирует следующее случайное число в
  последовательности. Оно будет находиться в диапазоне от `0` до
  `RAND_MAX` (константа в `cstdlib`, значением которой является `32767`).

```c++
#include <iostream>
#include <cstdlib> // для функций rand() и srand()

int main() {
    srand(4541); // устанавливаем стартовое значение - 4 541

    // Выводим 100 случайных чисел
    for (int count = 0; count < 20; ++count) {
        std::cout << rand() << "\t";
        // Если вывели 5 чисел, то вставляем символ новой строки
        if ((count + 1) % 5 == 0)
            std::cout << "\n";
    }
}

<< 822351550	1622942556	1721308543	188933821	858593265	
   1584136113	790961218	377942596	486417893	2090487109	
   1000318466	402762403	1806474202	1283089007	1964638683	
   1562682819	1550405832	217774549	309706346	102057035	
```

### Стартовое число и последовательности в ГПСЧ
В языке Cи есть функция `time()`, которая возвращает в качестве времени общее\
количество секунд, прошедшее от полуночи 1 января 1970 года.\
Теперь наша программа будет генерировать разные последовательности случайных чисел:
```c++
#include <iostream>
#include <cstdlib> // для функций rand() и srand()
#include <ctime> // для функции time()

int main() {
    srand(static_cast<unsigned int>(time(0))); // устанавливаем значение системных часов в качестве стартового числа
    for (int count=0; count < 20; ++count) {
        std::cout << rand() << "\t";
        // Если вывели 5 чисел, то вставляем символ новой строки
        if ((count+1) % 5 == 0)
            std::cout << "\n";
    }
}
```

### Генерация случайных чисел в заданном диапазоне
```c++
int getRandomNumber(int min, int max) {
    // Предполагается, что srand уже вызвали
    return rand() % (min - max + 1) + min;
}
```

### Рандомные числа в C++11
**Вихрь Марсенна (Mersenne Twister) для случайных 32-битных чисел `unsigned`:**
```c++
#include <iostream>
#include <random>  // для std::random_device и std::mt19937


int main() {
    std::random_device rd;
    std::mt19937 mersenne{rd()}; // инициализируем Вихрь Мерсенна случайным стартовым числом

    // Выводим несколько случайных чисел
    for (int count = 0; count < 48; ++count) {
        std::cout << mersenne() << "\t";
        // Если вывели 5 чисел, то вставляем символ новой строки
        if ((count + 1) % 5 == 0)
            std::cout << "\n";
    }

    return 0;
}
```

## Урок №75. Обработка некорректного пользовательского ввода
Программа, которая имеет обработку некорректного ввода, называется **надежной**.
### std::cin, буфер данных и извлечение
Оператор `>>` называется **оператором извлечения**.

**Обработка некорректных извлечений (примитивный калькулятор):**
```c++
double getValue() {
    while (true) {  // цикл продолжается до тех пор, пока пользователь не введет корректное значение
        std::cout << "Enter a double value: ";
        double a;
        std::cin >> a;
        if (std::cin.fail()) {  // если предыдущее извлечение оказалось неудачным,
            std::cin.clear(); // то возвращаем cin в 'обычный' режим работы
            std::cin.ignore(32767, '\n'); // и удаляем значения предыдущего ввода из входного буфера
            std::cout << "Oops, that input is invalid. Please try again.\n";
        } else // если всё хорошо, то возвращаем a
            std::cin.ignore(32767,'\n'); // удаляем лишние значения
            return a;
    }
}

char getOperator() {
    while (true) {  // цикл продолжается до тех пор, пока пользователь не введет корректное значение
        std::cout << "Enter one of the following: +, -, *, or /: ";
        char sm;
        std::cin >> sm;
        // Переменные типа char могут принимать любые символы из
        // пользовательского ввода, поэтому нам не стоит беспокоиться по поводу
        // возникновения неудачного извлечения
        std::cin.ignore(32767, '\n'); // удаляем лишний балласт
        // Выполняем проверку пользовательского ввода
        if (sm == '+' || sm == '-' || sm == '*' || sm == '/')
            return sm; // возвращаем обратно в caller
        else // в противном случае, сообщаем пользователю, что что-то пошло не так
            std::cout << "Oops, that input is invalid. Please try again.\n";
    }
}

void printResult(double a, char sm, double b) {
    switch (sm) {
        case '+':
            std::cout << a << " + " << b << " is " << a + b << '\n';
            break;
        case '-':
            std::cout << a << " - " << b << " is " << a - b << '\n';
            break;
        case '*':
            std::cout << a << " * " << b << " is " << a * b << '\n';
            break;
        case '/':
            std::cout << a << " / " << b << " is " << a / b << '\n';
            break;
        default:
            std::cout << "Something went wrong: printResult() got an invalid operator.";
            break;
    }
}


int main() {
    double a = getValue();
    char sm = getOperator();
    double b = getValue();
    printResult(a, sm, b);

    return 0;
}
```

```c++
if (std::cin.fail()) // если предыдущее извлечение не выполнилось или произошло переполнение,
{
    std::cin.clear(); // то возвращаем cin в 'обычный' режим работы
    std::cin.ignore(32767,'\n'); // и удаляем значения предыдущего ввода из входного буфера
}
```

## Урок №76. Введение в тестирование кода
**Тестирование программного обеспечения** — это процесс определения\
работоспособности программного обеспечения согласно ожиданиям разработчика.

**Правило: Часто компилируйте свой код и всегда тестируйте все нетривиальные\
функции, которые вы пишете.**

**Покрытие стейтментов** — это процент стейтментов в вашем коде, которые были
задействованы во время выполнения тестирования.

**Правило: Убедитесь, что во время тестирования задействованы все стейтменты\
вашей функции.**

Термин **"покрытие ветвлений"** относится к проценту ветвлений, которые были\
выполнены в каждом случае (положительном и отрицательном) отдельно.

**Правило: Тестируйте каждый случай ветвления в вашей программе.**

**Правило: Используйте "тест 0, 1, 2" для проверки циклов на корректную работу с\
разным количеством итераций.**

**Правило: Тестируйте разные типы ввода, чтобы убедиться, что ваш "кусок кода"\
правильно их обрабатывает.**

## Глава №5. Итоговый тест
### Теория
**Операторы `if`** позволяют выполнить код, основываясь на результате условия\
(истинно оно или нет). Если условие ложное, то выполняется **оператор `else`**. Можно\
связывать несколько операторов `if` и `else` вместе.

**Оператор `switch`** обеспечивает более удобный и быстрый способ использования\
условий/ветвлений в коде. Он отлично сочетается с перечислениями.

**Оператор `goto`** позволяет переносить точку выполнения в программе из одного\
места в другое. Использовать этот оператор не рекомендуется.

**Цикл `while`** выполняет определенный код до тех пор, пока условие истинно.
Сначала обрабатывается условие, а затем выполняется код.

**Цикл do `while`** — это тот же цикл `while`, только сначала выполняется код, а затем уже\
проверяется условие. Он отлично подходит для вывода меню или других\
элементов, так как позволяет выполнить код хотя бы один раз.

**Циклы `for`** наиболее используемые циклы. Они идеальны, когда нужно выполнить\
код определенное количество раз.

**Оператор `break`** позволяет немедленно завершить выполнение оператора switch,\
циклов `while`, `do while` или `for`.

**Оператор `continue`** позволяет немедленно перейти к следующей итерации цикла.\
Будьте осторожны при использовании этого оператора в связке с циклами `while` или\
`do while` — не забывайте о возникновении проблемы с инкрементом счетчика цикла.

И, наконец, **рандомные числа** позволяют получить разные результаты при\
выполнении одной и той же программы.

### Тест
**Задание №1.**\
В итоговом тесте главы №2 мы написали программу имитации мячика, падающего с\
башни. Так как тогда мы еще ничего не знали о циклах и не умели их использовать,\
то время полета мячика составляло всего лишь 5 секунд.\
Измените программу, приведенную ниже, таким образом, чтобы мячик падал\
ровно то количество секунд, которое необходимо ему для достижения земли.

**constants.h:**
```c++
#ifndef CONSTANTS_H
#define CONSTANTS_H
namespace myConstants {
    const double gravity(9.8);
}
#endif
```

**main.cpp:**
```c++
#include <iostream>
#include "constants.h"

// Получаем начальную высоту от пользователя и возвращаем её
double getInitialHeight() {
    std::cout << "Enter the initial height of the tower in meters: ";
    double initialHeight;
    std::cin >> initialHeight;
    return initialHeight;
}

// Возвращаем расстояние от земли после "..." секунд падения
double calculateHeight(double initialHeight, int seconds) {
    // Используем формулу: [ s = u * t + (g * t^2) / 2 ], где u (начальная скорость) = 0
    double distanceFallen = (myConstants::gravity * seconds * seconds) / 2;
    double currentHeight = initialHeight - distanceFallen;
    return currentHeight;
}

// Выводим высоту, на которой находится мячик после каждой секунды падения
void printHeight(double height, int seconds) {
    if (height > 0.0)
        std::cout << "At " << seconds << " seconds, the ball is at height: "
                  << height << " meters\n";
    else
        std::cout << "At " << seconds << " seconds, the ball is on the ground.\n";
}

int main() {
    const double initialHeight = getInitialHeight();
    int seconds = 0;
    double height;
    do {
        height = calculateHeight(initialHeight, seconds);
        printHeight(height, seconds);
        ++seconds;
    } while (height > 0.0);
    return 0;
}
```

**Задание №2.**\
Напишите программу-игру типа Hi-Lo:
* Во-первых, ваша программа должна выбрать случайное целое число в\
  диапазоне от 1 до 100.
* Пользователю дается 7 попыток, чтобы угадать это число.
* Если пользователь не угадал число, то программа должна подсказывать,\
  была ли его догадка слишком большой или слишком маленькой.
* Если пользователь угадал число, то программа должна сообщить, что всё\
  верно — вы выиграли.
* Если же у пользователя кончились попытки, и он не угадал число, то\
  программа должна сообщить ему, что он проиграл и показать правильный\
  результат.
* В конце игры программа должна спросить у пользователя, не хочет ли он\
  сыграть еще раз. Если пользователь не введет ни y, ни n (а что-то другое), то\
  программа должна спросить его еще раз.

```c++
#include <iostream>
#include <cstdlib> // для функций srand() и rand()
#include <ctime> // для функции time()

// Генерируем случайное число между min и max.
// Предполагается, что srand() уже вызывали
int getRandomNumber(int min, int max) {
    static const double fraction = 1.0 / (static_cast<double>(RAND_MAX) + 1.0);
    // Равномерно распределяем выбор случайного числа в диапазоне
    return static_cast<int>(rand() * fraction * (max - min + 1) + min);
}

// Возвращаем true, если пользователь выиграл, false - если проиграл
bool playGame(int guesses, int number) {
    // Цикл работы с догадками пользователя
    for (int count = 1; count <= guesses; ++count) {
        std::cout << "Guess #" << count << ": ";
        int guess;
        std::cin >> guess;
        if (guess > number)
            std::cout << "Your guess is too high.\n";
        else if (guess < number)
            std::cout << "Your guess is too low.\n";
        else // догадка == число
            return true;
    }
    return false;
}

bool playAgain() {
    // Продолжаем спрашивать у пользователя, хочет ли он сыграть еще раз до тех пор, пока он не нажмет 'y' или 'n'
    char ch;
    do {
        std::cout << "Would you like to play again (y/n)? ";
        std::cin >> ch;
    } while (ch != 'y' && ch != 'n');
    return (ch == 'y');
}

int main() {
    srand(static_cast<unsigned int>(time(0))); // в качестве стартового числа используем системные часы
    rand(); // сбрасываем первый результат, так как функция rand() не особо
    // хорошо рандомизирует первое случайное число в Visual Studio
    const int guesses = 7; // у пользователя есть 7 попыток
    do {
        int number = getRandomNumber(1, 100); // число, которое пользователь должен угадать
        std::cout << "Let's play a game. I'm thinking of a number. You have "
                  << guesses << " tries to guess what it is.\n";
        bool won = playGame(guesses, number);
        if (won)
            std::cout << "Correct! You win!\n";
        else
            std::cout << "Sorry, you lose. The correct number was " << number
                      << "\n";
    }
    while (playAgain());
    std::cout << "Thank you for playing.\n";
    return 0;
}
```

# Глава №6.
## Урок №77. Массивы
```c++
int testResult[30]; // выделяем 30 целочисленных переменных, используя фиксированный массив
testResult[0] = 12;
```

```c++
struct Rectangle {
    int length;
    int width;
};
Rectangle rects[4]; // объявляем массив с 4-мя прямоугольниками
rects[0] = {12, 15};
rects[0].width = 22;
```

### Индексы массивов
В языке C++ индексы массивов **всегда должны быть интегрального типа данных**\
(т.е. типа `char`, `short`, `int`, `long`, `long long`, `bool` и т.д.).

### Объявление массивов фиксированного размера
При объявлении массива фиксированного размера, его длина должна быть\
константой типа `compile-time`:
```c++
// Используем литерал
int array[7]; // хорошо

// Используем макрос-объект с текст_замена в качестве символьной константы
#define ARRAY_WIDTH 4
int array[ARRAY_WIDTH]; // синтаксически хорошо, но не делайте этого

// Используем символьную константу
const int arrayWidth = 7;
int array[arrayWidth]; // хорошо

// Используем перечислитель
enum ArrayElements {
    MIN_ARRAY_WIDTH = 3
};
int array[MIN_ARRAY_WIDTH]; // хорошо

// Используем неконстантную переменную
int width;
std::cin >> width;
int array[width]; // плохо: width должна быть константой типа compile-time!

// Используем константную переменную типа runtime
int temp = 8;
const int width = temp;
int array[width]; // плохо: здесь width является константой типа runtime, но должна быть константой типа compile-time!
```

## Урок №78. Фиксированные массивы
```c++
int array[5] = { 4, 5, 8, 9, 12 }; // используется список инициализаторов для инициализации фиксированного массива
```
Если в списке инициализаторов меньше, чем может содержать массив, то\
остальные элементы будут проинициализированы значением `0`. Если больше - ошибка.

```c++
int array[5] = { }; // Инициализируем все элементы массива значением 0

int array[5] { 4, 5, 8, 9, 12 }; // используем uniform-инициализацию для инициализации фиксированного массива
```

### Длина массива
```c++
int array[5] = { 0, 1, 2, 3, 4 }; // явно указываем длину массива
int array[] = { 0, 1, 2, 3, 4 }; // список инициализаторов автоматически определит длину массива
```

### Массивы и перечисления
```c++
const int numberOfStudents(5);
int testScores[numberOfStudents];
testScores[3] = 65;
```
Кто представлен элементом `testScores[3]`? Непонятно!

Это можно решить, используя перечисление, в котором перечислители\
сопоставляются каждому из возможных индексов массива:
```c++
#include <iostream>

enum StudentNames {
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    MAX_STUDENTS // 5
};

int main() {
    int testScores[StudentNames::MAX_STUDENTS]; // всего 5 студентов
    testScores[JOHN] = 65;

    return 0;
}
```
`MAX_STUDENTS` используется во время объявления массива для\
гарантирования того, что массив имеет корректную длину (она должна быть на\
единицу больше самого большого индекса). Это полезно как для подсчета\
элементов, так и для возможности автоматического изменения длины массива,\
если добавить еще один перечислитель:
```c++
enum StudentNames {
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    KIRILL, // 5
    MAX_STUDENTS // 6
};
```

### Массивы и классы `enum`
```c++
#include <iostream>

enum class StudentNames {
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    MAX_STUDENTS // 5
};

int main() {
    int testScores[static_cast<int>(StudentNames::MAX_STUDENTS)]; // всего 5 студентов
    testScores[static_cast<int>(StudentNames::JOHN)] = 65;

    return 0;
}
```

Стандартное перечисление внутри пространства имен:
```c++
#include <iostream>

namespace StudentNames {
    enum StudentNames {
        SMITH, // 0
        ANDREW, // 1
        IVAN, // 2
        JOHN, // 3
        ANTON, // 4
        MAX_STUDENTS // 5
    };
}

int main() {
    int testScores[static_cast<int>(StudentNames::MAX_STUDENTS)]; // всего 5 студентов
    testScores[static_cast<int>(StudentNames::JOHN)] = 65;

    return 0;
}
```

### Передача массивов в функции
**Когда обычная переменная передается по значению, то C++ копирует значение\
аргумента в параметр функции. Поскольку параметр является копией, то изменение\
значения параметра не изменяет значение исходного аргумента.**

Однако, поскольку копирование больших массивов — дело трудоёмкое, то **C++ не
копирует массив при его передаче в функцию**. Вместо этого передается фактический
массив.

**Примечание:** Если вы **не хотите**, чтобы функция изменяла значения элементов
массива, переданного в нее в качестве параметра, то нужно сделать массив
константным:
```c++
// Даже если array является фактическим массивом, внутри этой функции он должен рассматриваться как константный
void passArray(const int array[5]) {
    // Поэтому каждая из следующих строк вызовет ошибку компиляции!
    array[0] = 11;
    array[1] = 7;
    array[2] = 5;
    array[3] = 3;
    array[4] = 2;
}
```

### Оператор `sizeof` и массивы
```c++
#include <iostream>

void printSize(int array[]) {
    std::cout << sizeof(array) << '\n'; // выводится размер указателя, а не массива
}

int main() {
    int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
    std::cout << sizeof(array) << '\n'; // выводится размер массива
    printSize(array);
    
    return 0;
}

<< 32
<< 8
```

### Определение длины фиксированного массива
Чтобы определить длину фиксированного массива, поделите размер всего массива\
на размер одного элемента массива:
```c++
#include <iostream>

int main() {
    int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
    // размер массива = длина массива * размер одного элемента
    std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";
    
    return 0;
}

<< The array has 8 elements
```

**Правило: При использовании массивов убедитесь, что ваши индексы корректны и\
соответствуют диапазону вашего массива.**

### Тест
**Задание №1.**\
Объявите массив для хранения температуры (дробное число) каждого дня в году\
(всего 365 дней). Проинициализируйте массив значением 0.0 для каждого дня.
```c++
double temperature[365] = { 0.0 };
```

**Задание №2.**\
Создайте перечисление со следующими перечислителями: `chicken`, `lion`,\
`giraffe`, `elephant`, `duck` и `snake`. Поместите перечисление в пространство\
имен. Объявите массив, где элементами будут эти перечислители и, используя\
список инициализаторов, инициализируйте каждый элемент соответствующим\
количеством лап определенного животного. В функции `main()` выведите количество\
ног у слона, используя перечислитель.
```c++
#include <iostream>

namespace Animals {
    enum Animals {
        CHICKEN,
        LION,
        GIRAFFE,
        ELEPHANT,
        DUCK,
        SNAKE,
        MAX_ANIMALS
    };
}

int main() {
    int legs[Animals::MAX_ANIMALS] = { 2, 4, 4, 4, 2, 0 };
    std::cout << "An elephant has " << legs[Animals::ELEPHANT] << " legs.\n";
    return 0;
}
```

## Урок №79. Массивы и циклы
```c++
int students[] = { 73, 85, 84, 44, 78};
const int numStudents = sizeof(students) / sizeof(students[0]);
int totalScore = 0;
// Используем цикл для вычисления totalScore
for (int person = 0; person < numStudents; ++person)
    totalScore += students[person];
double averageScore = static_cast<double>(totalScore) / numStudents;

<< 72.8
```

### Тест
**Задание №1.**\
Выведите на экран следующий массив с помощью цикла:\
`int array[] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };`

```c++
#include <iostream>
int main() {
    int array[] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
    const int arrayLength = sizeof(array) / sizeof(array[0]);
    for (int index=0; index < arrayLength; ++index)
        std::cout << array[index] << " ";
    
    return 0;
}
```

**Задание №2.**\
Используя массив из задания №1:\
Попросите пользователя ввести число от 1 до 9. Если пользователь введет что-либо\
другое — попросите его снова ввести число и так до тех пор, пока он не введет\
корректное значение из заданного диапазона. Как только пользователь введет\
число от 1 до 9, выведите массив на экран. Затем найдите в массиве элемент с\
числом, которое ввел пользователь, и выведите его индекс.

```c++
#include <iostream>

int main() {
    // Сначала принимаем корректный пользовательский ввод
    int number = 0;
    do {
        std::cout << "Enter a number between 1 and 9: ";
        std::cin >> number;
        // Если пользователь ввел некорректное значение
        if (std::cin.fail())
            std::cin.clear();
        std::cin.ignore(32767, '\n');
    } while (number < 1 || number > 9);
    
    // Дальше выводим массив на экран
    int array[] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
    const int arrayLength = sizeof(array) / sizeof(array[0]);
    for (int index=0; index < arrayLength; ++index)
        std::cout << array[index] << " ";
    std::cout << "\n";
    
    // Затем ищем в массиве число, которое ввел пользователь и выводим его индекс
    for (int index=0; index < arrayLength; ++index) {
        if (array[index] == number) {
            std::cout << "The number " << number << " has index " << index << "\n";
            break; // так как каждый элемент в массиве уникальный, то нет надобности продолжать перебирать элементы дальше
        }
    }
    return 0;
}
```

**Задание №3.**\
Измените следующую программу так, чтобы вместо `maxScore` с наибольшим\
значением, переменная `maxIndex` содержала индекс элемента с наибольшим\
значением:
```c++
#include <iostream>
int main() {
    int scores[] = { 73, 85, 84, 44, 78 };
    const int numStudents = sizeof(scores) / sizeof(scores[0]);
    int maxIndex = 0; // отслеживаем самую высокую оценку  (maxScore = 0;)
    for (int student = 0; student < numStudents; ++student)
        if (scores[student] > scores[maxIndex])
            maxIndex = student;  // (maxScore = scores[student];)
    std::cout << "The best score: " << scores[maxIndex] << '\n';
    std::cout << "Index of the best score: " << maxIndex << '\n';
    return 0;
}
```

## Урок №80. Сортировка массивов методом выбора
