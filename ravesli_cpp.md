## Урок №44. Условный тернарный оператор, оператор sizeof и Запятая

```c++
z = (a, b); // сначала вычисляется выражение (a, b), которое равняется значению b, а затем результат присваивается переменной z
z = a, b; // вычисляется как "(z = a), b", поэтому переменной z присваивается значение a, переменная b - игнорируется
```

Условный (тернарный) оператор (обозначается как `?:`) является единственным тернарным\
оператором в языке С++, который работает с 3-мя операндами.

```c++
    c ? x : y  // Если c — ненулевое значение (true), то вычисляется x, в противном случае — y
```

Оператор ?: предоставляет сокращенный способ (альтернативу) ветвления if/else.\
Стейтменты if/else:

```c++
if (условие)
    выражение;
else
    другое_выражение;
```

Можно записать как:

```c++
(условие) ? выражение : другое_выражение;
```

Еще примеры:

```c++
// Привычный способ
if (x > y)
larger = x;
else
larger = y;

// Через тернарный оператор
larger = (x > y) ? x : y;
```

Помните, что оператор ?: имеет очень низкий приоритет, из-за этого его следует
записывать в круглых скобках.

```c++
int x = 0, y = 2;
std::cout << ((x > y) ? x : y);  // 2
std::cout << (x > y) ? x : y;  // 0
```

## Урок №45. Операторы сравнения

```c++
#include <iostream>

int main() {
    double d1(100 - 99.99); // должно быть 0.01, но = 0.0100000000000005116
    double d2(10 - 9.99); // должно быть 0.01, но = 0.0099999999999997868
    
    if (d1 == d2)
        std::cout << "d1 == d2" << "\n";
    else if (d1 > d2)
        std::cout << "d1 > d2" << "\n";
    else if (d1 < d2)
        std::cout << "d1 < d2" << "\n";
    return 0;
    
    >> d1 > d2
}
```

Не рекомендуется использовать операторы == или != с числами типа с плавающей точкой.\
Вместо них следует использовать функцию, которая вычисляет, насколько эквивалентны эти два
значения.

```c++
#include <cmath> // для функции fabs()

// Возвращаем true, если разница между a и b в пределах процента эпсилона
// epsilon вводится в процентах
bool approximatelyEqual(double a, double b, double epsilon) {
    return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
```

Но и функция approximatelyEqual() тоже не идеальна, особенно, когда дело доходит
до чисел, близких к нулю

```c++
// Значение a очень близко к 1.0, но, из-за ошибок округления, чуть меньше 1.0
double a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
// давайте сравним значение a - 1.0 (почти 0.0) с 0.0
std::cout << approximatelyEqual(a - 1.0, 0.0, 1e-8)

>> 0  // Математика просто ломается, когда дело доходит до нулей
```

Но и этого можно избежать, используя как абсолютный эпсилон (то, что мы делали\
в первом способе), так и относительный (способ Кнута) вместе:

```c++
// Возвращаем true, если разница между a и b меньше absEpsilon или в пределах relEpsilon
bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon) {
// Проверяем числа на равенство их друг другу - это нужно в тех случаях, 
// когда сравниваемые числа являются нулевыми или "около нуля"
double diff = fabs(a - b);
if (diff <= absEpsilon)
return true;
// В противном случае, возвращаемся к алгоритму Кнута
return diff <= ((fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * relEpsilon);
}
```

Тогда:

```c++
double a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
std::cout << approximatelyEqual(a, 1.0, 1e-8);  // сравниваем "почти 1.0" с 1.0
std::cout << approximatelyEqual(a - 1.0, 0.0, 1e-8) << "\n"; // сравниваем "почти 0.0" с 0.0
std::cout << approximatelyEqualAbsRel(a - 1.0, 0.0, 1e-12, 1e-8) << "\n"; // сравниваем "почти 0.0" с 0.0

>> 1
>> 0
>> 1
```

## Урок №46. Логические операторы: И, ИЛИ, НЕ

### Логический оператор НЕ

```c++
if (!(x == y))
    std::cout << "x != y";
```

Любое ненулевое целое значение в логическом контексте является
true. Так как `х = 5`, то `х` вычисляется как `true`, а вот `!x = false`, т.е. `0`.

### Логический оператор ИЛИ

```c++
if (value == 0 || value == 1 || value == 2 || value == 3)
    std::cout << "You picked 0, 1, 2, or 3" << std::endl;
```

### Логический оператор И

```c++
if (value > 10 && value < 20)
    std::cout << "Your value is between 10 and 20" << std::endl;
```

### Использование логических операторов И/ИЛИ

**Приоритет логического И выше приоритета ИЛИ**

Рассмотрим следующее выражение: `value1 || value2 && value3`. Поскольку
приоритет логического И выше, то обрабатываться выражение будет так:\
`value1 || (value2 && value3)`\
А не так:\
`(value1 || value2) && value3`

**Законы Де Моргана** гласят, что `!(x && y)` эквивалентно `!x || !y`,
`а !(x || y)` эквивалентно `!x && !y`.

## Урок №48. Побитовые операторы

### Побитовый сдвиг влево (<<) и побитовый сдвиг вправо (>>)

```
// сдвиг влева
3 = 0011
3 << 1 = 0110 = 6
3 << 2 = 1100 = 12
3 << 3 = 1000 = 8

// сдвиг вправо
12 = 1100
12 >> 1 = 0110 = 6
12 >> 2 = 0011 = 3
12 >> 3 = 0001 = 1
```

```c++
int main() {
    unsigned int x = 4;
    x = x << 1;  // оператор << используется для побитового сдвига влево
    std::cout << x; // оператор << используется для вывода данных в консоль
    return 0;
}

>> 8
```

### Побитовый оператор НЕ

Результаты побитового НЕ зависят от размера типа данных.

```
// размер типа данных составляет 4 бита
4 = 0100
~ 4 = 1011 (двоичное) = 11 (десятичное)

// размер типа данных составляет 8 бит
4 = 0000 0100
~ 4 = 1111 1011 (двоичное) = 251 (десятичное)
```

### Побитовые операторы И, ИЛИ и исключающее ИЛИ (XOR)

Если хоть один бит в столбце равен 1, то результат целого столбца — 1

```
// 2 числа
0 1 0 1 // 5
0 1 1 0 // 6
-------
0 1 1 1 // 7

// 3 числа
0 0 0 1 // 1
0 1 0 0 // 4
0 1 1 0 // 6
--------
0 1 1 1 // 7
```

Побитовое И работает аналогично логическому И — возвращается true, только если
оба бита в столбце равны 1

```
0 1 0 1 // 5
0 1 1 0 // 6
--------
0 1 0 0 // 4

0 0 0 1 // 1
0 0 1 1 // 3
0 1 1 1 // 7
--------
0 0 0 1 // 1
```

При обработке двух операндов, исключающее ИЛИ возвращает true (1),\
только если один и только один из операндов является истинным (1).\
Если таких нет или все операнды равны 1, то результатом будет false (0).

```
0 1 1 0 // 6
0 0 1 1 // 3
-------
0 1 0 1 // 5
```

Если единиц в столбце чётное количество, то результатом будет 0, если же нечётное\
количество, то результат — 1.

```
0 0 0 1 // 1
0 0 1 1 // 3
0 1 1 1 // 7
--------
0 1 0 1 // 5
```

### Побитовые операторы присваивания

Вместо `х = х << 1;` мы можем написать `х <<= 1;`

## Урок №49. Битовые флаги и битовые маски

```c++
// Определяем 8 отдельных битовых флагов (они могут представлять всё, что вы захотите).
// Обратите внимание, в C++11 лучше использовать "uint8_t" вместо "unsigned char"
const unsigned char option1 = 0x01; // шестнадцатеричный литерал для 0000 0001
const unsigned char option2 = 0x02; // шестнадцатеричный литерал для 0000 0010
const unsigned char option3 = 0x04; // шестнадцатеричный литерал для 0000 0100
const unsigned char option4 = 0x08; // шестнадцатеричный литерал для 0000 1000
const unsigned char option5 = 0x10; // шестнадцатеричный литерал для 0001 0000
const unsigned char option6 = 0x20; // шестнадцатеричный литерал для 0010 0000
const unsigned char option7 = 0x40; // шестнадцатеричный литерал для 0100 0000
const unsigned char option8 = 0x80; // шестнадцатеричный литерал для 1000 0000

// Байтовое значения для хранения комбинаций из 8 возможных вариантов
unsigned char myflags = 0; // все флаги/параметры отключены до старта
```

Чтобы узнать битовое состояние, используется побитовое И:

```c++
if (myflags & option4) ... // если option4 установлено - что-нибудь делаем
```

Чтобы включить биты, используется побитовое ИЛИ:

```c++
myflags |= option4; // включаем option4
myflags |= (option4 | option5); // включаем option4 и option5
```

Чтобы выключить биты, используется побитовое И с инвертированным литералом:

```c++
myflags &= ~option4; // выключаем option4
myflags &= ~(option4 | option5); // выключаем option4 и option5
```

Для переключения между состояниями бит, используется побитовое исключающее ИЛИ (XOR):

```c++
myflags ^= option4; // включаем или выключаем option4
myflags ^= (option4 | option5); // изменяем состояния option4 и option5
```

### Битовые флаги полезны, если:

#### Если у вас много идентичных битовых флагов

Вместо одной переменной `myflags`, рассмотрим случай, когда у вас есть две\
переменные: `myflags1` и `myflags2`, каждая из которых может хранить 8\
значений. Если вы определите их как два отдельных логических набора, то вам\
потребуется 16 логических значений и, таким образом, 16 байт. Однако с\
использованием битовых флагов вам потребуется только 10 байт (8 для\
определения параметров и 1 для каждой переменной `myflags`). А вот если у вас\
будет 100 переменных `myflags`, то, используя битовые флаги, вам потребуется 108\
байт вместо 800. Чем больше идентичных переменных вам нужно, тем более\
значительной будет экономия памяти.

#### Если есть функция, которая на вход принимает большое количество данных

Представьте, что у вас есть функция, которая может принимать любую\
комбинацию из 32 различных вариантов. Одним из способов написания такой\
функции является использование 32 отдельных логических параметров:
```c++
void someFunction(bool option1, bool option2, bool option3, bool option4,
bool option5, bool option6, bool option7, bool option8, bool option9, bool
option10, bool option11, bool option12, bool option13, bool option14, bool
option15, bool option16, bool option17, bool option18, bool option19, bool
option20, bool option21, bool option22, bool option23, bool option24, bool
option25, bool option26, bool option27, bool option28, bool option29, bool
option30, bool option31, bool option32);

someFunction(false, false, false, false, false, false, false, false, false,
true, false, false, false, false, false, false, false, false, false, false,
false, false, false, false, false, false, false, false, false, false, false,
true);
```

А вот если определить функцию с помощью битовых флагов:

```c++
void someFunction(unsigned int options);
```

То можно выбирать и передавать только нужные параметры:

```c++
someFunction(option10 | option32);
```

Кроме того, что это читабельнее, это также эффективнее и производительнее, так\
как включает только 2 операции (1 побитовое ИЛИ и 1 передача параметров)

### Введение в std::bitset

Для его использования необходимо подключить заголовочный файл bitset, а затем\
определить переменную типа std::bitset, указав необходимое количество бит. Она\
должна быть константой типа compile time.

```c++
#include <bitset>

std::bitset<8> bits; // нам нужно 8 бит
```

При желании std::bitset можно инициализировать начальным набором значений:

```c++
#include <bitset>

std::bitset<8> bits(option1 | option2) ; // начнем с включенных option1 и option2
std::bitset<8> morebits(0x2) ; // начнем с битового шаблона 0000 0010
```

В `std::bitset` есть 4 основные функции:

- функция `test()` — позволяет узнать значение бита (0 или 1).
- функция `set()` — позволяет включить биты (если они уже включены, то ничего не произойдет).
- функция `reset()` — позволяет выключить биты (если они уже выключены, то ничего не произойдет).
- функция `flip()` — позволяет изменить значения бит на противоположные (с 0 на 1 или с 1 на 0).

Пример использования:

```c++
#include <iostream>
#include <bitset>

// Обратите внимание, используя std::bitset, наши options соответствуют порядковым номерам бит, а не их значениям
const int option_1 = 0;
const int option_2 = 1;
const int option_3 = 2;
const int option_4 = 3;
const int option_5 = 4;
const int option_6 = 5;
const int option_7 = 6;
const int option_8 = 7;

int main() {
    // Помните, что отсчет бит начинается не с 1, а с 0
    std::bitset<8> bits(0x2); // нам нужно 8 бит, начнем с битового шаблона 0000 0010
    bits.set(option_5); // включаем 4-й бит - его значение изменится на 1 (теперь мы имеем 0001 0010)
    bits.flip(option_6); // изменяем значения 5-го бита на противоположное (теперь мы имеем 0011 0010)
    bits.reset(option_6); // выключаем 5-й бит - его значение снова 0 (теперь мы имеем 0001 0010)
    
    std::cout << "Bit 4 has value: " << bits.test(option_5) << '\n';
    std::cout << "Bit 5 has value: " << bits.test(option_6) << '\n';
    std::cout << "All the bits: " << bits << '\n';
    
    return 0;
}

>> Bit 4 has value: 1
>> Bit 5 has value: 0
>> All the bits: 00010010
```

### Битовые маски

Когда мы соединяем отдельные биты вместе, в целях их модификации как группы,\
то это называется битовой маской.

```c++
#include <iostream>

int main() {
    const unsigned int lowMask = 0xF; // битовая маска для хранения последних4 бит (шестнадцатеричный литерал для 0000 0000 0000 1111)
    
    std::cout << "Enter an integer: ";
    int num;
    std::cin >> num;
    
    num &= lowMask; // удаляем первые биты, оставляя последние 4
    
    std::cout << "The 4 low bits have value: " << num << '\n';
    
    return 0;
}

>> Enter an integer: 151
<< The 4 low bits have value: 7
```

`151` в десятичной системе равно `1001 0111` в двоичной. `lowMask` — это `0000
1111` в 8-битной двоичной системе. `1001 0111 & 0000 1111 = 0000 0111`,
что равно десятичному `7`.

### Пример с RGBA

Следующая программа просит пользователя ввести 32-битное шестнадцатеричное\
значение, а затем извлекает 8-битные цветовые значения R, G, B и A:

```c++
#include <iostream>

int main() {
    const unsigned int redBits = 0xFF000000;
    const unsigned int greenBits = 0x00FF0000;
    const unsigned int blueBits = 0x0000FF00;
    const unsigned int alphaBits = 0x000000FF;
    
    std::cout << "Enter a 32-
    bit RGBA color value in hexadecimal (e.g. FF7F3300): ";
    unsigned int pixel;
    std::cin >> std::hex >> pixel; // std::hex позволяет вводить шестнадцатеричные значения
    
    // Используем побитовое И для изоляции красных пикселей, а затем сдвигаем значение вправо в диапазон 0-255
    unsigned char red = (pixel & redBits) >> 24;
    unsigned char green = (pixel & greenBits) >> 16;
    unsigned char blue = (pixel & blueBits) >> 8;
    unsigned char alpha = pixel & alphaBits;
    
    std::cout << "Your color contains:\n";
    std::cout << static_cast<int>(red) << " of 255 red\n";
    std::cout << static_cast<int>(green) << " of 255 green\n";
    std::cout << static_cast<int>(blue) << " of 255 blue\n";
    std::cout << static_cast<int>(alpha) << " of 255 alpha\n";
    
    return 0;
}
```

Результат выполнения программы:

```c++
<< Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300):
>> FF7F3300
<< Your color contains:
<< 255 of 255 red
<< 127 of 255 green
<< 51 of 255 blue
<< 0 of 255 alpha
```

### Тест

Есть следующий фрагмент кода:

```c++
int main() {
    unsigned char option_viewed = 0x01;
    unsigned char option_edited = 0x02;
    unsigned char option_favorited = 0x04;
    unsigned char option_shared = 0x08;
    unsigned char option_deleted = 0x80;
    
    unsigned char myArticleFlags;
    
    return 0;
}
```

№1. Добавьте строку кода, чтобы пометить статью как уже прочитанную (option_viewed).\
`myArticleFlags |= option_viewed;`

№2. Добавьте строку кода, чтобы проверить, была ли статья удалена (option_deleted).\
`if (myArticleFlags & option_deleted) …`

№3. Добавьте строку кода, чтобы открепить статью от закрепленного места (option_favorited).\
`myArticleFlags &= ~option_favorited;`

№4. Почему следующие две строки идентичны?

```c++
myflags &= ~(option4 | option5); // выключаем option4 и option5
myflags &= ~option4 & ~option5; // выключаем option4 и option5
```

Закон Де Моргана.

# Глава 4

## Урок №50. Блоки стейтментов (составные операторы)

**Блоки стейтментов** (или **"составные операторы"**) — это группа стейтментов,\
которые обрабатываются компилятором как одна инструкция. Блок начинается с\
символа `{` и заканчивается символом `}`, стейтменты находятся внутри. Блоки могут\
использоваться в любом месте, где разрешено использовать один стейтмент. В\
конце составного оператора точка с запятой не ставится.

### Вложенные блоки

При использовании вложенных блоков, блок, который содержит внутри себя другой\
блок, называется **внешним блоком**, а тот, который содержится внутри этого блока\
— **внутренний/вложенный блок**.

```c++
int add(int x, int y) { // начало блока
    return x + y;
} // конец блока

int main() { // начало внешнего блока
    // Несколько стейтментов
    int value {};
    
    { // начало внутреннего/вложенного блока
    add(3, 4);
    } // конец внутреннего/вложенного блока
    
    return 0;
} // конец внешнего блока
```

### Количество уровней вложенности блоков

**Уровень вложенности функции** (или **"глубина вложенности функции"**) — это\
максимальное количество блоков, которые могут находиться в любой точке\
функции (включая внешний блок). В вышеприведенной функции есть 4 блока, но\
уровень вложенности равен 3.

```c++
#include <iostream>

int main() { // 1-й уровень вложенности блоков
    std::cout << "Enter an integer: ";
    int value {};
    std::cin >> value;
    
    if (value > 0) { // 2-й уровень вложенности блоков
        if ((value % 2) == 0) { // 3-й уровень вложенности блоков
                std::cout << value << " is positive and even\n";
            }
            else
            { // также 3-й уровень вложенности блоков
                std::cout << value << " is positive and odd\n";
            }
    }
    
    return 0;
}
```

## Урок №51. Локальные переменные, область видимости и продолжительность жизни

**Область видимости** определяет, где можно использовать переменную. **Продолжительность жизни**\
(или **"время жизни"**) определяет, где переменная создается и где уничтожается.

Переменные, определенные внутри блока, называются **локальными\
переменными**. Локальные переменные имеют **автоматическую\
продолжительность жизни**: они создаются (и инициализируются, если\
необходимо) в точке определения и уничтожаются при выходе из блока. Локальные\
переменные имеют **локальную область видимости** (или **"блочную"**), т.е. они входят\
в область видимости с точки объявления и выходят в самом конце блока, в котором\
определены.

```c++
#include <iostream>

int main() { // начало внешнего блока
    int x(5);
    
    { // начало вложенного блока
        int y(7);
        // Мы можем использовать x и y здесь
        std::cout << x << " + " << y << " = " << x + y;
    } // переменная y уничтожается здесь
    
    // Переменную y здесь нельзя использовать, поскольку она уже уничтожена!
    
    return 0;
} // переменная x уничтожается здесь
```

### Сокрытие имен
Переменная внутри вложенного блока может иметь то же имя, что и переменная\
внутри внешнего блока. Когда подобное случается, то переменная во вложенном\
(внутреннем) блоке «скрывает» внешнюю переменную. Это называется **сокрытием имен**:

```c++
#include <iostream>

int main() { // внешний блок
    int oranges(5); // внешняя переменная oranges

    if (oranges >= 5) // относится к внешней oranges
    { // вложенный блок
        int oranges; // скрывается внешняя переменная oranges
        // Идентификатор oranges теперь относится к вложенной переменной oranges.
        // Внешняя переменная oranges временно скрыта
        oranges = 10; // здесь мы присваиваем значение 10 вложенной переменной oranges, не внешней!

        std::cout << oranges << std::endl; // выводим значение вложенной переменной oranges
    } // вложенная переменная oranges уничтожается

    // Идентификатор oranges опять относится к внешней переменной oranges

    std::cout << oranges << std::endl; // выводим значение внешней переменной oranges

    return 0;
}  // внешняя переменная oranges уничтожается

<< 10
<< 5
```

**Правило: Избегайте использования вложенных переменных с именами,
идентичными именам внешних переменных.**

### Область видимости переменных
**Правило: Определяйте переменные в наиболее ограниченной области видимости.**
```c++
#include <iostream>

int main() {
    // Не определяйте x здесь
    {
        // Переменная x используется только внутри этого блока, поэтому определяем её здесь
        int x(7);
        std::cout << x;
    }
    // В противном случае, переменная x может быть использована и здесь
    
    return 0;
}
```

### Кириллица
`setlocale(LC_ALL, "rus");`

### Резюме
Область видимости определяет, где переменная доступна для использования.\
Продолжительность жизни переменной определяет, когда переменная\
создается и когда уничтожается.

Локальные переменные имеют локальную (блочную) область видимости, доступ\
к ним осуществляется только внутри блока, в котором они определены.

Локальные переменные имеют автоматическую продолжительность жизни, что\
означает, что они создаются в точке определения и уничтожаются в конце блока,\
в котором определены.

## Урок №52. Глобальные переменные
**Глобальными** называются переменные, которые объявлены вне блока. Они имеют\
**статическую продолжительность жизни**, т.е. создаются при запуске программы и\
уничтожаются при её завершении. Глобальные переменные имеют **глобальную\
область видимости** (или **"файловую область видимости"**), т.е. их можно\
использовать в любом месте файла, после их объявления.

### Определение глобальных переменных
С помощью оператора разрешения области видимости (`::`), компилятору\
можно сообщить, какую версию переменной вы хотите использовать: глобальную\
или локальную.
```c++
#include <iostream>

int value(4); // глобальная переменная

int main() {
    int value = 8; // эта переменная (локальная) скрывает значение глобальной переменной
    value++; // увеличивается локальная переменная value (не глобальная)
    ::value--; // уменьшается глобальная переменная value (не локальная)
    
    std::cout << "Global value: " << ::value << "\n";
    std::cout << "Local value: " << value << "\n";
    
    return 0;
} // локальная переменная уничтожается

<< Global value: 3
<< Local value: 9
```

Использовать одинаковые имена для локальных и глобальных переменных — это\
прямой путь к проблемам и ошибкам, поэтому подобное делать не рекомендуется.\
Многие разработчики добавляют к глобальным переменным префикс `g_`.

### Ключевые слова static и extern
Связь переменной определяет, относятся ли несколько упоминаний одного\
идентификатора к одной и той же переменной или нет.

Переменная без связей — это переменная с локальной областью видимости,\
которая относится только к блоку, в котором она определена.

Переменная, имеющая внутренние связи, называется **внутренней переменной** (или\
**"статической переменной"**). Она может использоваться в любом месте файла, в\
котором определена, но не относится к чему-либо вне этого файла.

Переменная, имеющая внешние связи, называется **внешней переменной**. Она\
может использоваться как в файле, в котором определена, так и в других файлах.

**Ключевое слово `static` нужно**, чтобы сделать глобальную переменную внутренней\
(которую можно использовать только внутри одного файла):
```c++
#include <iostream>

// g_x - это статическая глобальная переменная, 
// которую можно использовать только внутри этого файла
static int g_x; 

int main() {
    return 0;
}
```

**Ключевое слово `extern` нужно**, чтобы сделать глобальную переменную внешней\
(которую можно использовать в любом файле программы):
```c++
#include <iostream>

// g_y - это внешняя глобальная переменная и её можно
// использовать и в других файлах программы
extern double g_y(9.8);

int main() {
    return 0;
}
```
По умолчанию, неконстантные переменные, объявленные вне блока, считаются\
внешними. Однако константные переменные, объявленные вне блока, считаются\
внутренними.

### Предварительные объявления переменных с использованием extern
Чтобы использовать внешнюю глобальную переменную, которая была\
объявлена в другом файле, нужно записать предварительное объявление\
переменной с использованием ключевого слова extern (без инициализируемого значения):

**global.cpp:**
```c++
// Определяем две глобальные переменные
int g_m; // неконстантные глобальные переменные имеют внешнюю связь по умолчанию

int g_n(3); // неконстантные глобальные переменные имеют внешнюю связь по умолчанию
// g_m и g_n можно использовать в любом месте этого файла
```
**main.cpp:**
```c++
#include <iostream>

extern int g_m; // предварительное объявление g_m. Теперь g_m можно использовать в любом месте этого файла

int main() {
    extern int g_n; // предварительное объявление g_n. Теперь g_n можно использовать только внутри main()
    
    g_m = 4;
    std::cout << g_n;3
    
    return 0;
}

<< 3
```
Если предварительное объявление находится вне блока, то оно применяется ко всему файлу.\
Если же внутри блока, то оно применяется только к нему.

Если переменная объявлена с помощью ключевого слова static, то получить доступ к\
ней с помощью предварительного объявления не получится:

**constants.cpp:**
```c++
static const double g_gravity(9.8);
```

**main.cpp:**
```c++
#include <iostream>

// не найдет g_gravity в constants.cpp, так как g_gravity является внутренней переменной
extern const double g_gravity; 

int main() {
    // вызовет ошибку компиляции, так как переменная g_gravity не была определена для использования в main.cpp
    std:: cout << g_gravity; 
    
    return 0;
}
```

### Связи функций
Функции имеют такие же свойства связи, что и переменные. По умолчанию они\
имеют внешнюю связь, которую можно сменить на внутреннюю с помощью\
ключевого слова `static`:
```c++
// Эта функция определена как static и может быть использована только внутри этого файла.
// Попытки доступа к ней через прототип функции будут безуспешными
static int add(int a, int b) {
    return a + b;
}
```
Предварительные объявления функций не нуждаются в ключевом слове extern.

### Глобальные символьные константы
**constants.cpp:**
```c++
namespace Constants {
    // Фактические глобальные переменные
    extern const double pi(3.14159);
    extern const double avogadro(6.0221413e23);
    extern const double my_gravity(9.2);
}
```

**constants.h:**
```c++
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace Constants {
// Только предварительные объявления
extern const double pi;
extern const double avogadro;
extern const double my_gravity;
}

#endif
```

**Их использование в коде остается неизменным:**
```c++
#include "constants.h"

//...
double circumference = 2 * radius * Constants::pi;
//...
```
Теперь определение символьных констант выполняется только один раз (в\
constants.cpp). Любые изменения, сделанные в constants.cpp, потребуют\
перекомпиляции только (одного) этого файла.

Но есть и обратная сторона медали: такие константы больше не будут считаться\
константами типа `compile-time` и, поэтому, не смогут использоваться где-либо, где\
потребуется константа такого типа.

Поскольку глобальные символьные константы должны находиться в отдельном\
пространстве имен и быть доступными только для чтения, то использовать префикс\
`g_` уже не обязательно.

### Резюме

- Глобальные переменные имеют глобальную область видимости и могут\
  использоваться в любом месте программы. Подобно функциям, вы должны\
  использовать предварительные объявления (с ключевым словом extern),\
  чтобы использовать глобальную переменную, определенную в другом файле.
- По умолчанию, глобальные неконстантные переменные имеют внешнюю\
  связь. Вы можете использовать ключевое слово static, чтобы сделать их\
  внутренними.
- По умолчанию, глобальные константные переменные имеют внутреннюю\
  связь. Вы можете использовать ключевое слово extern, чтобы сделать их\
  внешними.
- Используйте префикс `g_` для идентификации ваших неконстантных\
  глобальных переменных.

### Тест
В чём разница между областью видимости, продолжительностью жизни и связью\
переменных? Какие типы продолжительности жизни, области видимости и связи\
имеют глобальные переменные?

- Область видимости определяет, где переменная доступна для\
  использования. Продолжительность жизни определяет, где переменная\
  создается и где уничтожается. Связь определяет, может ли переменная\
  использоваться в другом файле или нет.
- Глобальные переменные имеют глобальную область видимости (или\
  «файловую область видимости»), что означает, что они доступны из точки\
  объявления до конца файла, в котором объявлены.
- Глобальные переменные имеют статическую продолжительность жизни,\
  что означает, что они создаются при запуске программы и уничтожаются\
  при её завершении.
- Глобальные переменные могут иметь либо внутреннюю, либо внешнюю\
  связь (это можно изменить через использование ключевых слов static и\
  extern, соответственно).

## Урок №53. Почему глобальные переменные – зло?
### Почему (неконстантные) глобальные переменные — это зло?
Их значения могут изменять любые вызываемые функции, при этом вы можете этого и не знать:
```c++
#include <iostream>

// Объявление глобальной переменной
int g_mode;

void doSomething() {
    g_mode = 2; // присваиваем глобальной переменной g_mode значение 2
}

int main() {
    // Примечание: Здесь мы присваиваем глобальной переменной
    // g_mode значение 1. Это не объявление локальной переменной g_mode!
    g_mode = 1; 
    
    doSomething();
    
    // Программист по-прежнему ожидает, что g_mode будет 1.
    // Но функция doSomething() изменила значение этой переменной на 2!
    
    if (g_mode == 1)
        std::cout << "No threat detected.\n";
    else
        std::cout << "Launching nuclear missiles...\n";
    
    return 0;
}

<< Launching nuclear missiles...
```
**Правило: Вместо глобальных переменных используйте локальные (когда это целесообразно).**

### Резюме
Избегайте использования неконстантных глобальных переменных, насколько это\
возможно! Если же используете, то используйте их максимально разумно и\
осторожно.

## Урок №54. Статические переменные
Использование **ключевого слова** `static` с локальными переменными изменяет их\
свойство продолжительности жизни с автоматического на статическое (или\
"фиксированное"). **Статическая переменная** (или **«переменная со статической\
продолжительностью жизни»**) сохраняет свое значение даже после выхода из\
блока, в котором она определена. То есть она создается (и инициализируется)\
только один раз, а затем сохраняется на протяжении выполнения всей программы.
```c++
#include <iostream>

void incrementAndPrint() {
    static int s_value = 1; // переменная s_value является статической
    ++s_value;
    std::cout << s_value << std::endl;
} // переменная s_value не уничтожается здесь, но становится недоступной

int main() {
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();
    
    return 0;
}

<< 2
<< 3
<< 4
```
Поскольку переменная `s_value` объявлена статической (с помощью ключевого\
слова `static`), то она создается и инициализируется только один раз. Кроме того,\
выходя из области видимости, она не уничтожается. Каждый раз, при вызове\
функции `incrementAndPrint()`, значение `s_value` увеличивается.

Так же, как мы используем префикс `g_` с глобальными переменными, префикс `s_`\
принято использовать со статическими переменными. Обратите внимание,\
внутренние глобальные переменные (которые объявлены с использованием static)\
остаются с префиксом `g_`, а не с префиксом `s_`.

```c++
// присвоение каждому объекту отдельный уникальный идентификационный номер
int generateID() {
  static int s_itemID = 0;
  return s_itemID++;
}
```
`s_itemID` — это локальная переменная, то она не может быть «изменена» другими функциями

**Статические переменные** имеют некоторые преимущества глобальных переменных\
(они не уничтожаются до завершения программы), сохраняя при этом локальную\
область видимости. Таким образом, они намного безопаснее для использования,\
нежели глобальные переменные.

### Тест
Какой эффект от добавления ключевого слова static к глобальной переменной?\
Какое влияние оно имеет на локальную переменную?

Добавляя ключевое слово static к глобальной переменной, мы определяем её\
как внутреннюю, то есть такую, которую нельзя экспортировать и использовать в\
других файлах.\
В случае с локальной переменной, добавление static определяет её как\
статическую, то есть она создается и инициализируется только один раз, и не\
уничтожается до самого конца программы.

## Урок №55. Связи, область видимости и продолжительность жизни
### Область видимости
**Область видимости** идентификатора определяет, где он доступен для\
использования. К идентификатору, который находится вне области видимости,\
доступ закрыт.
- Переменные с **локальной/блочной областью видимости** доступны только в
  пределах блока, в котором они объявлены. Это:
  - локальные переменные;
  - параметры функции.
- Переменные с **глобальной/файловой областью видимости** доступны в
  любом месте файла. Это:
  - глобальные переменные.

### Продолжительность жизни
**Продолжительность жизни** переменной определяет, где она создается и где
уничтожается.
- Переменные с **автоматической продолжительностью жизни** создаются в\
  точке определения и уничтожаются при выходе из блока, в котором
  определены. Это:
  - обычные локальные переменные.
- Переменные **со статической продолжительностью жизни** создаются, когда\
  программа запускается, и уничтожаются при её завершении. Это:
  - глобальные переменные;
  - статические локальные переменные.
- Переменные с **динамической продолжительностью жизни** создаются и\
  уничтожаются по запросу программиста. Это:
  - динамические переменные (о них мы поговорим на соответствующем уроке).

### Связи
**Связь** идентификатора определяет, относятся ли несколько упоминаний одного\
идентификатора к одному и тому же идентификатору или нет.

- Идентификаторы **без связей** — это идентификаторы, которые ссылаются сами\
  на себя. Это:
  - обычные локальные переменные;
  - пользовательские типы данных, такие как enum, typedef и классы,\
    объявленные внутри блока (об этом детально поговорим на\
    соответствующих уроках).

- Идентификаторы с **внутренней связью** доступны в любом месте файла, в\
  котором они объявлены. Это:
  - статические глобальные переменные (инициализированные или неинициализированные);
  - константные глобальные переменные;
  - статические функции (о них поговорим чуть позже).

- Идентификаторы с **внешней связью** доступны как в любом месте файла, в\
  котором они объявлены, так и в других файлах (через предварительное\
  объявление). Это:
  - обычные функции;
  - неконстантные глобальные переменные (инициализированные или неинициализированные);
  - внешние константные глобальные переменные;
  - определяемые пользователем типы данных, такие как enum, typedef и\
    классы с глобальной областью видимости (о них мы поговорим чуть позже).

Идентификаторы с внешней связью могут вызвать ошибку дублирования\
определений, если определения скомпилированы в более чем одном файле .cpp.

Функции по умолчанию имеют внешнюю связь, что можно изменить с помощью\
ключевого слова static (на внутреннюю связь).

## Урок №56. Пространства имен
**Конфликт имен** возникает, когда два одинаковых идентификатора находятся в
одной области видимости, и компилятор не может понять, какой из этих двух
следует использовать в конкретной ситуации.

### Что такое пространство имен?
**Пространство имен** определяет область кода, в которой гарантируется
уникальность всех идентификаторов. По умолчанию, глобальные переменные и
обычные функции определены в **глобальном пространстве** имен.

Собственные пространства имен через **ключевое слово `namespace`**. 
Всё, что объявлено внутри пользовательского пространства имен, — 
принадлежит только этому пространству имен (а не глобальному).

**boo.h:**
```c++
namespace Boo {
    // Эта версия doOperation() принадлежит пространству имен Boo
  int doOperation(int a, int b) {
    return a + b;
  }   
}
```
**xoo.h:**
```c++
namespace Doo {
    // Эта версия doOperation() принадлежит пространству имен Doo
  int doOperation(int a, int b) {
    return a - b;
  }   
}
```
**main.cpp:**
```c++
#include <iostream>
#include "boo.h"
#include "doo.h"

int main() {
    std::cout << doOperation(5, 4);
    return 0;
}

<< error C2065: 'doOperation' : undeclared identifier
```
Существует два разных способа сообщить компилятору, какую версию `doOperation()`\
следует использовать: через оператор разрешения области видимости или с\
помощью using-стейтментов (следующий урок).

### Доступ к пространству имен через оператор разрешения области видимости (`::`)
Сообщим компилятору использовать версию `doOperation()` из пространства имен `Boo`:
```c++
#include <iostream>
#include "boo.h"
#include "doo.h"

int main(void) {
  std::cout << Boo::doOperation(5, 4);
  std::cout << Doo::doOperation(5, 4);
  return 0;
}

<< 9
<< 1
```
Также этот оператор можно использовать без какого-либо префикса (например,\
`::doOperation`). В таком случае мы ссылаемся на глобальное пространство имен.

### Пространства имен с одинаковыми названиями
Допускается объявление пространств имен в нескольких местах (либо в нескольких\
файлах, либо в нескольких местах внутри одного файла). Всё, что находится внутри\
одного блока имен, считается частью только этого блока.

**add.h:**
```c++
namespace DoMath {
    // Функция add() является частью пространства имен DoMath
    int add(int x, int y) {
        return x + y;
    }
}
```
**subtract.h:**
```c++
namespace DoMath {
    // Функция subtract() является частью пространства имен DoMath
    int subtract(int x, int y) {
        return x - y;
    }
}
```

**main.cpp:**
```c++
#include <iostream>
#include "add.h" // импортируем DoMath::add()
#include "subtract.h" // импортируем DoMath::subtract()

int main() {
    std::cout << DoMath::add(5, 4) << '\n';
    std::cout << DoMath::subtract(5, 4) << '\n';
    return 0;
}

<< 9
<< 1
```

### Псевдонимы и вложенные пространства имен
Одни пространства имен могут быть вложены в другие пространства имен:
```c++
#include <iostream>

namespace Boo {
    namespace Doo {
        const int g_x = 7;
    }
}

int main() {
    std::cout << Boo::Doo::g_x;
    return 0;
}
```
Поскольку Doo находится внутри Boo, то доступ к `g_x` осуществляется через `Boo::Doo::g_x`.

Так как это не всегда удобно и эффективно, то C++ позволяет создавать псевдонимы
для пространств имен:
```c++
#include <iostream>

namespace Boo {
    namespace Doo {
        const int g_x = 7;
    }
}

namespace Foo = Boo::Doo;  // Foo теперь считается как Boo::Doo

int main() {
    std::cout << Foo::g_x;  // это, на самом деле, Boo::Doo::g_x
    return 0;
}
```
**Вложенность пространств имен использовать не рекомендуется.**

## Урок №57. using-стейтменты
### Использование "using-объявления"
Строка using `std::cout;` сообщает компилятору, что мы будем использовать\
объект `cout` из пространства имен `std`. И каждый раз, когда компилятор будет\
сталкиваться с `cout`, он будет понимать, что это `std::cout`.
```c++
#include <iostream>

int main() {
  using std::cout; // «using-объявление» сообщает компилятору, что cout следует обрабатывать, как std::cout
  cout << "Hello, world!"; // и никакого префикса std:: уже здесь не нужно!
  return 0;
}
```

### Использование "using-директивы"
`using namespace std;` сообщает компилятору, что мы хотим использовать всё, \
что находится в пространстве имен `std`, так что, если компилятор найдет имя, \
которое не сможет распознать, он будет проверять его наличие в пространстве имен `std`.
```c++
#include <iostream>

int main() {
    // «using-директива» сообщает компилятору, что мы используем все объекты из пространства имен std!
  using namespace std; 
  cout << "Hello, world!"; // и никакого префикса std:: уже здесь не нужно!
  return 0;
}
```
**Совет: Старайтесь избегать использования "using-директивы" (насколько это возможно).**

### Пример конфликта c "using-директивой"
**Неверный способ:**
```c++
#include <iostream>

int cout() {  // объявляем нашу собственную функцию "cout"
    return 4;
}

int main() {
  // делаем std::cout доступным по "cout"  
  using namespace std;
  // какой cout компилятор здесь должен использовать? 
  cout << "Hello, world!"; 
  
  return 0;
}
```
**Верный способ:**
```c++
// Добавить префикс std:: к cout:
std::cout << "Hello, world!"; // сообщаем компилятору, что хотим использовать std::cout

// Использовать бы "using-объявление" вместо "using-директивы":
using std::cout; // сообщаем компилятору, что cout означает std::cout
cout << "Hello, world!"; // так что здесь следует использовать std::cou
```
**Правило: Никогда не используйте using-стейтменты вне тела функций.**

### Отмена/замена using-стейтментов
Как только один using-стейтмент был объявлен, его невозможно отменить или\
заменить другим using-стейтментом в пределах области видимости, в которой он\
был объявлен. Например:
```c++
int main() {
  using namespace Boo;
  // Отменить «использование пространства имен Boo» здесь невозможно!
  // Также нет никакого способа заменить «using namespace Boo» на другой using-стейтмент
  
  return 0;
} // действие using namespace Boo заканчивается здесь
```
Лучшее, что вы можете сделать — это намеренно ограничить область применения\
using-стейтментов с самого начала, используя правила локальной области видимости:
```c++
int main() {
  {
    using namespace Boo;
    // Здесь всё относится к пространству имен Boo::
  } // действие using namespace Boo заканчивается здесь
  
  {
    using namespace Foo;
    // Здесь всё относится к пространству имен Foo::
  } // действие using namespace Foo заканчивается здесь
  
  return 0;
}
```

## Урок №58. Неявное преобразование типов данных
### Преобразование типов
Процесс конвертации значений из одного типа данных в другой называется **преобразованием типов**.

Преобразование типов **может** выполняться в следующих случаях:
- Случай №1: Присваивание или инициализация переменной значением другого типа данных:
  ```c++
  double k(4)  // инициализация переменной типа double целым числом 4
  k = 7; // присваиваем переменной типа double целое число 7
  ```
- Случай №2: Передача значения в функцию, где тип параметра — другой:
  ```c++
  void doSomething(long l){
  }
  doSomething(4);  // передача числа 4 (тип int) в функцию с параметром типа long
  ```
- Случай №3: Возврат из функции, где тип возвращаемого значения — другой:
  ```c++
  float doSomething(){
    return 4.0;  // передача значения 4.0 (тип double) из функции, которая возвращает float
  }
  ```
- Случай №4: Использование бинарного оператора с операндами разных типов:
  ```c++
  double division = 5.0 / 4; // операция деления со значениями типов double и int
  ```

**Есть 2 основных способа преобразования типов:**
- **Неявное преобразование типов**, когда компилятор автоматически\
  конвертирует один фундаментальный тип данных в другой.
- **Явное преобразование типов**, когда разработчик использует один из\
  операторов явного преобразования для выполнения конвертации объекта из\
  одного типа данных в другой.

### Неявное преобразование типов
**Неявное преобразование типов** (или "автоматическое преобразование типов")\
выполняется всякий раз, когда требуется один фундаментальный тип данных, но\
предоставляется другой, и пользователь не указывает компилятору, как выполнить\
конвертацию (не использует явное преобразование типов через операторы явного\
преобразования).

Есть 2 основных способа неявного преобразования типов:
- числовое расширение;
- числовая конверсия.

### Числовое расширение
Когда значение из одного типа данных конвертируется в другой тип данных\
побольше (по размеру и по диапазону значений), то это называется **числовым\
расширением**:
```c++
long l(65); // расширяем значение типа int (65) в тип long
double d(0.11f); // расширяем значение типа float (0.11) в тип double
```

В языке C++ есть два варианта расширений:
- **Интегральное расширение** (или "целочисленное расширение"). Включает в\
  себя преобразование целочисленных типов, меньших, чем int (bool, char,\
  unsigned char, signed char, unsigned short, signed short) в int (если это\
  возможно) или unsigned int.
- **Расширение типа с плавающей точкой**. Конвертация из типа float в тип double.

**Важно: Числовые расширения всегда безопасны и не приводят к потере данных.**

### Числовые конверсии
Когда мы конвертируем значение из более крупного типа данных в аналогичный, но\
более мелкий тип данных, или конвертация происходит между разными типами\
данных, то это называется **числовой конверсией**.
```c++
double d = 4; // конвертируем 4 (тип int) в double
short s = 3; // конвертируем 3 (тип int) в short
```

В этом примере мы присвоили огромное целочисленное значение типа `int`\
переменной типа `char` (диапазон которого составляет от -128 до 127).\
Это приведет к переполнению и следующему результату:
```c++
#include <iostream>

int main() {
  int i = 30000;
  char c = i;
  std::cout << static_cast<int>(c);
  
  return 0;
}

<< 48
```

Однако, если число подходит по диапазону, конвертация пройдет успешно.
```c++
#include <iostream>

int main() {
  int i = 3;
  short s = i; // конвертируем значение типа int в тип short
  std::cout << s << std::endl;
  
  double d = 0.1234;
  float f = d; // конвертируем значение типа double в тип float
  std::cout << f << std::endl;
  
  return 0;
}

<< 3
<< 0.1234
```

В случаях со значениями типа с плавающей точкой могут произойти округления\
из-за худшей точности в меньших типах. Например:
```c++
#include <iostream>
#include <iomanip> // для std::setprecision()
int main() {
  float f = 0.123456789; // значение типа double - 0.123456789 имеет 9 значащих цифр, но float может хранить только 7
  std::cout << std::setprecision(9) << f; // std::setprecision определен в заголовочном файле iomanip
  
  return 0;
}

<< 0.123456791
```

`std::setprecision(n)` устанавливает параметр точности потока `out` или `in` равным `n`:
```c++
#include <numbers>
int main() {
    constexpr long double pi {std::numbers::pi_v<long double>};
    std::cout << std::setprecision(3) << pi << '\n';
    std::cout << std::setprecision(19) << pi << '\n';
    return 0;
}

<< 3.14
<< 3.141592653589793239
```

Конвертируя из `float` в `int`, любая дробь отбрасывается:
```c++
#include <iostream>

int main() {
    int i = 4.6;
    std::cout << i;
    
    return 0;
}

<< 4
```

### Обработка арифметических выражений
Оператор `typeid`, чтобы узнать решающий тип в выражении.
```c++
#include <iostream>
#include <typeinfo> // для typeid

int main() {
  short x(3);
  short y(6);
  std::cout << typeid(x + y).name() << " " << x + y << std::endl; // вычисляем решающий тип данных в выражении x + y
}

<< int 9
```

Здесь значение signed int (10) подвергается расширению в unsigned int (которое\
имеет более высокий приоритет), и выражение вычисляется как unsigned int. А\
поскольку unsigned — это только положительные числа, то происходит\
переполнение, и мы имеем то, что имеем:
```c++
#include <iostream>
int main()
{
  std::cout << 5u - 10; // 5u означает значение 5 типа unsigned int
  return 0;
}

<< 4294967291
```
Это одна из тех многих веских причин избегать использования типа unsigned int вообще.

## Урок №59. Явное преобразование типов данных
### Операторы явного преобразования типов данных
В языке C++ есть 5 видов **операций явного преобразования типов**:
- конвертация C-style;
- применение оператора static_cast;
- применение оператора const_cast;
- применение оператора dynamic_cast;
- применение оператора reinterpret_cast.

**Правило: Избегайте использования const_cast и reinterpret_cast, если у вас нет на
это веских причин.**

### Конвертация C-style
```c++
int i1 = 11;
int i2 = 3;
// т.к. i1 станет типа float, то i2 также затем автоматически преобразуется в тип float
float x = float(i1) / i2;
```
**Правило: Не используйте конвертацию C-style.**

### Оператор static_cast
Оператор `static_cast` лучше всего использовать для конвертации одного\
фундаментального типа данных в другой:
```c++
int i1 = 11;
int i2 = 3;
float x = static_cast<float>(i1) / i2;
```
Основным преимуществом оператора `static_cast` является проверка его выполнения\
компилятором во время компиляции, что усложняет возможность возникновения\
непреднамеренных проблем.

### Использование операторов явного преобразования в неявном преобразовании
Чтобы сообщить компилятору, что вы намеренно делаете что-то, что потенциально опасно, 
используйте оператор `static_cast`:
```c++
int i = 49;
char ch = static_cast<char>(i);

int i = 90;
i = static_cast<int>(i / 3.6);
```

### Резюме
Преобразования типов данных следует избегать, если это вообще возможно,\
поскольку всякий раз, когда выполняется подобное изменение, есть вероятность\
возникновения непредвиденных проблем. Но очень часто случаются ситуации,\
когда этого не избежать. Поэтому в таких случаях лучше использовать оператор\
`static_cast` вместо конвертации `C-style`.

### Тест
В чём разница между явным и неявным преобразованием типов данных?

Неявное преобразование происходит, когда компилятор ожидает значение\
одного типа, но получает значение другого типа.

Явное преобразование происходит, когда программист использует оператор\
явного преобразования для конвертации значения из одного типа данных в\
другой.
