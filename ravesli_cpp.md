## Урок №44. Условный тернарный оператор, оператор sizeof и Запятая

```c++
z = (a, b); // сначала вычисляется выражение (a, b), которое равняется значению b, а затем результат присваивается переменной z
z = a, b; // вычисляется как "(z = a), b", поэтому переменной z присваивается значение a, переменная b - игнорируется
```

Условный (тернарный) оператор (обозначается как `?:`) является единственным тернарным\
оператором в языке С++, который работает с 3-мя операндами.

```c++
    c ? x : y  // Если c — ненулевое значение (true), то вычисляется x, в противном случае — y
```

Оператор ?: предоставляет сокращенный способ (альтернативу) ветвления if/else.\
Стейтменты if/else:
```c++
if (условие)
    выражение;
else
    другое_выражение;
```

Можно записать как:
```c++
(условие) ? выражение : другое_выражение;
```

Еще примеры:
```c++
// Привычный способ
if (x > y)
    larger = x;
else
    larger = y;

// Через тернарный оператор
larger = (x > y) ? x : y;
```

Помните, что оператор ?: имеет очень низкий приоритет, из-за этого его следует
записывать в круглых скобках.
```c++
int x = 0, y = 2;
std::cout << ((x > y) ? x : y);  // 2
std::cout << (x > y) ? x : y;  // 0
```

## Урок №45. Операторы сравнения

```c++
#include <iostream>

int main() {
    double d1(100 - 99.99); // должно быть 0.01, но = 0.0100000000000005116
    double d2(10 - 9.99); // должно быть 0.01, но = 0.0099999999999997868
    
    if (d1 == d2)
        std::cout << "d1 == d2" << "\n";
    else if (d1 > d2)
        std::cout << "d1 > d2" << "\n";
    else if (d1 < d2)
        std::cout << "d1 < d2" << "\n";
    return 0;
    
    >> d1 > d2
}
```

Не рекомендуется использовать операторы == или != с числами типа с плавающей точкой.\
Вместо них следует использовать функцию, которая вычисляет, насколько эквивалентны эти два
значения.
```c++
#include <cmath> // для функции fabs()

// Возвращаем true, если разница между a и b в пределах процента эпсилона
// epsilon вводится в процентах
bool approximatelyEqual(double a, double b, double epsilon) {
    return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
```

Но и функция approximatelyEqual() тоже не идеальна, особенно, когда дело доходит
до чисел, близких к нулю
```c++
// Значение a очень близко к 1.0, но, из-за ошибок округления, чуть меньше 1.0
double a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
// давайте сравним значение a - 1.0 (почти 0.0) с 0.0
std::cout << approximatelyEqual(a - 1.0, 0.0, 1e-8)

>> 0  // Математика просто ломается, когда дело доходит до нулей
```

Но и этого можно избежать, используя как абсолютный эпсилон (то, что мы делали
в первом способе), так и относительный (способ Кнута) вместе:
```c++
// Возвращаем true, если разница между a и b меньше absEpsilon или в пределах relEpsilon
bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon) {
    // Проверяем числа на равенство их друг другу - это нужно в тех случаях, 
    // когда сравниваемые числа являются нулевыми или "около нуля"
    double diff = fabs(a - b);
    if (diff <= absEpsilon)
        return true;
    // В противном случае, возвращаемся к алгоритму Кнута
    return diff <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * relEpsilon);
}
```

Тогда:
```c++
double a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
std::cout << approximatelyEqual(a, 1.0, 1e-8);  // сравниваем "почти 1.0" с 1.0
std::cout << approximatelyEqual(a - 1.0, 0.0, 1e-8) << "\n"; // сравниваем "почти 0.0" с 0.0
std::cout << approximatelyEqualAbsRel(a - 1.0, 0.0, 1e-12, 1e-8) << "\n"; // сравниваем "почти 0.0" с 0.0

>> 1
>> 0
>> 1
```

## Урок №46. Логические операторы: И, ИЛИ, НЕ

### Логический оператор НЕ
```c++
if (!(x == y))
    std::cout << "x != y";
```

Любое ненулевое целое значение в логическом контексте является
true. Так как `х = 5`, то `х` вычисляется как `true`, а вот `!x = false`, т.е. `0`.

### Логический оператор ИЛИ

```c++
if (value == 0 || value == 1 || value == 2 || value == 3)
    std::cout << "You picked 0, 1, 2, or 3" << std::endl;
```

### Логический оператор И

```c++
if (value > 10 && value < 20)
    std::cout << "Your value is between 10 and 20" << std::endl;
```

### Использование логических операторов И/ИЛИ

**Приоритет логического И выше приоритета ИЛИ**

Рассмотрим следующее выражение: `value1 || value2 && value3`. Поскольку
приоритет логического И выше, то обрабатываться выражение будет так:\
`value1 || (value2 && value3)`\
А не так:\
`(value1 || value2) && value3`

**Законы Де Моргана** гласят, что `!(x && y)` эквивалентно `!x || !y`,
`а !(x || y)` эквивалентно `!x && !y`.

## Урок №48. Побитовые операторы
### Побитовый сдвиг влево (<<) и побитовый сдвиг вправо (>>)
```
// сдвиг влева
3 = 0011
3 << 1 = 0110 = 6
3 << 2 = 1100 = 12
3 << 3 = 1000 = 8

// сдвиг вправо
12 = 1100
12 >> 1 = 0110 = 6
12 >> 2 = 0011 = 3
12 >> 3 = 0001 = 1
```

```c++
int main() {
    unsigned int x = 4;
    x = x << 1;  // оператор << используется для побитового сдвига влево
    std::cout << x; // оператор << используется для вывода данных в консоль
    return 0;
}

>> 8
```

### Побитовый оператор НЕ
Результаты побитового НЕ зависят от размера типа данных.
```
// размер типа данных составляет 4 бита
4 = 0100
~ 4 = 1011 (двоичное) = 11 (десятичное)

// размер типа данных составляет 8 бит
4 = 0000 0100
~ 4 = 1111 1011 (двоичное) = 251 (десятичное)
```

### Побитовые операторы И, ИЛИ и исключающее ИЛИ (XOR)

Если хоть один бит в столбце равен 1, то результат целого столбца — 1
```
// 2 числа
0 1 0 1 // 5
0 1 1 0 // 6
-------
0 1 1 1 // 7

// 3 числа
0 0 0 1 // 1
0 1 0 0 // 4
0 1 1 0 // 6
--------
0 1 1 1 // 7
```

Побитовое И работает аналогично логическому И — возвращается true, только если
оба бита в столбце равны 1
```
0 1 0 1 // 5
0 1 1 0 // 6
--------
0 1 0 0 // 4

0 0 0 1 // 1
0 0 1 1 // 3
0 1 1 1 // 7
--------
0 0 0 1 // 1
```

При обработке двух операндов, исключающее ИЛИ возвращает true (1),
только если один и только один из операндов является истинным (1).
Если таких нет или все операнды равны 1, то результатом будет false (0).
```
0 1 1 0 // 6
0 0 1 1 // 3
-------
0 1 0 1 // 5
```

Если единиц в столбце чётное количество, то результатом будет 0, если же нечётное
количество, то результат — 1.
```
0 0 0 1 // 1
0 0 1 1 // 3
0 1 1 1 // 7
--------
0 1 0 1 // 5
```

### Побитовые операторы присваивания
Вместо `х = х << 1;` мы можем написать `х <<= 1;`

## Урок №49. Битовые флаги и битовые маски

```c++
// Определяем 8 отдельных битовых флагов (они могут представлять всё, что вы захотите).
// Обратите внимание, в C++11 лучше использовать "uint8_t" вместо "unsigned char"
const unsigned char option1 = 0x01; // шестнадцатеричный литерал для 0000 0001
const unsigned char option2 = 0x02; // шестнадцатеричный литерал для 0000 0010
const unsigned char option3 = 0x04; // шестнадцатеричный литерал для 0000 0100
const unsigned char option4 = 0x08; // шестнадцатеричный литерал для 0000 1000
const unsigned char option5 = 0x10; // шестнадцатеричный литерал для 0001 0000
const unsigned char option6 = 0x20; // шестнадцатеричный литерал для 0010 0000
const unsigned char option7 = 0x40; // шестнадцатеричный литерал для 0100 0000
const unsigned char option8 = 0x80; // шестнадцатеричный литерал для 1000 0000

// Байтовое значения для хранения комбинаций из 8 возможных вариантов
unsigned char myflags = 0; // все флаги/параметры отключены до старта
```

Чтобы узнать битовое состояние, используется побитовое И:
```c++
if (myflags & option4) ... // если option4 установлено - что-нибудь делаем
```

Чтобы включить биты, используется побитовое ИЛИ:
```c++
myflags |= option4; // включаем option4
myflags |= (option4 | option5); // включаем option4 и option5
```

Чтобы выключить биты, используется побитовое И с инвертированным литералом:
```c++
myflags &= ~option4; // выключаем option4
myflags &= ~(option4 | option5); // выключаем option4 и option5
```

Для переключения между состояниями бит, используется побитовое исключающее ИЛИ (XOR):
```c++
myflags ^= option4; // включаем или выключаем option4
myflags ^= (option4 | option5); // изменяем состояния option4 и option5
```

### Битовые флаги полезны, если:
#### Если у вас много идентичных битовых флагов
Вместо одной переменной `myflags`, рассмотрим случай, когда у вас есть две
переменные: `myflags1` и `myflags2`, каждая из которых может хранить 8
значений. Если вы определите их как два отдельных логических набора, то вам
потребуется 16 логических значений и, таким образом, 16 байт. Однако с
использованием битовых флагов вам потребуется только 10 байт (8 для
определения параметров и 1 для каждой переменной `myflags`). А вот если у вас
будет 100 переменных `myflags`, то, используя битовые флаги, вам потребуется 108
байт вместо 800. Чем больше идентичных переменных вам нужно, тем более
значительной будет экономия памяти.

#### Если есть функция, которая на вход принимает большое количество данных
Представьте, что у вас есть функция, которая может принимать любую
комбинацию из 32 различных вариантов. Одним из способов написания такой
функции является использование 32 отдельных логических параметров:
```c++
void someFunction(bool option1, bool option2, bool option3, bool option4,
bool option5, bool option6, bool option7, bool option8, bool option9, bool
option10, bool option11, bool option12, bool option13, bool option14, bool
option15, bool option16, bool option17, bool option18, bool option19, bool
option20, bool option21, bool option22, bool option23, bool option24, bool
option25, bool option26, bool option27, bool option28, bool option29, bool
option30, bool option31, bool option32);

someFunction(false, false, false, false, false, false, false, false, false,
true, false, false, false, false, false, false, false, false, false, false,
false, false, false, false, false, false, false, false, false, false, false,
true);
```

А вот если определить функцию с помощью битовых флагов:
```c++
void someFunction(unsigned int options);
```

То можно выбирать и передавать только нужные параметры:
```c++
someFunction(option10 | option32);
```
Кроме того, что это читабельнее, это также эффективнее и производительнее, так
как включает только 2 операции (1 побитовое ИЛИ и 1 передача параметров)

### Введение в std::bitset
Для его использования необходимо подключить заголовочный файл bitset, а затем
определить переменную типа std::bitset, указав необходимое количество бит. Она
должна быть константой типа compile time.
```c++
#include <bitset>

std::bitset<8> bits; // нам нужно 8 бит
```

При желании std::bitset можно инициализировать начальным набором значений:
```c++
#include <bitset>

std::bitset<8> bits(option1 | option2) ; // начнем с включенных option1 и option2
std::bitset<8> morebits(0x2) ; // начнем с битового шаблона 0000 0010
```

В `std::bitset` есть 4 основные функции:
- функция `test()` — позволяет узнать значение бита (0 или 1).
- функция `set()` — позволяет включить биты (если они уже включены, то ничего не произойдет).
- функция `reset()` — позволяет выключить биты (если они уже выключены, то ничего не произойдет).
- функция `flip()` — позволяет изменить значения бит на противоположные (с 0 на 1 или с 1 на 0).

Пример использования:
```c++
#include <iostream>
#include <bitset>

// Обратите внимание, используя std::bitset, наши options соответствуют порядковым номерам бит, а не их значениям
const int option_1 = 0;
const int option_2 = 1;
const int option_3 = 2;
const int option_4 = 3;
const int option_5 = 4;
const int option_6 = 5;
const int option_7 = 6;
const int option_8 = 7;

int main() {
    // Помните, что отсчет бит начинается не с 1, а с 0
    std::bitset<8> bits(0x2); // нам нужно 8 бит, начнем с битового шаблона 0000 0010
    bits.set(option_5); // включаем 4-й бит - его значение изменится на 1 (теперь мы имеем 0001 0010)
    bits.flip(option_6); // изменяем значения 5-го бита на противоположное (теперь мы имеем 0011 0010)
    bits.reset(option_6); // выключаем 5-й бит - его значение снова 0 (теперь мы имеем 0001 0010)
    
    std::cout << "Bit 4 has value: " << bits.test(option_5) << '\n';
    std::cout << "Bit 5 has value: " << bits.test(option_6) << '\n';
    std::cout << "All the bits: " << bits << '\n';
    
    return 0;
}

>> Bit 4 has value: 1
>> Bit 5 has value: 0
>> All the bits: 00010010
```

### Битовые маски
Когда мы соединяем отдельные биты вместе, в целях их модификации как группы,
то это называется битовой маской.

```c++
#include <iostream>

int main() {
    const unsigned int lowMask = 0xF; // битовая маска для хранения последних4 бит (шестнадцатеричный литерал для 0000 0000 0000 1111)
    
    std::cout << "Enter an integer: ";
    int num;
    std::cin >> num;
    
    num &= lowMask; // удаляем первые биты, оставляя последние 4
    
    std::cout << "The 4 low bits have value: " << num << '\n';
    
    return 0;
}

>> Enter an integer: 151
>> The 4 low bits have value: 7
```

`151` в десятичной системе равно `1001 0111` в двоичной. `lowMask` — это `0000
1111` в 8-битной двоичной системе. `1001 0111 & 0000 1111 = 0000 0111`,
что равно десятичному `7`.

### Пример с RGBA

Следующая программа просит пользователя ввести 32-битное шестнадцатеричное
значение, а затем извлекает 8-битные цветовые значения R, G, B и A:
```c++
#include <iostream>

int main() {
    const unsigned int redBits = 0xFF000000;
    const unsigned int greenBits = 0x00FF0000;
    const unsigned int blueBits = 0x0000FF00;
    const unsigned int alphaBits = 0x000000FF;
    
    std::cout << "Enter a 32-
    bit RGBA color value in hexadecimal (e.g. FF7F3300): ";
    unsigned int pixel;
    std::cin >> std::hex >> pixel; // std::hex позволяет вводить шестнадцатеричные значения
    
    // Используем побитовое И для изоляции красных пикселей, а затем сдвигаем значение вправо в диапазон 0-255
    unsigned char red = (pixel & redBits) >> 24;
    unsigned char green = (pixel & greenBits) >> 16;
    unsigned char blue = (pixel & blueBits) >> 8;
    unsigned char alpha = pixel & alphaBits;
    
    std::cout << "Your color contains:\n";
    std::cout << static_cast<int>(red) << " of 255 red\n";
    std::cout << static_cast<int>(green) << " of 255 green\n";
    std::cout << static_cast<int>(blue) << " of 255 blue\n";
    std::cout << static_cast<int>(alpha) << " of 255 alpha\n";
    
    return 0;
}
```

Результат выполнения программы:
```c++
Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300):
>>> FF7F3300
Your color contains:
255 of 255 red
127 of 255 green
51 of 255 blue
0 of 255 alpha
```

### Тест
Есть следующий фрагмент кода:
```c++
int main() {
    unsigned char option_viewed = 0x01;
    unsigned char option_edited = 0x02;
    unsigned char option_favorited = 0x04;
    unsigned char option_shared = 0x08;
    unsigned char option_deleted = 0x80;
    
    unsigned char myArticleFlags;
    
    return 0;
}
```

№1. Добавьте строку кода, чтобы пометить статью как уже прочитанную (option_viewed).\
`myArticleFlags |= option_viewed;`

№2. Добавьте строку кода, чтобы проверить, была ли статья удалена (option_deleted).\
`if (myArticleFlags & option_deleted) …`

№3. Добавьте строку кода, чтобы открепить статью от закрепленного места (option_favorited).\
`myArticleFlags &= ~option_favorited;`

№4. Почему следующие две строки идентичны?
```c++
myflags &= ~(option4 | option5); // выключаем option4 и option5
myflags &= ~option4 & ~option5; // выключаем option4 и option5
```
Закон Де Моргана.

