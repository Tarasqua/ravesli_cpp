# Глава №16. Стандартная библиотека шаблонов (STL) в C++
## Содержание
1. [Урок №204. Стандартная библиотека шаблонов STL](#урок-204-стандартная-библиотека-шаблонов-stl)
2. [Урок №205. Контейнеры STL](#урок-205-контейнеры-stl)
3. [Урок №206. Итераторы STL](#урок-206-итераторы-stl)
4. [Урок №207. Алгоритмы STL](#урок-207-алгоритмы-stl)

## [Урок №204. Стандартная библиотека шаблонов STL](#урок-204-стандартная-библиотека-шаблонов-stl)
### Стандартная библиотека шаблонов
**Стандартная библиотека шаблонов** (сокр. **"STL"** от "**S**tandard **T**emplate **L**ibrary") —\
это часть Стандартной библиотеки С++, которая содержит набор шаблонов\
контейнерных классов (например, `std::vector` и `std::array`), алгоритмов и итераторов.

## [Урок №205. Контейнеры STL](#урок-205-контейнеры-stl)
**Контейнеры STL делятся на три основные категории:**
* последовательные;
* ассоциативные;
* адаптеры.

### Последовательные контейнеры
**Последовательные контейнеры** (или **«контейнеры последовательности»**) — это\
контейнерные классы, элементы которых находятся в последовательности.

**STL содержит 6 контейнеров последовательности:**
* `std::vector`;
* `std::deque`;
* `std::array`;
* `std::list`;
* `std::forward_list`;
* `std::basic_string`.

**Класс vector** (или просто **«вектор»**) – это динамический массив, способный\
увеличиваться по мере необходимости для содержания всех своих элементов:
```c++
#include <iostream> 
#include <vector>
 
int main() {
    std::vector<int> vect;
    for (int count=0; count < 5; ++count)
        vect.push_back(10 - count); // добавляем числа в конец массива
 
    for (int index=0; index < vect.size(); ++index)
        std::cout << vect[index] << ' '; // 10 9 8 7 6
 
    std::cout << '\n';
}
```

**Класс deque** (или просто **«дек»**) — это двусторонняя очередь, реализованная в виде\
динамического массива, который может расти с обоих концов:
```c++
#include <iostream>
#include <deque>
 
int main() {
    std::deque<int> deq;
    for (int count=0; count < 4; ++count) {
        deq.push_back(count); // вставляем числа в конец массива
        deq.push_front(10 - count); // вставляем числа в начало массива
    }
 
    for (int index=0; index < deq.size(); ++index)
        std::cout << deq[index] << ' '; // 7 8 9 10 0 1 2 3
 
    std::cout << '\n';
}
```

**List** (или просто **«список»**) — это двусвязный список, каждый элемент которого\
содержит 2 указателя: один указывает на следующий элемент списка, а другой — на\
предыдущий элемент списка. List предоставляет доступ только к началу и к концу\
списка — произвольный доступ запрещен. Если вы хотите найти значение где-то в\
середине, то вы должны начать с одного конца и перебирать каждый элемент\
списка до тех пор, пока не найдете то, что ищете. Преимуществом двусвязного\
списка является то, что добавление элементов происходит очень быстро, если вы,\
конечно, знаете, куда хотите добавлять. Обычно для перебора элементов\
двусвязного списка используются итераторы.

Хотя о **классе string** (и **wstring**) обычно не говорят, как о последовательном\
контейнере, но он, по сути, таковым является, поскольку его можно рассматривать\
как вектор с элементами типа `char` (или `wchar`).

### Ассоциативные контейнеры
**Ассоциативные контейнеры** — это контейнерные классы, которые автоматически\
сортируют все свои элементы (в том числе и те, которые добавляете вы). По\
умолчанию ассоциативные контейнеры выполняют сортировку элементов,\
используя оператор сравнения `<`.
* **set** — это контейнер, в котором хранятся только уникальные элементы, и\
  повторения запрещены. Элементы сортируются в соответствии с их\
  значениями.
* **multiset** — это set, но в котором допускаются повторяющиеся элементы.
* **map** (или **«ассоциативный массив»**) — это set, в котором каждый элемент\
  является парой "ключ-значение". "Ключ" используется для сортировки и\
  индексации данных и должен быть уникальным, а "значение" — это\
  фактические данные.
* **multimap** (или **«словарь»**) — это map, который допускает дублирование\
  ключей. Все ключи отсортированы в порядке возрастания, и вы можете\
  посмотреть значение по ключу.

### Адаптеры
**Адаптеры** — это специальные предопределенные контейнерные классы, которые\
адаптированы для выполнения конкретных заданий. Самое интересное\
заключается в том, что вы сами можете выбрать, какой последовательный\
контейнер должен использовать адаптер.
* **stack** (**стек**) — это контейнерный класс, элементы которого работают по\
  принципу **LIFO** (англ. _«**L**ast **I**n, **F**irst **O**ut» = «последним пришел, первым\
  ушел»_), т.е. элементы добавляются (вносятся) в конец контейнера и\
  удаляются (выталкиваются) оттуда же (из конца контейнера). Обычно в стеках\
  используется `deque` в качестве последовательного контейнера по умолчанию\
  (что немного странно, поскольку vector был бы более подходящим\
  вариантом), но вы также можете использовать `vector` или `list`.
* **queue** (**очередь**) — это контейнерный класс, элементы которого работают по\
  принципу **FIFO** (англ. _«**F**irst **I**n, **F**irst **O**ut» = «первым пришел, первым ушел»_),\
  т.е. элементы добавляются (вносятся) в конец контейнера, но удаляются\
  (выталкиваются) из начала контейнера. По умолчанию в очереди\
  используется `deque` в качестве последовательного контейнера, но также\
  может использоваться и `list`.
* **priority_queue** (**очередь с приоритетом**) — это тип очереди, в которой все\
  элементы отсортированы (с помощью оператора сравнения `<`). При\
  добавлении элемента, он автоматически сортируется. Элемент с наивысшим\
  приоритетом (самый большой элемент) находится в самом начале очереди с\
  приоритетом, также, как и удаление элементов выполняется с самого начала\
  очереди с приоритетом.

## [Урок №206. Итераторы STL](#урок-206-итераторы-stl)
**Итератор** — это объект, который способен перебирать элементы контейнерного\
класса без необходимости пользователю знать реализацию определенного\
контейнерного класса.

### Функционал итераторов
* **Оператор** `*` возвращает элемент, на который в данный момент указывает\
  итератор.
* **Оператор** `++` перемещает итератор к следующему элементу контейнера.\
  Большинство итераторов также предоставляют **оператор** `−−` для перехода к\
  предыдущему элементу.
* **Операторы `==` и `!=`** используются для определения того, указывают ли оба\
  итераторы на один и тот же элемент или нет. Для сравнения значений, на\
  которые указывают оба итераторы, нужно сначала разыменовать эти\
  итераторы, а затем использовать оператор `==` или оператор `!=`.
* Оператор `=` присваивает итератору новую позицию (обычно начальный или\
  конечный элемент контейнера). Чтобы присвоить значение элемента, на\
  который указывает итератор, другому объекту, нужно сначала разыменовать\
  итератор, а затем использовать оператор `=`.

**4 основных метода для работы с оператором** `=`:
* метод `begin()` возвращает итератор, представляющий начальный элемент\
  контейнера;
* метод `end()` возвращает итератор, представляющий элемент, который\
  находится после последнего элемента в контейнере;
* метод `cbegin()` возвращает константный (только для чтения) итератор,\
  представляющий начальный элемент контейнера;
* метод `cend()` возвращает константный (только для чтения) итератор,\
  представляющий элемент, который находится после последнего элемента в\
  контейнере.

Может показаться странным, что метод `end()` не указывает на последний элемент\
контейнера, но это сделано в целях упрощения использования циклов: цикл\
перебирает элементы до тех пор, пока итератор не достигнет метода `end()`, и тогда\
уже всё — «Баста!».

Наконец, все контейнеры предоставляют (как минимум) **два типа итераторов**:
* `container::iterator` — итератор для чтения/записи;
* `container::const_iterator` — итератор только для чтения.

### Итерация по вектору
```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> myVector;
    for (int count = 0; count < 5; ++count)
        myVector.push_back(count);

    std::vector<int>::const_iterator it; // объявляем итератор только для чтения
    it = myVector.begin(); // присваиваем ему начальный элемент вектора
    while (it != myVector.end()) { // пока итератор не достигнет последнего элемента
        std::cout << *it << " "; // выводим значение элемента, на который указывает итератор
        ++it; // и переходим к следующему элементу
    } // 0 1 2 3 4 

    std::cout << '\n';
}
```

### Итерация по списку
```c++
#include <iostream>
#include <list>

int main() {
    std::list<int> myList;
    for (int count = 0; count < 5; ++count)
        myList.push_back(count);

    std::list<int>::const_iterator it; // объявляем итератор
    it = myList.begin(); // присваиваем ему начальный элемент списка
    while (it != myList.end()) { // пока итератор не достигнет последнего элемента
        std::cout << *it << " "; // выводим значение элемента, на который указывает итератор
        ++it; // и переходим к следующему элементу
    } // 0 1 2 3 4

    std::cout << '\n';
}
```

Код этой программы почти идентичен предыдущему примеру, хотя реализация\
векторов и списков значительно отличается друг от друга!

### Итерация по set-у
```c++
#include <iostream>
#include <set>

int main() {
    std::set<int> mySet;
    mySet.insert(8);
    mySet.insert(3);
    mySet.insert(-4);
    mySet.insert(9);
    mySet.insert(2);

    std::set<int>::const_iterator it; // объявляем итератор
    it = mySet.begin(); // присваиваем ему начальный элемент set-а
    while (it != mySet.end()) { // пока итератор не достигнет последнего элемента
        std::cout << *it << " "; // выводим значение элемента, на который указывает итератор
        ++it; // и переходим к следующему элементу
    } // -4 2 3 8 9

    std::cout << '\n';
}
```

### Итерация по ассоциативному массиву
Контейнеры `map` и `multimap` принимают пары элементов (определенные как `std::pair`).\
Мы используем вспомогательную функцию `make_pair()` для создания пар. `std::pair`\
позволяет получить доступ к элементу (паре "ключ-значение") через первый и второй\
члены. В нашем ассоциативном массиве мы используем первый член в качестве "ключа",\
а второй в качестве "значения":
```c++
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<int, std::string> myMap;
    myMap.insert(std::make_pair(3, "cat"));
    myMap.insert(std::make_pair(2, "dog"));
    myMap.insert(std::make_pair(5, "chicken"));
    myMap.insert(std::make_pair(4, "lion"));
    myMap.insert(std::make_pair(1, "spider"));

    std::map<int, std::string>::const_iterator it; // объявляем итератор
    it = myMap.begin(); // присваиваем ему начальный элемент вектора
    while (it != myMap.end()) { // пока итератор не достигнет последнего элемента
        std::cout << it->first << "=" << it->second << " "; // выводим значение элемента,
        // на который указывает итератор
        ++it; // и переходим к следующему элементу
    } // 1=spider 2=dog 3=cat 4=lion 5=chicken

    std::cout << '\n';
}
```

### Резюме
> <picture>
>   <source media="(prefers-color-scheme: light)" srcset="https://raw.githubusercontent.com/Mqxx/GitHub-Markdown/main/blockquotes/badge/light-theme/success.svg">
>   <img alt="Success" src="https://raw.githubusercontent.com/Mqxx/GitHub-Markdown/main/blockquotes/badge/dark-theme/success.svg">
> </picture><br>
>
> Итераторы предоставляют простой способ перебора элементов контейнерного\
> класса без необходимости знать реализацию определенного контейнерного класса.\
> В сочетании с алгоритмами STL и методами контейнерных классов итераторы\
> становятся еще более мощными.

## [Урок №207. Алгоритмы STL](#урок-207-алгоритмы-stl)
### Алгоритмы `min_element()` и `max_element()`
Алгоритмы `min_element()` и `max_element()` находят минимальный и максимальный\
элементы в контейнере:
```c++
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> li;
    for (int nCount = 0; nCount < 5; ++nCount)
        li.push_back(nCount);

    std::list<int>::const_iterator it; // объявляем итератор
    it = min_element(li.begin(), li.end());
    std::cout << *it << ' '; // 0
    it = max_element(li.begin(), li.end());
    std::cout << *it << ' '; // 4

    std::cout << '\n';
}
```

### Алгоритмы `find()` и `list::insert()`
В следующем примере мы используем алгоритм `find()`, чтобы найти определенное\
значение в списке, а затем используем функцию `list::insert()` для добавления нового\
значения в список:
```c++
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> li;
    for (int nCount = 0; nCount < 5; ++nCount)
        li.push_back(nCount);

    std::list<int>::iterator it; // объявляем итератор
    it = find(li.begin(), li.end(), 2); // ищем в списке число 2
    li.insert(it, 7); // используем алгоритм list::insert() для добавления числа 7 перед числом 2

    for (it = li.begin(); it != li.end(); ++it) // выводим с помощью цикла и итератора элементы списка
        std::cout << *it << ' '; // 0 1 7 2 3 4

    std::cout << '\n';
}
```

### Алгоритмы `sort()` и `reverse()`
В следующем примере мы отсортируем весь вектор, выведем отсортированные\
элементы, а затем выведем их в обратном порядке:
```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vect;
    vect.push_back(4);
    vect.push_back(8);
    vect.push_back(-3);
    vect.push_back(3);
    vect.push_back(-8);
    vect.push_back(12);
    vect.push_back(5);

    std::sort(vect.begin(), vect.end()); // выполняем сортировку элементов вектора
    std::vector<int>::const_iterator it; // объявляем итератор
    for (it = vect.begin(); it != vect.end(); ++it) // выводим с помощью цикла и итератора элементы вектора
        std::cout << *it << ' '; // -8 -3 3 4 5 8 12

    std::cout << '\n';

    std::reverse(vect.begin(), vect.end()); // записываем элементы вектора в обратном порядке
    for (it = vect.begin(); it != vect.end(); ++it) // выводим с помощью цикла и итератора элементы вектора
        std::cout << *it << ' '; // 12 8 5 4 3 -3 -8

    std::cout << '\n';
}
```

### Резюме
> <picture>
>   <source media="(prefers-color-scheme: light)" srcset="https://raw.githubusercontent.com/Mqxx/GitHub-Markdown/main/blockquotes/badge/light-theme/success.svg">
>   <img alt="Success" src="https://raw.githubusercontent.com/Mqxx/GitHub-Markdown/main/blockquotes/badge/dark-theme/success.svg">
> </picture><br>
>
> Хотя это всего лишь небольшой пример алгоритмов, которые предоставляет STL, но\
> этого уже должно быть достаточно, чтобы вы увидели пользу и то, насколько легко\
> использовать алгоритмы STL в сочетании с итераторами и контейнерами.
