## Урок 42. Арифметические операторы

**`static_cast\<type>(expression)` для конвертации типов данных**
```c++
int main() {
int x = 7;
int y = 4;

std::cout << "int / int = " << x / y << "\n";  // int / int = 1
std::cout << "double / int = " << static_cast<double>(x) / y << "\n";  // double / int = 1.75
std::cout << "int / double = " << x / static_cast<double>(y) << "\n";  // int / double = 1.75
std::cout << "double / double = " << static_cast<double>(x) / static_cast<double>(y) << "\n";  // double / double = 1.75

return 0;
}
```

## Урок 43. Инкремент, декремент и побочные эффекты

```c++
// Префикс
// значение сначала увеличивается, а затем уже вычисляется
int x = 5;
int y = ++x;  // x = 6 и 6 присваивается y
```

```c++
// Постфикс
// Компилятор создает временную копию переменной x, увеличивает оригинальный x,
// а затем возвращает копию. Только после возврата копия x удаляется 
int x = 5;
int y = x++;  // x = 6, но переменной y присваивается 5
```

```c++
int add(int x, int y){
    return x + y;
}

int main() {
    int x = 5;
    std::cout << add(x, x++);  // 11
    std::cout << add(x, ++x);  // 12
    
    return 0;
}
```

```c++
int main(){
    int x = 1;
    x = x++;
    std::cout << x;  // 1
    
    return 0;
}
```

## Урок №44. Условный тернарный оператор, оператор `sizeof` и Запятая

```c++
z = (a, b); // сначала вычисляется выражение (a, b), которое равняется значению b, а затем результат присваивается переменной z
z = a, b; // вычисляется как "(z = a), b", поэтому переменной z присваивается значение a, переменная b - игнорируется
```

Условный (тернарный) оператор (обозначается как `?:`) является единственным тернарным\
оператором в языке С++, который работает с 3-мя операндами.

```c++
    c ? x : y  // Если c — ненулевое значение (true), то вычисляется x, в противном случае — y
```

Оператор ?: предоставляет сокращенный способ (альтернативу) ветвления if/else.\
Стейтменты if/else:

```c++
if (условие)
    выражение;
else
    другое_выражение;
```

Можно записать как:

```c++
(условие) ? выражение : другое_выражение;
```

Еще примеры:

```c++
// Привычный способ
if (x > y)
larger = x;
else
larger = y;

// Через тернарный оператор
larger = (x > y) ? x : y;
```

Помните, что оператор ?: имеет очень низкий приоритет, из-за этого его следует
записывать в круглых скобках.

```c++
int x = 0, y = 2;
std::cout << ((x > y) ? x : y);  // 2
std::cout << (x > y) ? x : y;  // 0
```

## Урок №45. Операторы сравнения

```c++
#include <iostream>

int main() {
    double d1(100 - 99.99); // должно быть 0.01, но = 0.0100000000000005116
    double d2(10 - 9.99); // должно быть 0.01, но = 0.0099999999999997868
    
    if (d1 == d2)
        std::cout << "d1 == d2" << "\n";
    else if (d1 > d2)
        std::cout << "d1 > d2" << "\n";
    else if (d1 < d2)
        std::cout << "d1 < d2" << "\n";
    return 0;
    
    >> d1 > d2
}
```

Не рекомендуется использовать операторы == или != с числами типа с плавающей точкой.\
Вместо них следует использовать функцию, которая вычисляет, насколько эквивалентны эти два
значения.

```c++
#include <cmath> // для функции fabs()

// Возвращаем true, если разница между a и b в пределах процента эпсилона
// epsilon вводится в процентах
bool approximatelyEqual(double a, double b, double epsilon) {
    return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
```

Но и функция approximatelyEqual() тоже не идеальна, особенно, когда дело доходит
до чисел, близких к нулю

```c++
// Значение a очень близко к 1.0, но, из-за ошибок округления, чуть меньше 1.0
double a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
// давайте сравним значение a - 1.0 (почти 0.0) с 0.0
std::cout << approximatelyEqual(a - 1.0, 0.0, 1e-8)

>> 0  // Математика просто ломается, когда дело доходит до нулей
```

Но и этого можно избежать, используя как абсолютный эпсилон (то, что мы делали\
в первом способе), так и относительный (способ Кнута) вместе:

```c++
// Возвращаем true, если разница между a и b меньше absEpsilon или в пределах relEpsilon
bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon) {
// Проверяем числа на равенство их друг другу - это нужно в тех случаях, 
// когда сравниваемые числа являются нулевыми или "около нуля"
double diff = fabs(a - b);
if (diff <= absEpsilon)
return true;
// В противном случае, возвращаемся к алгоритму Кнута
return diff <= ((fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * relEpsilon);
}
```

Тогда:

```c++
double a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
std::cout << approximatelyEqual(a, 1.0, 1e-8);  // сравниваем "почти 1.0" с 1.0
std::cout << approximatelyEqual(a - 1.0, 0.0, 1e-8) << "\n"; // сравниваем "почти 0.0" с 0.0
std::cout << approximatelyEqualAbsRel(a - 1.0, 0.0, 1e-12, 1e-8) << "\n"; // сравниваем "почти 0.0" с 0.0

>> 1
>> 0
>> 1
```

## Урок №46. Логические операторы: И, ИЛИ, НЕ

### Логический оператор НЕ

```c++
if (!(x == y))
    std::cout << "x != y";
```

Любое ненулевое целое значение в логическом контексте является
true. Так как `х = 5`, то `х` вычисляется как `true`, а вот `!x = false`, т.е. `0`.

### Логический оператор ИЛИ

```c++
if (value == 0 || value == 1 || value == 2 || value == 3)
    std::cout << "You picked 0, 1, 2, or 3" << std::endl;
```

### Логический оператор И

```c++
if (value > 10 && value < 20)
    std::cout << "Your value is between 10 and 20" << std::endl;
```

### Использование логических операторов И/ИЛИ

**Приоритет логического И выше приоритета ИЛИ**

Рассмотрим следующее выражение: `value1 || value2 && value3`. Поскольку
приоритет логического И выше, то обрабатываться выражение будет так:\
`value1 || (value2 && value3)`\
А не так:\
`(value1 || value2) && value3`

**Законы Де Моргана** гласят, что `!(x && y)` эквивалентно `!x || !y`,
`а !(x || y)` эквивалентно `!x && !y`.

## Урок №48. Побитовые операторы

### Побитовый сдвиг влево (`<<`) и побитовый сдвиг вправо (`>>`)

```
// сдвиг влева
3 = 0011
3 << 1 = 0110 = 6
3 << 2 = 1100 = 12
3 << 3 = 1000 = 8

// сдвиг вправо
12 = 1100
12 >> 1 = 0110 = 6
12 >> 2 = 0011 = 3
12 >> 3 = 0001 = 1
```

```c++
int main() {
    unsigned int x = 4;
    x = x << 1;  // оператор << используется для побитового сдвига влево
    std::cout << x; // оператор << используется для вывода данных в консоль
    return 0;
}

>> 8
```

### Побитовый оператор НЕ

Результаты побитового НЕ зависят от размера типа данных.

```
// размер типа данных составляет 4 бита
4 = 0100
~ 4 = 1011 (двоичное) = 11 (десятичное)

// размер типа данных составляет 8 бит
4 = 0000 0100
~ 4 = 1111 1011 (двоичное) = 251 (десятичное)
```

### Побитовые операторы И, ИЛИ и исключающее ИЛИ (XOR)

Если хоть один бит в столбце равен 1, то результат целого столбца — 1

```
// 2 числа
0 1 0 1 // 5
0 1 1 0 // 6
-------
0 1 1 1 // 7

// 3 числа
0 0 0 1 // 1
0 1 0 0 // 4
0 1 1 0 // 6
--------
0 1 1 1 // 7
```

Побитовое И работает аналогично логическому И — возвращается true, только если
оба бита в столбце равны 1

```
0 1 0 1 // 5
0 1 1 0 // 6
--------
0 1 0 0 // 4

0 0 0 1 // 1
0 0 1 1 // 3
0 1 1 1 // 7
--------
0 0 0 1 // 1
```

При обработке двух операндов, исключающее ИЛИ возвращает true (1),\
только если один и только один из операндов является истинным (1).\
Если таких нет или все операнды равны 1, то результатом будет false (0).

```
0 1 1 0 // 6
0 0 1 1 // 3
-------
0 1 0 1 // 5
```

Если единиц в столбце чётное количество, то результатом будет 0, если же нечётное\
количество, то результат — 1.

```
0 0 0 1 // 1
0 0 1 1 // 3
0 1 1 1 // 7
--------
0 1 0 1 // 5
```

### Побитовые операторы присваивания

Вместо `х = х << 1;` мы можем написать `х <<= 1;`

## Урок №49. Битовые флаги и битовые маски

```c++
// Определяем 8 отдельных битовых флагов (они могут представлять всё, что вы захотите).
// Обратите внимание, в C++11 лучше использовать "uint8_t" вместо "unsigned char"
const unsigned char option1 = 0x01; // шестнадцатеричный литерал для 0000 0001
const unsigned char option2 = 0x02; // шестнадцатеричный литерал для 0000 0010
const unsigned char option3 = 0x04; // шестнадцатеричный литерал для 0000 0100
const unsigned char option4 = 0x08; // шестнадцатеричный литерал для 0000 1000
const unsigned char option5 = 0x10; // шестнадцатеричный литерал для 0001 0000
const unsigned char option6 = 0x20; // шестнадцатеричный литерал для 0010 0000
const unsigned char option7 = 0x40; // шестнадцатеричный литерал для 0100 0000
const unsigned char option8 = 0x80; // шестнадцатеричный литерал для 1000 0000

// Байтовое значения для хранения комбинаций из 8 возможных вариантов
unsigned char myflags = 0; // все флаги/параметры отключены до старта
```

Чтобы узнать битовое состояние, используется побитовое И:

```c++
if (myflags & option4) ... // если option4 установлено - что-нибудь делаем
```

Чтобы включить биты, используется побитовое ИЛИ:

```c++
myflags |= option4; // включаем option4
myflags |= (option4 | option5); // включаем option4 и option5
```

Чтобы выключить биты, используется побитовое И с инвертированным литералом:

```c++
myflags &= ~option4; // выключаем option4
myflags &= ~(option4 | option5); // выключаем option4 и option5
```

Для переключения между состояниями бит, используется побитовое исключающее ИЛИ (XOR):

```c++
myflags ^= option4; // включаем или выключаем option4
myflags ^= (option4 | option5); // изменяем состояния option4 и option5
```

### Битовые флаги полезны, если:

#### Если у вас много идентичных битовых флагов

Вместо одной переменной `myflags`, рассмотрим случай, когда у вас есть две\
переменные: `myflags1` и `myflags2`, каждая из которых может хранить 8\
значений. Если вы определите их как два отдельных логических набора, то вам\
потребуется 16 логических значений и, таким образом, 16 байт. Однако с\
использованием битовых флагов вам потребуется только 10 байт (8 для\
определения параметров и 1 для каждой переменной `myflags`). А вот если у вас\
будет 100 переменных `myflags`, то, используя битовые флаги, вам потребуется 108\
байт вместо 800. Чем больше идентичных переменных вам нужно, тем более\
значительной будет экономия памяти.

#### Если есть функция, которая на вход принимает большое количество данных

Представьте, что у вас есть функция, которая может принимать любую\
комбинацию из 32 различных вариантов. Одним из способов написания такой\
функции является использование 32 отдельных логических параметров:
```c++
void someFunction(bool option1, bool option2, bool option3, bool option4,
bool option5, bool option6, bool option7, bool option8, bool option9, bool
option10, bool option11, bool option12, bool option13, bool option14, bool
option15, bool option16, bool option17, bool option18, bool option19, bool
option20, bool option21, bool option22, bool option23, bool option24, bool
option25, bool option26, bool option27, bool option28, bool option29, bool
option30, bool option31, bool option32);

someFunction(false, false, false, false, false, false, false, false, false,
true, false, false, false, false, false, false, false, false, false, false,
false, false, false, false, false, false, false, false, false, false, false,
true);
```

А вот если определить функцию с помощью битовых флагов:

```c++
void someFunction(unsigned int options);
```

То можно выбирать и передавать только нужные параметры:

```c++
someFunction(option10 | option32);
```

Кроме того, что это читабельнее, это также эффективнее и производительнее, так\
как включает только 2 операции (1 побитовое ИЛИ и 1 передача параметров)

### Введение в `std::bitset`

Для его использования необходимо подключить заголовочный файл bitset, а затем\
определить переменную типа std::bitset, указав необходимое количество бит. Она\
должна быть константой типа compile time.

```c++
#include <bitset>

std::bitset<8> bits; // нам нужно 8 бит
```

При желании std::bitset можно инициализировать начальным набором значений:

```c++
#include <bitset>

std::bitset<8> bits(option1 | option2) ; // начнем с включенных option1 и option2
std::bitset<8> morebits(0x2) ; // начнем с битового шаблона 0000 0010
```

В `std::bitset` есть 4 основные функции:

- функция `test()` — позволяет узнать значение бита (0 или 1).
- функция `set()` — позволяет включить биты (если они уже включены, то ничего не произойдет).
- функция `reset()` — позволяет выключить биты (если они уже выключены, то ничего не произойдет).
- функция `flip()` — позволяет изменить значения бит на противоположные (с 0 на 1 или с 1 на 0).

Пример использования:

```c++
#include <iostream>
#include <bitset>

// Обратите внимание, используя std::bitset, наши options соответствуют порядковым номерам бит, а не их значениям
const int option_1 = 0;
const int option_2 = 1;
const int option_3 = 2;
const int option_4 = 3;
const int option_5 = 4;
const int option_6 = 5;
const int option_7 = 6;
const int option_8 = 7;

int main() {
    // Помните, что отсчет бит начинается не с 1, а с 0
    std::bitset<8> bits(0x2); // нам нужно 8 бит, начнем с битового шаблона 0000 0010
    bits.set(option_5); // включаем 4-й бит - его значение изменится на 1 (теперь мы имеем 0001 0010)
    bits.flip(option_6); // изменяем значения 5-го бита на противоположное (теперь мы имеем 0011 0010)
    bits.reset(option_6); // выключаем 5-й бит - его значение снова 0 (теперь мы имеем 0001 0010)
    
    std::cout << "Bit 4 has value: " << bits.test(option_5) << '\n';
    std::cout << "Bit 5 has value: " << bits.test(option_6) << '\n';
    std::cout << "All the bits: " << bits << '\n';
    
    return 0;
}

>> Bit 4 has value: 1
>> Bit 5 has value: 0
>> All the bits: 00010010
```

### Битовые маски

Когда мы соединяем отдельные биты вместе, в целях их модификации как группы,\
то это называется битовой маской.

```c++
#include <iostream>

int main() {
    const unsigned int lowMask = 0xF; // битовая маска для хранения последних4 бит (шестнадцатеричный литерал для 0000 0000 0000 1111)
    
    std::cout << "Enter an integer: ";
    int num;
    std::cin >> num;
    
    num &= lowMask; // удаляем первые биты, оставляя последние 4
    
    std::cout << "The 4 low bits have value: " << num << '\n';
    
    return 0;
}

>> Enter an integer: 151
<< The 4 low bits have value: 7
```

`151` в десятичной системе равно `1001 0111` в двоичной. `lowMask` — это `0000
1111` в 8-битной двоичной системе. `1001 0111 & 0000 1111 = 0000 0111`,
что равно десятичному `7`.

### Пример с RGBA

Следующая программа просит пользователя ввести 32-битное шестнадцатеричное\
значение, а затем извлекает 8-битные цветовые значения R, G, B и A:

```c++
#include <iostream>

int main() {
    const unsigned int redBits = 0xFF000000;
    const unsigned int greenBits = 0x00FF0000;
    const unsigned int blueBits = 0x0000FF00;
    const unsigned int alphaBits = 0x000000FF;
    
    std::cout << "Enter a 32-
    bit RGBA color value in hexadecimal (e.g. FF7F3300): ";
    unsigned int pixel;
    std::cin >> std::hex >> pixel; // std::hex позволяет вводить шестнадцатеричные значения
    
    // Используем побитовое И для изоляции красных пикселей, а затем сдвигаем значение вправо в диапазон 0-255
    unsigned char red = (pixel & redBits) >> 24;
    unsigned char green = (pixel & greenBits) >> 16;
    unsigned char blue = (pixel & blueBits) >> 8;
    unsigned char alpha = pixel & alphaBits;
    
    std::cout << "Your color contains:\n";
    std::cout << static_cast<int>(red) << " of 255 red\n";
    std::cout << static_cast<int>(green) << " of 255 green\n";
    std::cout << static_cast<int>(blue) << " of 255 blue\n";
    std::cout << static_cast<int>(alpha) << " of 255 alpha\n";
    
    return 0;
}
```

Результат выполнения программы:

```c++
<< Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300):
>> FF7F3300
<< Your color contains:
<< 255 of 255 red
<< 127 of 255 green
<< 51 of 255 blue
<< 0 of 255 alpha
```

### Тест

Есть следующий фрагмент кода:

```c++
int main() {
    unsigned char option_viewed = 0x01;
    unsigned char option_edited = 0x02;
    unsigned char option_favorited = 0x04;
    unsigned char option_shared = 0x08;
    unsigned char option_deleted = 0x80;
    
    unsigned char myArticleFlags;
    
    return 0;
}
```

№1. Добавьте строку кода, чтобы пометить статью как уже прочитанную (option_viewed).\
`myArticleFlags |= option_viewed;`

№2. Добавьте строку кода, чтобы проверить, была ли статья удалена (option_deleted).\
`if (myArticleFlags & option_deleted) …`

№3. Добавьте строку кода, чтобы открепить статью от закрепленного места (option_favorited).\
`myArticleFlags &= ~option_favorited;`

№4. Почему следующие две строки идентичны?

```c++
myflags &= ~(option4 | option5); // выключаем option4 и option5
myflags &= ~option4 & ~option5; // выключаем option4 и option5
```

Закон Де Моргана.

# Глава №4. Область видимости и другие типы переменных в C++

## Урок №50. Блоки стейтментов (составные операторы)

**Блоки стейтментов** (или **"составные операторы"**) — это группа стейтментов,\
которые обрабатываются компилятором как одна инструкция. Блок начинается с\
символа `{` и заканчивается символом `}`, стейтменты находятся внутри. Блоки могут\
использоваться в любом месте, где разрешено использовать один стейтмент. В\
конце составного оператора точка с запятой не ставится.

### Вложенные блоки

При использовании вложенных блоков, блок, который содержит внутри себя другой\
блок, называется **внешним блоком**, а тот, который содержится внутри этого блока\
— **внутренний/вложенный блок**.

```c++
int add(int x, int y) { // начало блока
    return x + y;
} // конец блока

int main() { // начало внешнего блока
    // Несколько стейтментов
    int value {};
    
    { // начало внутреннего/вложенного блока
    add(3, 4);
    } // конец внутреннего/вложенного блока
    
    return 0;
} // конец внешнего блока
```

### Количество уровней вложенности блоков

**Уровень вложенности функции** (или **"глубина вложенности функции"**) — это\
максимальное количество блоков, которые могут находиться в любой точке\
функции (включая внешний блок). В вышеприведенной функции есть 4 блока, но\
уровень вложенности равен 3.

```c++
#include <iostream>

int main() { // 1-й уровень вложенности блоков
    std::cout << "Enter an integer: ";
    int value {};
    std::cin >> value;
    
    if (value > 0) { // 2-й уровень вложенности блоков
        if ((value % 2) == 0) { // 3-й уровень вложенности блоков
                std::cout << value << " is positive and even\n";
            }
            else
            { // также 3-й уровень вложенности блоков
                std::cout << value << " is positive and odd\n";
            }
    }
    
    return 0;
}
```

## Урок №51. Локальные переменные, область видимости и продолжительность жизни

**Область видимости** определяет, где можно использовать переменную. **Продолжительность жизни**\
(или **"время жизни"**) определяет, где переменная создается и где уничтожается.

Переменные, определенные внутри блока, называются **локальными\
переменными**. Локальные переменные имеют **автоматическую\
продолжительность жизни**: они создаются (и инициализируются, если\
необходимо) в точке определения и уничтожаются при выходе из блока. Локальные\
переменные имеют **локальную область видимости** (или **"блочную"**), т.е. они входят\
в область видимости с точки объявления и выходят в самом конце блока, в котором\
определены.

```c++
#include <iostream>

int main() { // начало внешнего блока
    int x(5);
    
    { // начало вложенного блока
        int y(7);
        // Мы можем использовать x и y здесь
        std::cout << x << " + " << y << " = " << x + y;
    } // переменная y уничтожается здесь
    
    // Переменную y здесь нельзя использовать, поскольку она уже уничтожена!
    
    return 0;
} // переменная x уничтожается здесь
```

### Сокрытие имен
Переменная внутри вложенного блока может иметь то же имя, что и переменная\
внутри внешнего блока. Когда подобное случается, то переменная во вложенном\
(внутреннем) блоке «скрывает» внешнюю переменную. Это называется **сокрытием имен**:

```c++
#include <iostream>

int main() { // внешний блок
    int oranges(5); // внешняя переменная oranges

    if (oranges >= 5) // относится к внешней oranges
    { // вложенный блок
        int oranges; // скрывается внешняя переменная oranges
        // Идентификатор oranges теперь относится к вложенной переменной oranges.
        // Внешняя переменная oranges временно скрыта
        oranges = 10; // здесь мы присваиваем значение 10 вложенной переменной oranges, не внешней!

        std::cout << oranges << std::endl; // выводим значение вложенной переменной oranges
    } // вложенная переменная oranges уничтожается

    // Идентификатор oranges опять относится к внешней переменной oranges

    std::cout << oranges << std::endl; // выводим значение внешней переменной oranges

    return 0;
}  // внешняя переменная oranges уничтожается

<< 10
<< 5
```

**Правило: Избегайте использования вложенных переменных с именами,
идентичными именам внешних переменных.**

### Область видимости переменных
**Правило: Определяйте переменные в наиболее ограниченной области видимости.**
```c++
#include <iostream>

int main() {
    // Не определяйте x здесь
    {
        // Переменная x используется только внутри этого блока, поэтому определяем её здесь
        int x(7);
        std::cout << x;
    }
    // В противном случае, переменная x может быть использована и здесь
    
    return 0;
}
```

### Кириллица
`setlocale(LC_ALL, "rus");`

### Резюме
Область видимости определяет, где переменная доступна для использования.\
Продолжительность жизни переменной определяет, когда переменная\
создается и когда уничтожается.

Локальные переменные имеют локальную (блочную) область видимости, доступ\
к ним осуществляется только внутри блока, в котором они определены.

Локальные переменные имеют автоматическую продолжительность жизни, что\
означает, что они создаются в точке определения и уничтожаются в конце блока,\
в котором определены.

## Урок №52. Глобальные переменные
**Глобальными** называются переменные, которые объявлены вне блока. Они имеют\
**статическую продолжительность жизни**, т.е. создаются при запуске программы и\
уничтожаются при её завершении. Глобальные переменные имеют **глобальную\
область видимости** (или **"файловую область видимости"**), т.е. их можно\
использовать в любом месте файла, после их объявления.

### Определение глобальных переменных
С помощью оператора разрешения области видимости (`::`), компилятору\
можно сообщить, какую версию переменной вы хотите использовать: глобальную\
или локальную.
```c++
#include <iostream>

int value(4); // глобальная переменная

int main() {
    int value = 8; // эта переменная (локальная) скрывает значение глобальной переменной
    value++; // увеличивается локальная переменная value (не глобальная)
    ::value--; // уменьшается глобальная переменная value (не локальная)
    
    std::cout << "Global value: " << ::value << "\n";
    std::cout << "Local value: " << value << "\n";
    
    return 0;
} // локальная переменная уничтожается

<< Global value: 3
<< Local value: 9
```

Использовать одинаковые имена для локальных и глобальных переменных — это\
прямой путь к проблемам и ошибкам, поэтому подобное делать не рекомендуется.\
Многие разработчики добавляют к глобальным переменным префикс `g_`.

### Ключевые слова `static` и `extern`
Связь переменной определяет, относятся ли несколько упоминаний одного\
идентификатора к одной и той же переменной или нет.

Переменная без связей — это переменная с локальной областью видимости,\
которая относится только к блоку, в котором она определена.

Переменная, имеющая внутренние связи, называется **внутренней переменной** (или\
**"статической переменной"**). Она может использоваться в любом месте файла, в\
котором определена, но не относится к чему-либо вне этого файла.

Переменная, имеющая внешние связи, называется **внешней переменной**. Она\
может использоваться как в файле, в котором определена, так и в других файлах.

**Ключевое слово `static` нужно**, чтобы сделать глобальную переменную внутренней\
(которую можно использовать только внутри одного файла):
```c++
#include <iostream>

// g_x - это статическая глобальная переменная, 
// которую можно использовать только внутри этого файла
static int g_x; 

int main() {
    return 0;
}
```

**Ключевое слово `extern` нужно**, чтобы сделать глобальную переменную внешней\
(которую можно использовать в любом файле программы):
```c++
#include <iostream>

// g_y - это внешняя глобальная переменная и её можно
// использовать и в других файлах программы
extern double g_y(9.8);

int main() {
    return 0;
}
```
По умолчанию, неконстантные переменные, объявленные вне блока, считаются\
внешними. Однако константные переменные, объявленные вне блока, считаются\
внутренними.

### Предварительные объявления переменных с использованием extern
Чтобы использовать внешнюю глобальную переменную, которая была\
объявлена в другом файле, нужно записать предварительное объявление\
переменной с использованием ключевого слова extern (без инициализируемого значения):

**global.cpp:**
```c++
// Определяем две глобальные переменные
int g_m; // неконстантные глобальные переменные имеют внешнюю связь по умолчанию

int g_n(3); // неконстантные глобальные переменные имеют внешнюю связь по умолчанию
// g_m и g_n можно использовать в любом месте этого файла
```
**main.cpp:**
```c++
#include <iostream>

extern int g_m; // предварительное объявление g_m. Теперь g_m можно использовать в любом месте этого файла

int main() {
    extern int g_n; // предварительное объявление g_n. Теперь g_n можно использовать только внутри main()
    
    g_m = 4;
    std::cout << g_n;3
    
    return 0;
}

<< 3
```
Если предварительное объявление находится вне блока, то оно применяется ко всему файлу.\
Если же внутри блока, то оно применяется только к нему.

Если переменная объявлена с помощью ключевого слова static, то получить доступ к\
ней с помощью предварительного объявления не получится:

**constants.cpp:**
```c++
static const double g_gravity(9.8);
```

**main.cpp:**
```c++
#include <iostream>

// не найдет g_gravity в constants.cpp, так как g_gravity является внутренней переменной
extern const double g_gravity; 

int main() {
    // вызовет ошибку компиляции, так как переменная g_gravity не была определена для использования в main.cpp
    std:: cout << g_gravity; 
    
    return 0;
}
```

### Связи функций
Функции имеют такие же свойства связи, что и переменные. По умолчанию они\
имеют внешнюю связь, которую можно сменить на внутреннюю с помощью\
ключевого слова `static`:
```c++
// Эта функция определена как static и может быть использована только внутри этого файла.
// Попытки доступа к ней через прототип функции будут безуспешными
static int add(int a, int b) {
return a + b;
}
```
Предварительные объявления функций не нуждаются в ключевом слове extern.

### Глобальные символьные константы
**constants.cpp:**
```c++
namespace Constants {
    // Фактические глобальные переменные
    extern const double pi(3.14159);
    extern const double avogadro(6.0221413e23);
    extern const double my_gravity(9.2);
}
```

**constants.h:**
```c++
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace Constants {
// Только предварительные объявления
extern const double pi;
extern const double avogadro;
extern const double my_gravity;
}

#endif
```

**Их использование в коде остается неизменным:**
```c++
#include "constants.h"

//...
double circumference = 2 * radius * Constants::pi;
//...
```
Теперь определение символьных констант выполняется только один раз (в\
constants.cpp). Любые изменения, сделанные в constants.cpp, потребуют\
перекомпиляции только (одного) этого файла.

Но есть и обратная сторона медали: такие константы больше не будут считаться\
константами типа `compile-time` и, поэтому, не смогут использоваться где-либо, где\
потребуется константа такого типа.

Поскольку глобальные символьные константы должны находиться в отдельном\
пространстве имен и быть доступными только для чтения, то использовать префикс\
`g_` уже не обязательно.

### Резюме

- Глобальные переменные имеют глобальную область видимости и могут\
  использоваться в любом месте программы. Подобно функциям, вы должны\
  использовать предварительные объявления (с ключевым словом extern),\
  чтобы использовать глобальную переменную, определенную в другом файле.
- По умолчанию, глобальные неконстантные переменные имеют внешнюю\
  связь. Вы можете использовать ключевое слово static, чтобы сделать их\
  внутренними.
- По умолчанию, глобальные константные переменные имеют внутреннюю\
  связь. Вы можете использовать ключевое слово extern, чтобы сделать их\
  внешними.
- Используйте префикс `g_` для идентификации ваших неконстантных\
  глобальных переменных.

### Тест
В чём разница между областью видимости, продолжительностью жизни и связью\
переменных? Какие типы продолжительности жизни, области видимости и связи\
имеют глобальные переменные?

- Область видимости определяет, где переменная доступна для\
  использования. Продолжительность жизни определяет, где переменная\
  создается и где уничтожается. Связь определяет, может ли переменная\
  использоваться в другом файле или нет.
- Глобальные переменные имеют глобальную область видимости (или\
  «файловую область видимости»), что означает, что они доступны из точки\
  объявления до конца файла, в котором объявлены.
- Глобальные переменные имеют статическую продолжительность жизни,\
  что означает, что они создаются при запуске программы и уничтожаются\
  при её завершении.
- Глобальные переменные могут иметь либо внутреннюю, либо внешнюю\
  связь (это можно изменить через использование ключевых слов static и\
  extern, соответственно).

## Урок №53. Почему глобальные переменные – зло?
### Почему (неконстантные) глобальные переменные — это зло?
Их значения могут изменять любые вызываемые функции, при этом вы можете этого и не знать:
```c++
#include <iostream>

// Объявление глобальной переменной
int g_mode;

void doSomething() {
    g_mode = 2; // присваиваем глобальной переменной g_mode значение 2
}

int main() {
    // Примечание: Здесь мы присваиваем глобальной переменной
    // g_mode значение 1. Это не объявление локальной переменной g_mode!
    g_mode = 1; 
    
    doSomething();
    
    // Программист по-прежнему ожидает, что g_mode будет 1.
    // Но функция doSomething() изменила значение этой переменной на 2!
    
    if (g_mode == 1)
        std::cout << "No threat detected.\n";
    else
        std::cout << "Launching nuclear missiles...\n";
    
    return 0;
}

<< Launching nuclear missiles...
```
**Правило: Вместо глобальных переменных используйте локальные (когда это целесообразно).**

### Резюме
Избегайте использования неконстантных глобальных переменных, насколько это\
возможно! Если же используете, то используйте их максимально разумно и\
осторожно.

## Урок №54. Статические переменные
Использование **ключевого слова** `static` с локальными переменными изменяет их\
свойство продолжительности жизни с автоматического на статическое (или\
"фиксированное"). **Статическая переменная** (или **«переменная со статической\
продолжительностью жизни»**) сохраняет свое значение даже после выхода из\
блока, в котором она определена. То есть она создается (и инициализируется)\
только один раз, а затем сохраняется на протяжении выполнения всей программы.
```c++
#include <iostream>

void incrementAndPrint() {
    static int s_value = 1; // переменная s_value является статической
    ++s_value;
    std::cout << s_value << std::endl;
} // переменная s_value не уничтожается здесь, но становится недоступной

int main() {
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();
    
    return 0;
}

<< 2
<< 3
<< 4
```
Поскольку переменная `s_value` объявлена статической (с помощью ключевого\
слова `static`), то она создается и инициализируется только один раз. Кроме того,\
выходя из области видимости, она не уничтожается. Каждый раз, при вызове\
функции `incrementAndPrint()`, значение `s_value` увеличивается.

Так же, как мы используем префикс `g_` с глобальными переменными, префикс `s_`\
принято использовать со статическими переменными. Обратите внимание,\
внутренние глобальные переменные (которые объявлены с использованием static)\
остаются с префиксом `g_`, а не с префиксом `s_`.

```c++
// присвоение каждому объекту отдельный уникальный идентификационный номер
int generateID() {
static int s_itemID = 0;
return s_itemID++;
}
```
`s_itemID` — это локальная переменная, то она не может быть «изменена» другими функциями

**Статические переменные** имеют некоторые преимущества глобальных переменных\
(они не уничтожаются до завершения программы), сохраняя при этом локальную\
область видимости. Таким образом, они намного безопаснее для использования,\
нежели глобальные переменные.

### Тест
Какой эффект от добавления ключевого слова static к глобальной переменной?\
Какое влияние оно имеет на локальную переменную?

Добавляя ключевое слово static к глобальной переменной, мы определяем её\
как внутреннюю, то есть такую, которую нельзя экспортировать и использовать в\
других файлах.\
В случае с локальной переменной, добавление static определяет её как\
статическую, то есть она создается и инициализируется только один раз, и не\
уничтожается до самого конца программы.

## Урок №55. Связи, область видимости и продолжительность жизни
### Область видимости
**Область видимости** идентификатора определяет, где он доступен для\
использования. К идентификатору, который находится вне области видимости,\
доступ закрыт.
- Переменные с **локальной/блочной областью видимости** доступны только в
  пределах блока, в котором они объявлены. Это:
  - локальные переменные;
  - параметры функции.
- Переменные с **глобальной/файловой областью видимости** доступны в
  любом месте файла. Это:
  - глобальные переменные.

### Продолжительность жизни
**Продолжительность жизни** переменной определяет, где она создается и где
уничтожается.
- Переменные с **автоматической продолжительностью жизни** создаются в\
  точке определения и уничтожаются при выходе из блока, в котором
  определены. Это:
  - обычные локальные переменные.
- Переменные **со статической продолжительностью жизни** создаются, когда\
  программа запускается, и уничтожаются при её завершении. Это:
  - глобальные переменные;
  - статические локальные переменные.
- Переменные с **динамической продолжительностью жизни** создаются и\
  уничтожаются по запросу программиста. Это:
  - динамические переменные (о них мы поговорим на соответствующем уроке).

### Связи
**Связь** идентификатора определяет, относятся ли несколько упоминаний одного\
идентификатора к одному и тому же идентификатору или нет.

- Идентификаторы **без связей** — это идентификаторы, которые ссылаются сами\
  на себя. Это:
  - обычные локальные переменные;
  - пользовательские типы данных, такие как enum, typedef и классы,\
    объявленные внутри блока (об этом детально поговорим на\
    соответствующих уроках).

- Идентификаторы с **внутренней связью** доступны в любом месте файла, в\
  котором они объявлены. Это:
  - статические глобальные переменные (инициализированные или неинициализированные);
  - константные глобальные переменные;
  - статические функции (о них поговорим чуть позже).

- Идентификаторы с **внешней связью** доступны как в любом месте файла, в\
  котором они объявлены, так и в других файлах (через предварительное\
  объявление). Это:
  - обычные функции;
  - неконстантные глобальные переменные (инициализированные или неинициализированные);
  - внешние константные глобальные переменные;
  - определяемые пользователем типы данных, такие как enum, typedef и\
    классы с глобальной областью видимости (о них мы поговорим чуть позже).

Идентификаторы с внешней связью могут вызвать ошибку дублирования\
определений, если определения скомпилированы в более чем одном файле .cpp.

Функции по умолчанию имеют внешнюю связь, что можно изменить с помощью\
ключевого слова static (на внутреннюю связь).

## Урок №56. Пространства имен
**Конфликт имен** возникает, когда два одинаковых идентификатора находятся в
одной области видимости, и компилятор не может понять, какой из этих двух
следует использовать в конкретной ситуации.

### Что такое пространство имен?
**Пространство имен** определяет область кода, в которой гарантируется
уникальность всех идентификаторов. По умолчанию, глобальные переменные и
обычные функции определены в **глобальном пространстве** имен.

Собственные пространства имен через **ключевое слово `namespace`**.
Всё, что объявлено внутри пользовательского пространства имен, —
принадлежит только этому пространству имен (а не глобальному).

**boo.h:**
```c++
namespace Boo {
    // Эта версия doOperation() принадлежит пространству имен Boo
  int doOperation(int a, int b) {
    return a + b;
  }   
}
```
**xoo.h:**
```c++
namespace Doo {
    // Эта версия doOperation() принадлежит пространству имен Doo
  int doOperation(int a, int b) {
    return a - b;
  }   
}
```
**main.cpp:**
```c++
#include <iostream>
#include "boo.h"
#include "doo.h"

int main() {
    std::cout << doOperation(5, 4);
    return 0;
}

<< error C2065: 'doOperation' : undeclared identifier
```
Существует два разных способа сообщить компилятору, какую версию `doOperation()`\
следует использовать: через оператор разрешения области видимости или с\
помощью using-стейтментов (следующий урок).

### Доступ к пространству имен через оператор разрешения области видимости (`::`)
Сообщим компилятору использовать версию `doOperation()` из пространства имен `Boo`:
```c++
#include <iostream>
#include "boo.h"
#include "doo.h"

int main(void) {
  std::cout << Boo::doOperation(5, 4);
  std::cout << Doo::doOperation(5, 4);
  return 0;
}

<< 9
<< 1
```
Также этот оператор можно использовать без какого-либо префикса (например,\
`::doOperation`). В таком случае мы ссылаемся на глобальное пространство имен.

### Пространства имен с одинаковыми названиями
Допускается объявление пространств имен в нескольких местах (либо в нескольких\
файлах, либо в нескольких местах внутри одного файла). Всё, что находится внутри\
одного блока имен, считается частью только этого блока.

**add.h:**
```c++
namespace DoMath {
    // Функция add() является частью пространства имен DoMath
    int add(int x, int y) {
        return x + y;
    }
}
```
**subtract.h:**
```c++
namespace DoMath {
    // Функция subtract() является частью пространства имен DoMath
    int subtract(int x, int y) {
        return x - y;
    }
}
```

**main.cpp:**
```c++
#include <iostream>
#include "add.h" // импортируем DoMath::add()
#include "subtract.h" // импортируем DoMath::subtract()

int main() {
    std::cout << DoMath::add(5, 4) << '\n';
    std::cout << DoMath::subtract(5, 4) << '\n';
    return 0;
}

<< 9
<< 1
```

### Псевдонимы и вложенные пространства имен
Одни пространства имен могут быть вложены в другие пространства имен:
```c++
#include <iostream>

namespace Boo {
    namespace Doo {
        const int g_x = 7;
    }
}

int main() {
    std::cout << Boo::Doo::g_x;
    return 0;
}
```
Поскольку Doo находится внутри Boo, то доступ к `g_x` осуществляется через `Boo::Doo::g_x`.

Так как это не всегда удобно и эффективно, то C++ позволяет создавать псевдонимы
для пространств имен:
```c++
#include <iostream>

namespace Boo {
    namespace Doo {
        const int g_x = 7;
    }
}

namespace Foo = Boo::Doo;  // Foo теперь считается как Boo::Doo

int main() {
    std::cout << Foo::g_x;  // это, на самом деле, Boo::Doo::g_x
    return 0;
}
```
**Вложенность пространств имен использовать не рекомендуется.**

## Урок №57. using-стейтменты
### Использование "using-объявления"
Строка using `std::cout;` сообщает компилятору, что мы будем использовать\
объект `cout` из пространства имен `std`. И каждый раз, когда компилятор будет\
сталкиваться с `cout`, он будет понимать, что это `std::cout`.
```c++
#include <iostream>

int main() {
  using std::cout; // «using-объявление» сообщает компилятору, что cout следует обрабатывать, как std::cout
  cout << "Hello, world!"; // и никакого префикса std:: уже здесь не нужно!
  return 0;
}
```

### Использование "using-директивы"
`using namespace std;` сообщает компилятору, что мы хотим использовать всё, \
что находится в пространстве имен `std`, так что, если компилятор найдет имя, \
которое не сможет распознать, он будет проверять его наличие в пространстве имен `std`.
```c++
#include <iostream>

int main() {
    // «using-директива» сообщает компилятору, что мы используем все объекты из пространства имен std!
  using namespace std; 
  cout << "Hello, world!"; // и никакого префикса std:: уже здесь не нужно!
  return 0;
}
```
**Совет: Старайтесь избегать использования "using-директивы" (насколько это возможно).**

### Пример конфликта c "using-директивой"
**Неверный способ:**
```c++
#include <iostream>

int cout() {  // объявляем нашу собственную функцию "cout"
    return 4;
}

int main() {
  // делаем std::cout доступным по "cout"  
  using namespace std;
  // какой cout компилятор здесь должен использовать? 
  cout << "Hello, world!"; 
  
  return 0;
}
```
**Верный способ:**
```c++
// Добавить префикс std:: к cout:
std::cout << "Hello, world!"; // сообщаем компилятору, что хотим использовать std::cout

// Использовать бы "using-объявление" вместо "using-директивы":
using std::cout; // сообщаем компилятору, что cout означает std::cout
cout << "Hello, world!"; // так что здесь следует использовать std::cou
```
**Правило: Никогда не используйте using-стейтменты вне тела функций.**

### Отмена/замена using-стейтментов
Как только один using-стейтмент был объявлен, его невозможно отменить или\
заменить другим using-стейтментом в пределах области видимости, в которой он\
был объявлен. Например:
```c++
int main() {
  using namespace Boo;
  // Отменить «использование пространства имен Boo» здесь невозможно!
  // Также нет никакого способа заменить «using namespace Boo» на другой using-стейтмент
  
  return 0;
} // действие using namespace Boo заканчивается здесь
```
Лучшее, что вы можете сделать — это намеренно ограничить область применения\
using-стейтментов с самого начала, используя правила локальной области видимости:
```c++
int main() {
  {
    using namespace Boo;
    // Здесь всё относится к пространству имен Boo::
  } // действие using namespace Boo заканчивается здесь
  
  {
    using namespace Foo;
    // Здесь всё относится к пространству имен Foo::
  } // действие using namespace Foo заканчивается здесь
  
  return 0;
}
```

## Урок №58. Неявное преобразование типов данных
### Преобразование типов
Процесс конвертации значений из одного типа данных в другой называется **преобразованием типов**.

Преобразование типов **может** выполняться в следующих случаях:
- Случай №1: Присваивание или инициализация переменной значением другого типа данных:
  ```c++
  double k(4)  // инициализация переменной типа double целым числом 4
  k = 7; // присваиваем переменной типа double целое число 7
  ```
- Случай №2: Передача значения в функцию, где тип параметра — другой:
  ```c++
  void doSomething(long l){
  }
  doSomething(4);  // передача числа 4 (тип int) в функцию с параметром типа long
  ```
- Случай №3: Возврат из функции, где тип возвращаемого значения — другой:
  ```c++
  float doSomething(){
    return 4.0;  // передача значения 4.0 (тип double) из функции, которая возвращает float
  }
  ```
- Случай №4: Использование бинарного оператора с операндами разных типов:
  ```c++
  double division = 5.0 / 4; // операция деления со значениями типов double и int
  ```

**Есть 2 основных способа преобразования типов:**
- **Неявное преобразование типов**, когда компилятор автоматически\
  конвертирует один фундаментальный тип данных в другой.
- **Явное преобразование типов**, когда разработчик использует один из\
  операторов явного преобразования для выполнения конвертации объекта из\
  одного типа данных в другой.

### Неявное преобразование типов
**Неявное преобразование типов** (или "автоматическое преобразование типов")\
выполняется всякий раз, когда требуется один фундаментальный тип данных, но\
предоставляется другой, и пользователь не указывает компилятору, как выполнить\
конвертацию (не использует явное преобразование типов через операторы явного\
преобразования).

Есть 2 основных способа неявного преобразования типов:
- числовое расширение;
- числовая конверсия.

### Числовое расширение
Когда значение из одного типа данных конвертируется в другой тип данных\
побольше (по размеру и по диапазону значений), то это называется **числовым\
расширением**:
```c++
long l(65); // расширяем значение типа int (65) в тип long
double d(0.11f); // расширяем значение типа float (0.11) в тип double
```

В языке C++ есть два варианта расширений:
- **Интегральное расширение** (или "целочисленное расширение"). Включает в\
  себя преобразование целочисленных типов, меньших, чем int (bool, char,\
  unsigned char, signed char, unsigned short, signed short) в int (если это\
  возможно) или unsigned int.
- **Расширение типа с плавающей точкой**. Конвертация из типа float в тип double.

**Важно: Числовые расширения всегда безопасны и не приводят к потере данных.**

### Числовые конверсии
Когда мы конвертируем значение из более крупного типа данных в аналогичный, но\
более мелкий тип данных, или конвертация происходит между разными типами\
данных, то это называется **числовой конверсией**.
```c++
double d = 4; // конвертируем 4 (тип int) в double
short s = 3; // конвертируем 3 (тип int) в short
```

В этом примере мы присвоили огромное целочисленное значение типа `int`\
переменной типа `char` (диапазон которого составляет от -128 до 127).\
Это приведет к переполнению и следующему результату:
```c++
#include <iostream>

int main() {
  int i = 30000;
  char c = i;
  std::cout << static_cast<int>(c);
  
  return 0;
}

<< 48
```

Однако, если число подходит по диапазону, конвертация пройдет успешно.
```c++
#include <iostream>

int main() {
  int i = 3;
  short s = i; // конвертируем значение типа int в тип short
  std::cout << s << std::endl;
  
  double d = 0.1234;
  float f = d; // конвертируем значение типа double в тип float
  std::cout << f << std::endl;
  
  return 0;
}

<< 3
<< 0.1234
```

В случаях со значениями типа с плавающей точкой могут произойти округления\
из-за худшей точности в меньших типах. Например:
```c++
#include <iostream>
#include <iomanip> // для std::setprecision()
int main() {
  float f = 0.123456789; // значение типа double - 0.123456789 имеет 9 значащих цифр, но float может хранить только 7
  std::cout << std::setprecision(9) << f; // std::setprecision определен в заголовочном файле iomanip
  
  return 0;
}

<< 0.123456791
```

`std::setprecision(n)` устанавливает параметр точности потока `out` или `in` равным `n`:
```c++
#include <numbers>
int main() {
    constexpr long double pi {std::numbers::pi_v<long double>};
    std::cout << std::setprecision(3) << pi << '\n';
    std::cout << std::setprecision(19) << pi << '\n';
    return 0;
}

<< 3.14
<< 3.141592653589793239
```

Конвертируя из `float` в `int`, любая дробь отбрасывается:
```c++
#include <iostream>

int main() {
    int i = 4.6;
    std::cout << i;
    
    return 0;
}

<< 4
```

### Обработка арифметических выражений
Оператор `typeid`, чтобы узнать решающий тип в выражении.
```c++
#include <iostream>
#include <typeinfo> // для typeid

int main() {
  short x(3);
  short y(6);
  std::cout << typeid(x + y).name() << " " << x + y << std::endl; // вычисляем решающий тип данных в выражении x + y
}

<< int 9
```

Здесь значение signed int (10) подвергается расширению в unsigned int (которое\
имеет более высокий приоритет), и выражение вычисляется как unsigned int. А\
поскольку unsigned — это только положительные числа, то происходит\
переполнение, и мы имеем то, что имеем:
```c++
#include <iostream>
int main()
{
  std::cout << 5u - 10; // 5u означает значение 5 типа unsigned int
  return 0;
}

<< 4294967291
```
Это одна из тех многих веских причин избегать использования типа unsigned int вообще.

## Урок №59. Явное преобразование типов данных
### Операторы явного преобразования типов данных
В языке C++ есть 5 видов **операций явного преобразования типов**:
- конвертация C-style;
- применение оператора static_cast;
- применение оператора const_cast;
- применение оператора dynamic_cast;
- применение оператора reinterpret_cast.

**Правило: Избегайте использования const_cast и reinterpret_cast, если у вас нет на
это веских причин.**

### Конвертация `C-style`
```c++
int i1 = 11;
int i2 = 3;
// т.к. i1 станет типа float, то i2 также затем автоматически преобразуется в тип float
float x = float(i1) / i2;
```
**Правило: Не используйте конвертацию C-style.**

### Оператор `static_cast`
Оператор `static_cast` лучше всего использовать для конвертации одного\
фундаментального типа данных в другой:
```c++
int i1 = 11;
int i2 = 3;
float x = static_cast<float>(i1) / i2;
```
Основным преимуществом оператора `static_cast` является проверка его выполнения\
компилятором во время компиляции, что усложняет возможность возникновения\
непреднамеренных проблем.

### Использование операторов явного преобразования в неявном преобразовании
Чтобы сообщить компилятору, что вы намеренно делаете что-то, что потенциально опасно,
используйте оператор `static_cast`:
```c++
int i = 49;
char ch = static_cast<char>(i);

int i = 90;
i = static_cast<int>(i / 3.6);
```

### Резюме
Преобразования типов данных следует избегать, если это вообще возможно,\
поскольку всякий раз, когда выполняется подобное изменение, есть вероятность\
возникновения непредвиденных проблем. Но очень часто случаются ситуации,\
когда этого не избежать. Поэтому в таких случаях лучше использовать оператор\
`static_cast` вместо конвертации `C-style`.

### Тест
В чём разница между явным и неявным преобразованием типов данных?

Неявное преобразование происходит, когда компилятор ожидает значение\
одного типа, но получает значение другого типа.

Явное преобразование происходит, когда программист использует оператор\
явного преобразования для конвертации значения из одного типа данных в\
другой.

## Урок №60. Введение в `std::string`
### Тип данных string
```c++
#include <iostream>
#include <string>

int main() {
    std::string name{"Kirill"};
    std::cout << name;
    return 0;
}

<< Kirill
```

**Ввод строк через `std::cin`:**
```c++
#include <iostream>
#include <string>

int main() {
  std::cout << "Enter your full name: ";
  std::string myName;
  // это будет работать не так, как ожидается, поскольку извлечение 
  // данных из потока std::cin останавливается на первом пробеле
  std::cin >> myName; 
  
  std::cout << "Enter your age: ";
  std::string myAge;
  std::cin >> myAge;
  
  std::cout << "Your name is " << myName << " and your age is " << myAge;
}

<< Enter your full name: 
>> Kirill Tarasov
<< Enter your age: Your name is Kirill and your age is Tarasov
```

### Использование `std::getline()`
`std::getline()` используется, чтобы извлечь полную строку из входного потока данных (вместе с пробелами).\
Она принимает два параметра: первый — `std::cin`, второй — переменная типа `string`.
```c++
#include <iostream>
#include <string>

int main() {
    std::cout << "Enter your full name: ";
    std::string myName;
    std::getline(std::cin, myName); // полностью извлекаем строку в переменную myName

    std::cout << "Enter your age: ";
    std::string myAge;
    std::getline(std::cin, myAge); // полностью извлекаем строку в переменную myAge
    std::cout << "Your name is " << myName << " and your age is " << myAge;

    return 0;
}

<< Enter your full name:
>> Kirill Tarasiv
<< Enter your age: 
>> 22
<< Your name is Kirill Tarasiv and your age is 22
```

### Использование `std::getline()` c `std::cin`
Когда вы вводите числовое значение, поток `cin` захватывает вместе с вашим числом и\
символ новой строки. Поэтому, когда мы ввели `2`, `cin` фактически получил `2\n`.\
Затем он извлек значение `2` в переменную, оставляя `\n` (символ новой строки) во\
входном потоке. Затем, когда `std::getline()` извлекает данные для `myName`, он видит\
в потоке `\n` и думает, что мы, должно быть, ввели просто пустую строку.
```c++
#include <iostream>
#include <string>

int main() {
    std::cout << "Pick 1 or 2: ";
    int choice;
    std::cin >> choice;

    std::cout << "Now enter your name: ";
    std::string myName;
    std::getline(std::cin, myName);

    std::cout << "Hello, " << myName << ", you picked " << choice << '\n';
    
    return 0;
}
<< Pick 1 or 2: 
>> 2
<< Now enter your name: Hello, , you picked 2
```

Хорошей практикой является удалять из входного потока данных символ новой\
строки. Это можно сделать следующим образом:
```c++
// 32767 вводится для пропуска определенного количества символов перед 
// указанным разделителем, в данном случае - символом новой строки "\n"
std::cin.ignore(32767, '\n');
```

Если мы вставим эту строку непосредственно после получения входных данных, то\
символ новой строки будет удален из входного потока, и программа будет работать\
должным образом:
```c++
#include <iostream>
#include <string>

int main() {
    std::cout << "Pick 1 or 2: ";
    int choice;
    std::cin >> choice;
    
    std::cin.ignore(32767, '\n'); // удаляем символ новой строки из входного потока данных
    
    std::cout << "Now enter your name: ";
    std::string myName;
    std::getline(std::cin, myName);

    std::cout << "Hello, " << myName << ", you picked " << choice << '\n';
    
    return 0;
}

<< Pick 1 or 2: 
>> 2
<< Now enter your name:
>> Kirill Tarasov
<< Hello, Kirill Tarasov, you picked 2
```

**Правило: При вводе числовых значений не забывайте удалять символ новой\
строки из входного потока данных с помощью `std::cin.ignore()`.**

### Добавление строк
Оператор `+` для объединения двух строк или оператор `+=` для добавления одной строки к другой.
```c++
#include <iostream>
#include <string>

int main() {
    std::string x("44");
    std::string y("12");
    
    std::cout << x + y << "\n"; // объединяем строки x и y (а не складываем числа)
    x += " cats";
    std::cout << x;

    return 0;
}

<< 4412
<< 44 cats
```

### Длина строк
Для определения длины строки используется метод `.length()`:
```c++
std::string myName{"Kirill"};
std::cout << myName.length();

<< 6
```

### Тест
Напишите программу, которая просит у пользователя ввести его имя, фамилию и\
возраст. В результате, укажите пользователю, сколько лет он прожил на каждую\
букву из его имени и фамилии (чтобы было проще, учитывайте также пробелы).

```c++
#include <iostream>
#include <string>

int main()
{
    std::cout << "Enter your full name: ";
    std::string myName;
    std::getline(std::cin, myName); // извлекаем целую строку из входного потока в переменную myName
    std::cout << "Enter your age: ";
    // переменная myAge должна быть типа int, а не типа string, чтобы мы могли проводить с ней арифметические операции
    int myAge; 
    std::cin >> myAge;
    int letters = myName.length(); // вычисляем длину переменной myName (учитывая пробелы)
    // используем оператор static_cast, чтобы изменить тип переменной myAge на double, 
    // дабы сохранить дробную часть при целочисленном делении
    double agePerLetter = static_cast<double>(myAge) / letters; 
    std::cout << "You've lived " << agePerLetter << " years for each letter in your name.\n";
    
    return 0;
}

<< Enter your full name: 
>> Kirill Tarasov
<< Enter your age: 
>> 22
<< Youve lived 1.57143 years for each letter in your name.
```

### Урок №61. Перечисления
#### Перечисляемые типы
**Перечисление** (или **"перечисляемый тип"**) — это тип данных, где любое значение
(или **"перечислитель"**) определяется как символьная константа. Объявить
перечисление можно с помощью **ключевого слова `enum`**. Например:
```c++
// Объявляем новое перечисление Colors
enum Colors {
    // Ниже находятся перечислители - все возможные значения этого типа данных
    // Каждый перечислитель отделяется запятой (НЕ точкой с запятой)
    COLOR_RED,
    COLOR_BROWN,
    COLOR_GRAY,
    COLOR_WHITE,
    COLOR_PINK,
    COLOR_ORANGE,
    COLOR_BLUE,
    COLOR_PURPLE, // конечная запятая разрешена
}; // однако сам enum должен заканчиваться точкой с запятой

// Определяем несколько переменных перечисляемого типа Colors
Colors paint = COLOR_RED;
Colors house(COLOR_GRAY); 
```

### Имена перечислений
Так как перечислители вместе с перечислением находятся в едином пространстве имен, то\
имена перечислителей не могут повторяться в разных перечислениях:

```c++
enum Colors {
    YELLOW,
    BLACK, // BLACK находится в глобальном пространстве имен
    PINK
};

enum Feelings {
    SAD,
    ANGRY,
    BLACK // получим ошибку, так как BLACK уже используется в enum Colors
}; 
```

### Значения перечислителей
Каждому перечислителю автоматически присваивается целочисленное значение в\
зависимости от его позиции в списке перечисления. По умолчанию, первому\
перечислителю присваивается целое число `0`, а каждому следующему — на\
единицу больше, чем предыдущему:
```c++
#include <iostream>

enum Colors {
    COLOR_YELLOW, // присваивается 0
    COLOR_WHITE, // присваивается 1
    COLOR_ORANGE, // присваивается 2
    COLOR_GREEN, // присваивается 3
    COLOR_RED, // присваивается 4
    COLOR_GRAY, // присваивается 5
    COLOR_PURPLE, // присваивается 6
    COLOR_BROWN // присваивается 7
};

int main() {
    Colors paint(COLOR_RED);
    std::cout << paint;
    
    return 0;
} 

<< 4
```

```c++
// Определяем новый перечисляемый тип Animals
enum Animals {
    ANIMAL_PIG = -4,
    ANIMAL_LION, // присваивается -3
    ANIMAL_CAT, // присваивается -2
    ANIMAL_HORSE = 6,
    ANIMAL_ZEBRA = 6, // имеет то же значение, что и ANIMAL_HORSE
    ANIMAL_COW // присваивается 7
}; 
```

**Совет: Не присваивайте свои значения перечислителям.**

**Правило: Не присваивайте одинаковые значения двум перечислителям в одном\
перечислении, если на это нет веской причины.**

### Обработка перечислений
Компилятор не будет неявно конвертировать целочисленное значение в значение\
перечислителя:
```c++
Animals animal = 7; // приведет к ошибке компиляции
```

Тем не менее, вы можете сделать подобное с помощью оператора `static_cast`:
```c++
Colors color = static_cast<Colors>(5); // но так делать не рекомендуется 
```

Компилятор также не позволит вам вводить перечислители через `std::cin`:
```c++
enum Colors {
    ...
};
int main() {
    Colors color;
    std::cin >> color; // приведет к ошибке компиляции
    
    return 0;
}
```

Однако, вы можете ввести целое число, а затем использовать оператор `static_cast`,\
чтобы поместить целочисленное значение в перечисляемый тип:
```c++
int inputColor; 
std::cin >> inputColor;

Colors color = static_cast<Colors>(inputColor); 
```

попытка присвоить перечислитель из одного перечисления перечислителю из\
другого — вызовет ошибку компиляции:
```c++
Animals animal = COLOR_BLUE; // приведет к ошибке компиляции
```

Как и в случае с константами, **перечисления отображаются в отладчике**, что делает\
их еще более полезными.

### Польза от перечислений
```c++
enum ParseResult {
    SUCCESS = 0,
    ERROR_OPENING_FILE = -1,
    ERROR_PARSING_FILE = -2,
    ERROR_READING_FILE = -3
};

ParseResult readFileContents() {
    if (!openFile())
        return ERROR_OPENING_FILE;
    if (!parseFile())
        return ERROR_PARSING_FILE;
    if (!readfile())
        return ERROR_READING_FILE;
    
    return SUCCESS; // если всё прошло успешно
}

int main() {
    if (readFileContents() == SUCCESS) {
        // Делаем что-нибудь
    }
    else {
        // Выводим сообщение об ошибке
    } 
}
```

```c++
#include <iostream>
#include <string>

enum ItemType {
    ITEMTYPE_GUN,
    ITEMTYPE_ARBALET,
    ITEMTYPE_SWORD
};

std::string getItemName(ItemType itemType) {
    if (itemType == ITEMTYPE_GUN)
        return std::string("Gun");
    if (itemType == ITEMTYPE_ARBALET)
        return std::string("Arbalet");
    if (itemType == ITEMTYPE_SWORD)
        return std::string("Sword");
}

int main() {
    // ItemType - это перечисляемый тип, который мы объявили выше.
    // itemType (с маленькой i) - это имя переменной, которую мы определяем ниже (типа ItemType).
    // ITEMTYPE_GUN - это значение перечислителя, которое мы присваиваем переменной itemType
    ItemType itemType(ITEMTYPE_GUN);
    
    std::cout << "You are carrying a " << getItemName(itemType) << "\n";
    
    return 0;
}

<< You are carrying a Gun
```

### Тест
**Задание №1.**\
Напишите перечисление со следующими перечислителями: `ogre`, `goblin`,\
`skeleton`, `orc` и `troll`.
```c++
enum MonsterType {
    MONSTER_OGRE,
    MONSTER_GOBLIN,
    MONSTER_SKELETON,
    MONSTER_ORC,
    MONSTER_TROLL
}; 
```

**Задание №2.**\
Объявите переменную перечисляемого типа, который вы определили в задании
№1, и присвойте ей значение ogre.
```c++
MonsterType eMonsterType = MONSTER_OGRE; 
```

**Задание №3 (сразу ответы).**\
Перечислителям можно:
- присваивать целочисленные значения;
- не присваивать значения; Перечислителю без значения будет неявно присвоено\
  целочисленное значение предыдущего перечислителя +1. Если\
  предыдущего перечислителя нет, то тогда присвоится значение 0.
- присваивать значения предыдущих перечислителей (например, COLOR_BLUE\
  = COLOR_GRAY). Поскольку значениями перечислителей являются целые числа, а\
  целые числа можно присвоить перечислителям, то одни перечислители\
  могут быть присвоены другим перечислителям (хотя этого лучше\
  избегать).

Перечислители могут быть:
- отрицательными;
- не уникальными.


## Урок №62. Классы enum
```c++
#include <iostream>

int main() {
    enum Fruits {
        LEMON, // LEMON находится внутри той же области видимости, что и Fruits
        KIWI    
    };
    
    enum Colors {
        PINK, // PINK находится внутри той же области видимости, что и Colors
        GRAY
    };
    
    Fruits fruit = LEMON; // Fruits и LEMON доступны в одной области видимости (добавлять префикс не нужно)
    Colors color = PINK; // Colors и PINK доступны в одной области видимости (добавлять префикс не нужно)
    
    if (fruit == color) // компилятор будет сравнивать эти переменные как целые числа
        std::cout << "fruit and color are equal\n"; // и обнаружит, что они равны!
    else
        std::cout << "fruit and color are not equal\n";
    
    return 0;
}

<< fruit and color are equal
```

Для решения этой проблемы в C++11 добавили **классы `enum`** (или **"перечисления с\
областью видимости"**), которые добавляют перечислениям, как вы уже могли\
понять, локальную область видимости со всеми её правилами. Для создания такого\
класса нужно просто добавить **ключевое слово `class`** сразу после enum.
```c++
#include <iostream>

int main() {
    enum class Fruits {
        LEMON, // LEMON находится внутри той же области видимости, что и Fruits
        KIWI    
    };
    
    enum class Colors {
        PINK, // PINK находится внутри той же области видимости, что и Colors
        GRAY
    };
    
    Fruits fruit = Fruits::LEMON; // LEMON напрямую не доступен, мы должны использовать Fruits::LEMON
    Colors color = Colors::PINK; // то же и тут
    
    if (fruit == color) // ошибка компиляции, поскольку компилятор не знает, как сравнивать разные типы: Fruits и Colors 
        std::cout << "fruit and color are equal\n";
    else
        std::cout << "fruit and color are not equal\n";
    
    return 0;
}

<< no known conversion for argument 2 from 'main()::Colors' to 'main()::Fruits'
```
Строгие правила типов классов enum означают, что каждый класс `enum` считается\
уникальным типом. Это означает, что компилятор не сможет сравнивать\
перечислители из разных перечислений. Если вы попытаетесь это сделать,\
компилятор выдаст ошибку.

## Урок №63. Псевдонимы типов: typedef и type alias
**Ключевое слово `typedef`** позволяет программисту создать псевдоним для любого\
типа данных и использовать его вместо фактического имени типа.
```c++
typedef double time_t; // используем time_t в качестве псевдонима для типа double

// Следующие два стейтмента эквивалентны
double howMuch;
time_t howMuch;
```
Обычно к псевдонимам typedef добавляют окончание `_t`, указывая, таким образом,\
что идентификатором является тип, а не переменная.

### `typedef` и читабельность кода
Мы видим, что возвращаемым значением является целое число, но что оно означает?
```c++
int GradeTest();
```

С использованием возвращаемого типа `testScore_t` становится очевидным, что\
функция возвращает тип, значением которого является результат теста:
```c++
typedef int testScore_t;
testScore_t GradeTest();
```

### `typedef` и поддержка кода
`typedef` также позволяет изменить базовый тип объекта без внесения изменений в\
большое количество кода. Например, если вы использовали тип `short` для хранения\
идентификационного номера учащегося, но потом решили, что лучше использовать\
тип `long`, с `typedef` же всё, что вам нужно сделать, — это изменить объявление\
`typedef short studentID_t` на `typedef long studentID_t`.

### `typedef` и кроссплатформенность
Поскольку `char`, `short`, `int` и `long` не указывают свой размер, то для\
кроссплатформенных программ довольно часто используется `typedef` для\
определения псевдонимов, которые включают размер типа данных в битах.\
Например, `int8_t` — это 8-битный `signed int`, `int16_t` — это 16-битный `signed int`, а\
`int32_t` — это 32-битный `signed int`.

### `typedef` и упрощение сложного
С помощью `typedef` вы можете давать простые имена сложным типам данных,\
что сделает их проще как для использования, так и для понимания.
```c++
// используем pairlist_t в качестве псевдонима для этого длиннющего типа данных
typedef std::vector<std::pair<std::string, int>> pairlist_t; 

pairlist_t pairlist; // объявляем pairlist_t

boolean hasAttribute(pairlist_t pairlist) // используем pairlist_t в качестве типа параметра функции
{
// Что-то делаем
}
```

### `type alias`
С помощью `type alias` мы пишем имя, которое затем используется как\
синоним конкретного типа данных (т.е. принцип тот же, но синтаксис более удобен):
```c++
typedef double time_t; // используем time_t в качестве псевдонима для типа double

using time_t = double; // используем time_t в качестве псевдонима для типа double
```
**Правило: Используйте type alias вместо typedef, если ваш компилятор
поддерживает C++11.**

### Тест

**Задание №1.**\
Используя следующий прототип функции:\
`int editData();`\
Преобразуйте тип возвращаемого значения `int` в `status_t`, используя ключевое слово\
`typedef`.

```c++
typedef int status_t;
status_t editData();
```

**Задание №2.**\
Используя прототип функции из задания №1, преобразуйте тип возвращаемого\
значения `int` в `status_t`, используя ключевое слово `using` (C++11).

```c++
using status_t = int;
status_t editData();
```

## Урок №64. Структуры
**Структура позволяет сгруппировать переменные разных типов в единое целое.**

### Объявление и определение структур
```c++
struct Employee {
    short id;  // член (поле) структуры
    int age;
    double salary;
};

Employee john;
Employee james;
```

### Доступ к членам структур
```c++
Employee john; // создаем отдельную структуру Employee для John-а
john.id = 8; // присваиваем значение члену id структуры john
john.age = 27; // присваиваем значение члену age структуры john
john.salary = 32.17; // присваиваем значение члену salary структуры john

Employee james; // создаем отдельную структуру Employee для James-а
james.id = 9; // присваиваем значение члену id структуры james
james.age = 30; // присваиваем значение члену age структуры james
james.salary = 28.35; // присваиваем значение члену salary структуры james
```

### Инициализация структур
**Список инициализаторов:**
```c++
struct Employee {
    short id;
    int age;
    double salary;
};

// Так:
Employee john = { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
// Или так (uniform-инициализация):
Employee james{6, 29}; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)
```

### C++11/14: Инициализация нестатических членов структур
В C++11 добавили возможность присваивать нестатическим (обычным) членам\
структуры значения по умолчанию. Например:
```c++
#include <iostream>

struct Triangle {
    double length = 2.0;
    double width = 2.0;
};

int main() {
    Triangle z; // длина = 2.0, ширина = 2.0
    z.length = 3.0; // вы также можете присваивать членам структуры и другие значения
    
    Triangle b{ 3.0, 3.0 }; // uniform-инициализация также доступна
    return 0;
}
```

### Структуры и функции
Большим преимуществом использования структур является возможность передать всю структуру\
в функцию, которая должна работать с её членами:
```c++
#include <iostream>

struct Employee {
    short id;
    int age;
    double salary;
};

void printInformation(Employee employee) {
    std::cout << "ID: " << employee.id << "\n";
    std::cout << "Age: " << employee.age << "\n";
    std::cout << "Salary: " << employee.salary << "\n";
}

int main() {
    Employee john = { 21, 27, 28.45 };
    Employee james = { 22, 29, 19.29 };
    
    // Выводим информацию о John-е
    printInformation(john);
    std::cout << "\n";
    
    // Выводим информацию о James-е
    printInformation(james);
    
    return 0;
}

<< ID: 21
<< Age: 27
<< Salary: 28.45
<< ID: 22
<< Age: 29
<< Salary: 19.29
```

Функция также может возвращать структуру:
```c++
#include <iostream>

struct Point3d {
    double x;
    double y;
    double z;
};

Point3d getZeroPoint() {
    Point3d temp = { 0.0, 0.0, 0.0 };
    return temp;
}

int main() {
    Point3d zero = getZeroPoint();
    
    if (zero.x == 0.0 && zero.y == 0.0 && zero.z == 0.0)
        std::cout << "The point is zero\n";
    else
        std::cout << "The point is not zero\n";
    
    return 0;
}

<< The point is zero
```

### Вложенные структуры
```c++
#include <iostream>

struct Employee {
    short id;
    int age;
    double salary;
};

struct Company {
    Employee CEO; // Employee - это структура внутри структуры Company
    int numberOfEmployees;
};

int main() {
    Company myCompany = {{ 3, 35, 55000.0f }, 7 };
    std::cout << myCompany.CEO.salary;

    return 0;
}

<< 55000
```

### Размер структур
На большинстве платформ тип `short` занимает 2 байта, тип `int` — 4 байта, а тип `double` — 8 байт.\
Следовательно, ожидается, что `Employee` будет занимать 2 + 4 + 8 = 14 байт. Чтобы узнать\
точный размер `Employee`, мы можем воспользоваться оператором `sizeof`:
```c++
#include <iostream>

struct Employee {
    short id;
    int age;
    double salary;
};

int main() {
    std::cout << "The size of Employee is " << sizeof(Employee) << "\n";
    
    return 0;
}

<< The size of Employee is 16
```
Оказывается, мы можем сказать только, что размер структуры будет, _по крайней\
мере_, не меньше суммы размеров всех её членов. По соображениям производительности\
компилятор иногда может добавлять "пробелы/промежутки" в структуры.

### Тест
**Задание №1**
У вас есть веб-сайт и вы хотите отслеживать, сколько денег вы зарабатываете в день\
от размещенной на нем рекламы. Объявите структуру `Advertising`, которая будет\
отслеживать:
* сколько объявлений вы показали посетителям (1);
* сколько процентов посетителей нажали на объявления (2);
* сколько вы заработали в среднем за каждое нажатие на объявления (3).

Значения этих трех полей должен вводить пользователь. Передайте структуру\
`Advertising` в функцию, которая выведет каждое из этих значений, а затем
подсчитает, сколько всего денег вы заработали за день (перемножьте все 3 поля).

```c++
#include <iostream>

// Сначала объявляем структуру Advertising
struct Advertising {
    int adsShown;
    double clickThroughRatePercentage;
    double averageEarningsPerClick;
};

void printAdvertising(Advertising ad) {
    using namespace std;
    cout << "Number of ads shown: " << ad.adsShown << endl;
    cout << "Click through rate: " << ad.clickThroughRatePercentage << endl;
    cout << "Average earnings per click: $" << ad.averageEarningsPerClick << endl;
    // Следующая строка кода разбита из-за своей длины.
    // Мы делим ad.clickThroughRatePercentage на 100, так как пользователь указывает проценты, а не готовое число
    cout << "Total Earnings: $" <<
         (ad.adsShown * ad.clickThroughRatePercentage / 100 *
          ad.averageEarningsPerClick) << endl;
}
int main() {
    using namespace std;
    // Объявляем переменную структуры Advertising
    Advertising ad{};
    cout << "How many ads were shown today? ";
    cin >> ad.adsShown;
    cout << "What percentage of users clicked on the ads? ";
    cin >> ad.clickThroughRatePercentage;
    cout << "What was the average earnings per click? ";
    cin >> ad.averageEarningsPerClick;
    printAdvertising(ad);
    
    return 0;
}

<< How many ads were shown today? 200
<< What percentage of users clicked on the ads? 45
<< What was the average earnings per click? 2
<< Number of ads shown: 200
<< Click through rate: 45
<< Average earnings per click: $2
<< Total Earnings: $180

```

**Задание №2**
Создайте структуру для хранения дробных чисел. Структура должна иметь 2 члена:\
целочисленный числитель и целочисленный знаменатель. Объявите две дробные\
переменные и получите их значения от пользователя. Напишите функцию `multiply()`\
(параметрами которой будут эти две переменные), которая будет перемножать эти\
числа и выводить результат в виде десятичного числа.

```c++
#include <iostream>

struct Fractional {
    int numerator;
    int denominator;
};

void multiply(Fractional d1, Fractional d2) {
    using namespace std;
    // Не забываем об операторе static_cast, иначе компилятор выполнит целочисленное деление!
    cout << static_cast<float>(d1.numerator * d2.numerator) /
            (d1.denominator * d2.denominator);
}

int main() {
    using namespace std;
    // Определяем первую переменную-дробь
    Fractional d1{};
    cout << "Input the first numerator: ";
    cin >> d1.numerator;
    cout << "Input the first denominator: ";
    cin >> d1.denominator;

    // Определяем вторую переменную-дробь
    Fractional d2{};
    cout << "Input the second numerator: ";
    cin >> d2.numerator;
    cout << "Input the second denominator: ";
    cin >> d2.denominator;
    multiply(d1, d2);

    return 0;
}

<< Input the first numerator: 12
<< Input the first denominator: 5
<< Input the second numerator: 14
<< Input the second denominator: 3
<< 11.2
```

## Урок №65. Вывод типов: ключевое слово auto
Начиная с C++11, **ключевое слово `auto`** при инициализации переменной может\
использоваться вместо типа переменной, чтобы сообщить компилятору, что он\
должен присвоить тип переменной исходя из инициализируемого значения. Это\
называется **выводом типа** (или **"автоматическим определением типа данных\
компилятором"**).
```c++
auto x = 4.0; // 4.0 - это литерал типа double, поэтому и x должен быть типа double
auto y = 3 + 4; // выражение 3 + 4 обрабатывается как целочисленное, поэтому и переменная y должна быть типа int
```

В C++14 функционал ключевого слова auto был расширен до автоматического\
определения типа возвращаемого значения функции. Хотя это может показаться\
удобным, так делать не рекомендуется:
```c++
auto subtract(int a, int b) {
    return a - b;
}

int main() {
    auto result = subtract(4, 3); 
    return 0;
}
```
**Обратите внимание, это работает только с инициализированными переменными.**

### trailing-синтаксис в C++11
**Синтаксис типа возвращаемого значения `trailing` (или просто "trailing-синтаксис")**
```c++
// Обычное объявление функции:
int subtract(int a, int b);

// В C++11 это можно записать как:
auto subtract(int a, int b) -> int;
```

```c++
auto subtract(int a, int b) -> int;
auto divide(double a, double b) -> double;
auto printThis() -> void;
auto calculateResult(int a, double x) -> std::string;
```

### Резюме
Начиная с C++11 ключевое слово `auto` может использоваться вместо типа\
переменной при инициализации для выполнения вывода типа. Во всех других\
случаях использования ключевого слова auto следует избегать, если на это нет\
веских причин.

## Глава №4. Итоговый тест
### Теория
**Блок стейтментов** (или **"составной оператор"**) обрабатывается компилятором так,\
как если бы это был один стейтмент. Составные операторы помещаются в фигурные\
скобки `{` и `}` и используются почти везде.

**Локальные переменные** создаются в точке определения и уничтожаются при\
выходе из блока, в котором они объявлены. Доступ к ним возможен только внутри\
этого же блока.

**Глобальные переменные** создаются, когда программа запускается, и\
уничтожаются, когда она завершает свое выполнение. Они могут использоваться в\
любом месте программы. Неконстантные глобальные переменные следует\
избегать, потому что это — зло.

**Ключевое слово `static`** может использоваться для преобразования глобальной\
переменной во внутреннюю (с внутренней связью), чтобы её можно было\
использовать только в том файле, в котором она объявлена. Также ключевое слово\
`static` используют для указания того, что локальная переменная должна иметь\
статическую продолжительность жизни. А это означает, что она будет сохранять\
свое значение даже после выхода из своей области видимости.

**Пространство имен** — это область, в которой гарантируется уникальность всех\
имен. Отличный способ избежать конфликтов имен. Не используйте using-\
стейтменты вне тела функций.

**Неявное преобразование типов данных** происходит, когда один тип данных\
конвертируется в другой тип без использования одного из операторов явного\
преобразования. Явное преобразование типа происходит, когда один тип данных\
конвертируется в другой с помощью одного из операторов явного преобразования.\
В некоторых случаях это абсолютно безопасно, в других случаях данные могут быть\
потеряны. Избегайте использования конвертации `C-style`, вместо нее используйте\
оператор `static_cast`.

`std::string` — это простой способ работы с текстовыми строками (текст помещается в\
двойные кавычки).

**Перечисления** позволяют создавать собственные (пользовательские) типы данных.\
**Классы enum** — это те же перечисления, но надежнее и безопаснее. Используйте их\
вместо обычных перечислений, если ваш компилятор поддерживает C++11.

`typedef` позволяет создавать псевдонимы для типов данных. Целочисленные типы\
данных с фиксированным размером реализованы с помощью `typedef`. Псевдонимы\
типов полезны для присваивания простых имен сложным типам данных.

И, наконец, **структуры**. Они позволяют сгруппировать отдельные переменные в\
единое целое. Доступ к членам структуры осуществляется через оператор выбора\
членов (`.`). Объектно-ориентированное программирование в значительной степени\
основывается именно на структурах, поэтому, если вы изучили только одну вещь из\
этой главы, то лучше, чтобы это были структуры.

### Тест
При разработке игры мы решили, что в ней должны быть монстры, потому что всем\
нравится сражаться с монстрами. Объявите структуру, которая представляет вашего\
монстра. Монстр может быть разным: `ogre`, `goblin`, `skeleton`, `orc` и `troll`. Если\
ваш компилятор поддерживает C++11, то используйте классы `enum`, если нет —\
обычные перечисления.

Каждый монстр также должен иметь имя (используйте `std::string`) и количество\
здоровья, которое отображает, сколько урона он может получить, прежде чем\
умрет. Напишите функцию `printMonster()`, которая выведет все члены структуры.\
Объявите монстров типа `goblin` и `orc`, инициализируйте их, используя список\
инициализаторов, и передайте в функцию `printMonster()`.

Пример результата выполнения вашей программы:\
`This Goblin is named John and has 170 health.`\
`This Orc is named James and has 35 health.`

```c++
#include <iostream>
#include <string>

// Определяем класс enum с типами монстров
enum class MonsterType {
    OGRE,
    GOBLIN,
    SKELETON,
    ORC,
    TROLL
};

// Наша структура представляет одного монстра
struct Monster {
    MonsterType type;
    std::string name;
    int health;
};

// Возвращаем тип монстра в виде строки
std::string getMonsterTypeString(Monster monster) {
    if (monster.type == MonsterType::OGRE)
        return "Ogre";
    if (monster.type == MonsterType::GOBLIN)
        return "Goblin";
    if (monster.type == MonsterType::SKELETON)
        return "Skeleton";
    if (monster.type == MonsterType::ORC)
        return "Orc";
    if (monster.type == MonsterType::TROLL)
        return "Troll";
    return "Unknown";
}

// Выводим информацию о монстре
void printMonster(Monster monster) {
    std::cout << "This " << getMonsterTypeString(monster);
    std::cout << " is named " << monster.name << " and has "<< monster.health
              << " health.\n";
}

int main() {
    Monster goblin { MonsterType::GOBLIN, "John", 170 };
    Monster orc { MonsterType::ORC, "James", 35 };
    printMonster(goblin);
    printMonster(orc);

    return 0;
}

<< This Goblin is named John and has 170 health.
<< This Orc is named James and has 35 health.
```