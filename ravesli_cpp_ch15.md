# Глава №15. Умные указатели и Семантика перемещения в C++
## Содержание
1. [Урок №197. Умные указатели и Семантика перемещения](#урок-197-умные-указатели-и-семантика-перемещения)
2. [Урок №198. Ссылки r-value](#урок-198-ссылки-r-value)
3. [Урок №199. Конструктор перемещения и Оператор присваивания перемещением](#урок-199-конструктор-перемещения-и-оператор-присваивания-перемещением)

## [Урок №197. Умные указатели и Семантика перемещения](#урок-197-умные-указатели-и-семантика-перемещения)
```c++
#include <iostream>

template<class T>
class Auto_ptr1 {
    T *m_ptr;
public:
    // Получаем указатель для "владения" через конструктор
    explicit Auto_ptr1(T *ptr = nullptr) : m_ptr(ptr) {}

    // Деструктор позаботится об удалении указателя
    ~Auto_ptr1() { delete m_ptr; }

    // Выполняем перегрузку оператора разыменования и оператора ->, 
    // чтобы иметь возможность использовать Auto_ptr1 как m_ptr
    T &operator*() const { return *m_ptr; }
    T *operator->() const { return m_ptr; }
};

// Класс для проверки работоспособности вышеприведенного кода
class Item {
public:
    Item() { std::cout << "Item acquired\n"; }
    ~Item() { std::cout << "Item destroyed\n"; }
};

int main() {
    Auto_ptr1<Item> item(new Item); // динамическое выделение памяти
    // ... но никакого явного delete здесь не нужно
    // Также обратите внимание на то, что Item-у в угловых скобках не требуется символ *, 
    // поскольку это предоставляется шаблоном класса
    return 0;
} // item выходит из области видимости здесь и уничтожает выделенный Item вместо нас

// Item acquired
// Item destroyed
```

Рассмотрим детально, как работают эти программа и класс. Сначала мы\
динамически выделяем объект класса `Item` и передаем его в качестве параметра\
нашему шаблону класса `Auto_ptr1`. С этого момента объект `item` класса `Auto_ptr1`\
владеет выделенным объектом класса `Item` (`Auto_ptr1` имеет композиционную\
связь с `m_ptr`). Поскольку `item` объявлен в качестве локальной переменной и\
имеет область видимости блока, он выйдет из области видимости после\
завершения выполнения блока, в котором находится, и будет уничтожен. А\
поскольку это объект класса, то при его уничтожении будет вызван деструктор\
`Auto_ptr1`. Этот деструктор и обеспечит удаление указателя `Item`, который он\
хранит!

До тех пор, пока объект класса `Auto_ptr1` определен как локальная переменная (с\
автоматической продолжительностью жизни, отсюда и часть «Auto» в имени\
класса), `Item` гарантированно будет уничтожен в конце блока, в котором он\
объявлен, независимо от того, как этот блок (функция `main()`) завершит свое\
выполнение (досрочно или нет).

**Умный указатель** — это класс, предназначенный для управления динамически\
выделенной памятью и обеспечения освобождения (удаления) выделенной памяти\
при выходе объекта этого класса из области видимости.

```c++
#include <iostream>

template<class T>
class Auto_ptr1 {
    T* m_ptr;
public:
    // Получаем указатель для "владения" через конструктор
    explicit Auto_ptr1(T* ptr=nullptr) :m_ptr{ptr} {}

    // Деструктор позаботится об удалении указателя
    ~Auto_ptr1() { delete m_ptr; }

    // Выполняем перегрузку оператора разыменования и оператора ->,
    // чтобы иметь возможность использовать Auto_ptr1 как m_ptr
    T& operator*() const { return *m_ptr; }
    T* operator->() const { return m_ptr; }
};

// Класс для проверки работоспособности вышеприведенного кода
class Item {
public:
    Item() { std::cout << "Item acquired\n"; }
    ~Item() { std::cout << "Item destroyed\n"; }
    static void sayHi() { std::cout << "Hi!\n"; }
};

void myFunction() {
    Auto_ptr1<Item> ptr(new Item); // ptr теперь "владеет" Item-ом

    int a;
    std::cout << "Enter an integer: ";
    std::cin >> a;

    if (a == 0)
        return; // досрочный возврат функции

    // Использование ptr
    ptr->sayHi();
}

int main() {
    myFunction();

    return 0;
}

// если ненулевое значение
// Item acquired
// Enter an integer: 7
// Hi!
// Item destroyed

// ноль
// Item acquired
// Enter an integer: 0
// Item destroyed
```

Поскольку переменная `ptr` является локальной переменной, то она уничтожается\
при завершении выполнения функции (независимо от того, как это будет сделано:\
досрочно или нет). И поскольку деструктор `Auto_ptr1` выполняет очистку `Item`, то мы\
можем быть уверены, что `Item` будет корректно удален.

### Критический недостаток
```c++
int main() {
    Auto_ptr1<Item> item1(new Item);
    Auto_ptr1<Item> item2(item1); // поверхностное копирование, так как нет своего конструктора

    return 0;
}

// Item acquired
// Item destroyed
// Item destroyed
```

Когда мы инициализируем `item2` значением `item1`, оба объекта класса `Auto_ptr1` указывают\
на один и тот же `Item`. Когда `item2` выходит из области видимости, он удаляет `Item`,\
оставляя `item1` с висячим указателем. Когда же `item1` отправляется на удаление\
своего (уже удаленного) `Item`, происходит «Бум!».

```c++
void passByValue(Auto_ptr1<Item> item) {}

int main() {
    Auto_ptr1<Item> item1(new Item);
    passByValue(item1);

    return 0;
}
// та же ситуация, что и выше
```

В этой программе `item1` передается по значению в параметр `item` функции\
`passByValue()`, что приведет к дублированию указателя `Item`.

### Семантика перемещения
**Семантика перемещения** означает, что класс, вместо копирования, передает право\
собственности на объект.

```c++
#include <iostream>

template<class T>
class Auto_ptr2 {
    T *m_ptr;
public:
    explicit Auto_ptr2(T *ptr = nullptr) : m_ptr{ptr} {}

    ~Auto_ptr2() { delete m_ptr; }

    // Конструктор копирования, который реализовывает семантику перемещения
    Auto_ptr2(Auto_ptr2 &a) { // примечание: Ссылка не является константной
        m_ptr = a.m_ptr; // перемещаем наш глупый указатель от источника к нашему локальному объекту
        a.m_ptr = nullptr; // подтверждаем, что источник больше не владеет указателем
    }

    // Оператор присваивания, который реализовывает семантику перемещения
    Auto_ptr2 &operator=(Auto_ptr2 &a) { // примечание: Ссылка не является константной
        if (&a == this)
            return *this;

        delete m_ptr; // подтверждаем, что удалили любой указатель, который наш локальный объект имел до этого
        m_ptr = a.m_ptr; // затем перемещаем наш глупый указатель из источника к нашему локальному объекту
        a.m_ptr = nullptr; // подтверждаем, что источник больше не владеет указателем
        return *this;
    }

    T &operator*() const { return *m_ptr; }
    T *operator->() const { return m_ptr; }
    bool isNull() const { return m_ptr == nullptr; }
};

class Item {
public:
    Item() { std::cout << "Item acquired\n"; }
    ~Item() { std::cout << "Item destroyed\n"; }
};

int main() {
    Auto_ptr2<Item> item1(new Item); // Item acquired
    Auto_ptr2<Item> item2; // начнем с nullptr

    std::cout << "item1 is " << (item1.isNull() ? "null\n" : "not null\n"); // item1 is not null
    std::cout << "item2 is " << (item2.isNull() ? "null\n" : "not null\n"); // item2 is null

    item2 = item1; // item2 теперь является "владельцем" значения item1, объекту item1 присваивается null

    std::cout << "Ownership transferred\n";
    std::cout << "item1 is " << (item1.isNull() ? "null\n" : "not null\n"); // item1 is null
    std::cout << "item2 is " << (item2.isNull() ? "null\n" : "not null\n"); // item2 is not null
    
    return 0;
    // Item destroyed
}
```

Обратите внимание, перегруженный `operator=` передает право собственности на\
`m_ptr` от `item1` к `item2`! Следовательно, у нас не выполняется дублирования\
указателей, и всё аккуратно очищается (удаляется).

### `std::auto_ptr` и почему его лучше не использовать
> <picture>
>   <source media="(prefers-color-scheme: light)" srcset="https://raw.githubusercontent.com/Mqxx/GitHub-Markdown/main/blockquotes/badge/light-theme/warning.svg">
>   <img alt="Warning" src="https://raw.githubusercontent.com/Mqxx/GitHub-Markdown/main/blockquotes/badge/dark-theme/warning.svg">
> </picture><br>
>
> <b>Правило: `std::auto_ptr` устарел и не должен использоваться. Используйте вместо\
> него `std::unique_ptr` или `std::shared_ptr`.</b>

## [Урок №198. Ссылки r-value](#урок-198-ссылки-r-value)
### l-values и r-values
Каждое выражение в языке C++ имеет два свойства: **тип** и **категорию значения**.

О **l-value** проще всего думать, как о функции, объекте или переменной (или\
выражении, результатом которого является функция, объект или переменная),\
которая имеет свой адрес памяти.\
**l-values** разделены на две подкатегории:
* Модифицируемые l-values, которые можно изменить (например, переменной\
  `x` можно присвоить другое значение).
* Немодифицируемые l-values, которые являются `const` (например, константа `PI`).

О **r-value** проще всего думать, как «обо всем остальном, что не является l-value». Это\
литералы (например, `5`), временные значения (например, `x + 1`) и анонимные\
объекты (например, `Fraction(7, 3)`). r-values имеют область видимости\
выражения (уничтожаются в конце выражения, в котором находятся) и им нельзя\
что-либо присвоить.

Для поддержки семантики перемещения в C++11 ввели **3 новые категории\
значений**:
1. `pr-values`;
2. `x-values`;
3. `gl-values`.

### Ссылки l-value
**Ссылки l-value могут быть инициализированы только изменяемыми l-values.**

**Ссылки l-value на константные объекты могут быть инициализированы с помощью\
как l-values, так и r-values.**

### Ссылки r-value
**Ссылки r-value** - это ссылки, которые инициализируются только значениями r-values.

```c++
int x = 7;
int &lref = x; // инициализация ссылки l-value переменной x (значение l-value)
int &&rref = 7; // инициализация ссылки r-value литералом 7 (значение r-value)
```

**Ссылки r-value не могут быть инициализированы значениями l-values.**

Ссылки r-value имеют **два полезных свойства**:
1. Они увеличивают продолжительность жизни объекта, которым\
   инициализируются, до продолжительности жизни ссылки r-value (ссылки l-\
   value на константные объекты также могут это делать).
2. Неконстантные ссылки r-value позволяют нам изменять значения r-values, на\
   которые указывают ссылки r-value!

```c++
#include <iostream>

class Fraction {
private:
    int m_numerator;
    int m_denominator;

public:
    explicit Fraction(int numerator = 0, int denominator = 1) :
            m_numerator(numerator), m_denominator(denominator) {}

    friend std::ostream &operator<<(std::ostream &out, const Fraction &f1) {
        out << f1.m_numerator << "/" << f1.m_denominator;
        return out;
    }
};

int main() {
    Fraction &&rref = Fraction(4, 7); // ссылка r-value на анонимный объект класса Fraction
    std::cout << rref << '\n'; // 4/7

    return 0;
} // rref (и анонимный объект класса Fraction) выходит из области видимости здесь
```

Создаваемый анонимный объект `Fraction(4, 7)` обычно вышел бы из области\
видимости в конце выражения, в котором он определен. Однако, так как мы\
инициализируем ссылку r-value этим анонимным объектом, то его\
продолжительность жизни увеличивается до продолжительности жизни самой\
ссылки r-value, т.е. до конца функции `main()`. Затем мы используем ссылку r-value\
для вывода значения анонимного объекта класса `Fraction`.

```c++
#include <iostream>

int main() {
    int &&rref = 7; // поскольку мы инициализируем ссылку r-value литералом 7,
    // то создается временный объект со значением 7, на который указывает ссылка r-value
    rref = 12;
    std::cout << rref; // 12

    return 0;
}
```

Хотя это может показаться странным, но при инициализации ссылки r-value\
литералом, создается временный объект, на который ссылается ссылка r-value (она\
не ссылается на сам литерал).

### Ссылки r-value в качестве параметров функции
Ссылки r-value чаще всего используются в качестве параметров функции. Это\
наиболее полезно при перегрузке функций, когда вы хотите, чтобы выполнение\
функции отличалось в зависимости от аргументов (l-values или r-values):
```c++
#include <iostream>

void fun(const int &lref) { // перегрузка функции для работы с аргументами l-values
    std::cout << "l-value reference to const\n";
}

void fun(int &&rref) { // перегрузка функции для работы с аргументами r-values
    std::cout << "r-value reference\n";
}

int main() {
    int x = 7;
    fun(x); // аргумент l-value вызывает функцию с ссылкой l-value - l-value reference to const
    fun(7); // аргумент r-value вызывает функцию с ссылкой r-value - r-value reference

    return 0;
}
```

### Возврат ссылки r-value
Вы почти никогда **не должны возвращать ссылку r-value из функции** по той же\
причине, по которой вы почти никогда не должны возвращать ссылку l-value из\
функции. В большинстве случаев вы возвратите висячую ссылку (указывающую на\
удаленную память), а объект, на который будет ссылаться ссылка, выйдет из\
области видимости в конце функции.

### Тест
```c++
int main() {
    int x;

    // Ссылки l-value
    int &ref1 = x; // A
    int &ref2 = 7; // B - не скомпилируется

    const int &ref3 = x; // C
    const int &ref4 = 7; // D

    // Ссылки r-value
    int &&ref5 = x; // E - не скомпилируется
    int &&ref6 = 7; // F

    const int &&ref7 = x; // G - не скомпилируется
    const int &&ref8 = 7; // H

    return 0;
}
```

## [Урок №199. Конструктор перемещения и Оператор присваивания перемещением](#урок-199-конструктор-перемещения-и-оператор-присваивания-перемещением)