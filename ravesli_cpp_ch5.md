# Глава №5.
## Урок №66. Операторы управления потоком выполнения программ
### Остановка
```c++
#include <iostream>
#include <cstdlib> // для функции exit()

int main() {
    std::cout << 5;
    exit(0); // завершаем выполнение программы и возвращаем 0 обратно в операционную систему
    
    // Следующие стейтменты никогда не выполнятся
    std::cout << 3;
    
    return 0;
}
```

### Прыжок
Следующим оператором управления порядком выполнения программы является\
**прыжок** (или **"переход"**). Он безоговорочно сообщает компилятору во время\
выполнения перейти от одного стейтмента к другому, т.е. выполнить прыжок.\
**Ключевые слова `goto`, `break` и `continue`** являются разными типами прыжков.

### Условные ветвления
**Условное ветвление** заставляет программу изменить свой порядок выполнения,\
основываясь на значении результата выражения.\
**Ключевое слово switch** также предоставляет механизм для выполнения условного\
ветвления.

### Циклы
**Цикл** заставляет программу многократно выполнять определенное количество\
стейтментов до тех пор, пока заданное условие не станет ложным.

**В языке C++ есть 4 типа циклов:**
* цикл while;
* цикл do while;
* цикл for;
* цикл foreach (добавили в C++11).

### Исключения
**Исключения** предлагают механизм обработки ошибок, возникающих в функции.


## Урок №67. Операторы условного ветвления `if/else`
### Использование нескольких операций в ветвлениях `if/else`
```c++
if (expression) {
    ...
    ...
    ...
}
else {
    ...
    ...
    ...
}
```

### Связывание стейтментов `if`
```c++
if (expression1)
    ...
else if (expression2)
    ...
else
    ...
```

### Вложенные ветвления `if/else`
Используя блоки стейтментов, мы уточняем, к какому `if` следует прикреплять\
определенный `else`. Без блоков оператор `else` будет прикрепляться к ближайшему\
незакрытому оператору `if`.
```c++
#include <iostream>

int main() {
    std::cout << "Enter a number: ";
    int a;
    std::cin >> a;
    
    if (a > 15) {
        if (a < 25)
            std::cout << a << " is between 15 and 25\n";
    }
    else // относится к внешнему оператору if
        std::cout << a << " is less than 15\n";
    
    return 0;
}
```

### Использование логических операторов в ветвлениях `if/else`
Также вы можете проверить сразу несколько условий в ветвлениях `if/else`, используя\
логические операторы:
```c++
if (expression1 && expression2) {  // логическое И
    ...
}
else if (expression1 || expression2) {  // логическое ИЛИ
    ...
}
else {
    ...
}
```

### Основные использования ветвлений `if/else`
**Ранние возвраты:**
```c++
#include <iostream>

enum class ErrorCode {
ERROR_SUCCESS = 0,
ERROR_NEGATIVE_NUMBER = -1
};

ErrorCode doSomething(int value) {
    // Если параметром value является отрицательное число,
    if (value < 0)
        // то сразу же возвращаем код ошибки
        return ErrorCode::ERROR_NEGATIVE_NUMBER;
    
    // Что-нибудь делаем
    
    return ErrorCode::ERROR_SUCCESS;
}
```

```c++
int min(int a, int b) {
    return (a > b) ? b : a;
}
```

### Нулевые стейтменты
Также в C++ можно не указывать основную часть оператора `if`. Такие стейтменты\
называются **нулевыми стейтментами** (или **"null-стейтментами"**)
```c++
if (a > 15)
    ; // это нулевой стейтмент
```

**Предупреждение:** Всегда проверяйте, не "закрыли" ли вы случайно оператор `if`\
точкой с запятой.

## Урок №68. Оператор `switch`
```c++
#include <iostream>

enum Colors {
    COLOR_GRAY,
    COLOR_PINK,
    COLOR_BLUE,
    COLOR_PURPLE,
    COLOR_RED
};

void printColor(Colors color) {
    switch (color) {
        case COLOR_GRAY:
            std::cout << "Gray";
            break;
        case COLOR_PINK:
            std::cout << "Pink";
            break;
        case COLOR_BLUE:
            std::cout << "Blue";
            break;
        case COLOR_PURPLE:
            std::cout << "Purple";
            break;
        case COLOR_RED:
            std::cout << "Red";
            break;
        default:
            std::cout << "Unknown";
            break;
    }
}

int main() {
    printColor(Colors::COLOR_BLUE);

    return 0;
}
```

### Лейблы case
Можно использовать **сразу несколько кейсов** для одного выражения. Следующая\
функция использует несколько кейсов для проверки, соответствует ли параметр `p`\
числу из ASCII-таблицы:
```c++
#include <iostream>

bool isDigit(char p) {
    switch (p)
    {
        case '0': // если p = 0
        case '1': // если p = 1
        case '2': // если p = 2
        case '3': // если p = 3
        case '4': // если p = 4
        case '5': // если p = 5
        case '6': // если p = 6
        case '7': // если p = 7
        case '8': // если p = 8
        case '9': // если p = 9
            return true; // возвращаем true
        default: // в противном случае, возвращаем false
            return false;
    }
}

int main() {
    std::cout << isDigit('2');
    return 0;
}

<< 1
```

### Лейбл по умолчанию
Второй тип лейбла — это **лейбл по умолчанию** (так называемый **"default case"**),
который объявляется с использованием **ключевого слова default**.


### `switch` и `fall-through`
Когда кейс совпал (или выполняется `default`), то выполнение начинается с\
первого стейтмента, который находится после соответствующего кейса и\
продолжается до тех пор, пока не будет выполнено одно из следующих условий\
завершения:
```c++
switch (2) {
        case 1: // Не совпадает!
            std::cout << 1 << '\n'; // пропускается
        case 2: // Совпало!
            std::cout << 2 << '\n'; // выполнение кода начинается здесь
        case 3:
            std::cout << 3 << '\n'; // это также выполнится
        case 4:
            std::cout << 4 << '\n'; // и это
        default:
            std::cout << 5 << '\n'; // и это
    }

<< 2
<< 3
<< 4
<< 5
```
Когда выполнение переходит из одного кейса в следующий, то это называется **fall-through**.

### `switch` и оператор `break`
Оператор `break` (объявленный с использованием ключевого слова `break`) сообщает
компилятору, что мы уже сделали всё, что хотели с определенным `switch` (или
циклом `while`, `do while` или `for`) и больше не намерены с ним работать.
```c++
switch (2) {
        case 1: // Не совпадает!
            std::cout << 1 << '\n'; // пропускается
            break;
        case 2: // Совпало!
            std::cout << 2 << '\n'; // выполнение кода начинается здесь
            break;  // оператор break завершает выполнение switch-а
        case 3:
            std::cout << 3 << '\n';
            break;
        case 4:
            std::cout << 4 << '\n';
            break;
        default:
            std::cout << 5 << '\n';
            break;
    }
    
<< 2
```

### Несколько стейтментов внутри блока `switch`
```c++
switch (2) {
        case 2:
            std::cout << 2 << '\n';
            doSomething();
            std::cout << 4 << '\n';
            break;
        default:
            std::cout << "default case" << '\n';
            break;
    }
```

### Объявление переменной и её инициализация внутри `case`
Обратите внимание, что, хотя переменная `z` была определена в первом кейсе, она\
также используется и во втором кейсе. Все кейсы считаются частью одной и той же\
области видимости, поэтому, объявив переменную в одном кейсе, мы можем\
спокойно использовать её без объявления и в других кейсах.
```c++
switch (x) {
        case 1:
            int z; // ок, объявление разрешено
            z = 5; // ок, операция присваивания разрешена
            break;
        case 2:
            z = 6; // ок, переменная z была объявлена выше, поэтому мы можем использовать её здесь
            break;
        case 3:
            int c = 4; // нельзя, вы не можете инициализировать переменные внутри case
            break;
        default:
            std::cout << "default case" << std::endl;
            break;
    }
```

**Правило: Если нужно инициализировать и/или объявить переменные внутри\
кейса — используйте блоки стейтментов.**
```c++
switch (1) {
    case 1: { // обратите внимание, здесь указан блок
        int z = 5; // хорошо, переменные можно инициализировать внутри блока, который находится внутри кейса
        std::cout << z;
        break;
    }
    default:
        std::cout << "default case" << std::endl;
        break;
}
```

### Тест
**Задание №1.**\
Напишите функцию `calculate()`, которая принимает две переменные типа `int` и одну\
переменную типа `char`, которая, в свою очередь, представляет одну из следующих\
математических операций: `+`, `-`, `*`, `/` или `%` (остаток от числа). Используйте `switch`\
для выполнения соответствующей математической операции над целыми числами,\
а результат возвращайте обратно в `main()`. Если в функцию передается\
недействительный математический оператор, то функция должна выводить ошибку.\
С оператором деления выполняйте целочисленное деление.

```c++
#include <iostream>

int calculate(int x, int y, char op) {
    switch (op) {
        case '+':
            return x + y;
        case '-':
            return x - y;
        case '*':
            return x * y;
        case '/':
            return x / y;
        case '%':
            return x % y;
        default:
            std::cout << "calculate(): Unhandled case\n";
            return 0;
    }
}

int main() {
    std::cout << "Enter an integer: ";
    int x;
    std::cin >> x;
    std::cout << "Enter another integer: ";
    int y;
    std::cin >> y;
    std::cout << "Enter a mathematical operator (+, -, *, /, or %): ";
    char op;
    std::cin >> op;
    std::cout << x << " " << op << " " << y << " is " << calculate(x, y, op) << "\n";
    
    return 0;
}
```

**Задание №2.**\
Определите перечисление (или класс `enum`) `Animal`, которое содержит следующих\
животных: `pig`, `chicken`, `goat`, `cat`, `dog` и `ostrich`. Напишите функцию\
`getAnimalName()`, которая принимает параметр `Animal` и использует `switch` для\
возврата типа животного в качестве строки. Напишите еще одну функцию —\
`printNumberOfLegs()`, которая использует `switch` для вывода количества лап\
соответствующего типа животного. Убедитесь, что обе функции имеют кейс `default`,\
который выводит сообщение об ошибке. Вызовите `printNumberOfLegs()` в `main()`,\
используя в качестве параметров `cat` и `chicken`.

```c++
#include <iostream>
#include <string>

enum Animal {
    ANIMAL_PIG,
    ANIMAL_CHICKEN,
    ANIMAL_GOAT,
    ANIMAL_CAT,
    ANIMAL_DOG,
    ANIMAL_OSTRICH
};

std::string getAnimalName(Animal animal) {
    switch (animal) {
        case ANIMAL_CHICKEN:
            return "chicken";
        case ANIMAL_OSTRICH:
            return "ostrich";
        case ANIMAL_PIG:
            return "pig";
        case ANIMAL_GOAT:
            return "goat";
        case ANIMAL_CAT:
            return "cat";
        case ANIMAL_DOG:
            return "dog";
        default:
            return "getAnimalName(): Unhandled enumerator";
    }
}

void printNumberOfLegs(Animal animal) {
    std::cout << "A " << getAnimalName(animal) << " has ";
    switch (animal) {
        case ANIMAL_CHICKEN:
        case ANIMAL_OSTRICH:
            std::cout << "2";
            break;
        case ANIMAL_PIG:
        case ANIMAL_GOAT:
        case ANIMAL_CAT:
        case ANIMAL_DOG:
            std::cout << "4";
            break;
        default:
            std::cout << "printNumberOfLegs(): Unhandled enumerator";
            break;
    }
    std::cout << " legs.\n";
}

int main() {
    printNumberOfLegs(ANIMAL_CAT);
    printNumberOfLegs(ANIMAL_CHICKEN);
    
    return 0;
}

<< A cat has 4 legs.
<< A chicken has 2 legs.
```

## Урок №69. Оператор `goto`
**Оператор `goto`** – это оператор управления потоком выполнения программ, который\
заставляет центральный процессор выполнить переход из одного участка кода в\
другой (осуществить прыжок). Другой участок кода идентифицируется с помощью\
**лейбла**. Например:
```c++
#include <iostream>
#include <cmath> // для функции sqrt()

int main() {
    double z;
    tryAgain: // это лейбл
    std::cout << "Enter a non-negative number: ";
    std::cin >> z;

    if (z < 0.0)
        goto tryAgain; // а это оператор goto
    std::cout << "The sqrt of " << z << " is " << sqrt(z) << std::endl;

    return 0;
}

<< Enter a non-negative number: -5
<< Enter a non-negative number: 2
<< The sqrt of 2 is 1.41421
```

Ранее мы рассматривали два типа области видимости: локальная (или "блочная") и\
глобальная (или "файловая"). Лейблы используют третий тип области видимости:\
**область видимости функции**. Оператор `goto` и соответствующий лейбл должны\
находиться в одной и той же функции.

Существуют некоторые ограничения на использование операторов `goto`. Например,\
вы не сможете перепрыгнуть вперед через переменную, которая\
инициализирована в том же блоке, что и `goto`:
```c++
int main() {
    goto skip; // прыжок вперед недопустим
    int z = 7;
    skip: // лейбл
    z += 4; // какое значение будет в этой переменной?
    return 0;
}
```

**Спагетти-код** — это код, порядок выполнения которого напоминает тарелку\
со спагетти (всё запутано и закручено), что крайне затрудняет следование\
порядку и понимание логики выполнения такого кода.

**Правило: Избегайте использования операторов goto, если на это нет веских
причин.**

## Урок №70. Цикл `while`
```c++
while (expression)
    ...
```

### Бесконечные циклы
```c++
while (1) {  // или while (true)
    // Этот цикл будет выполняться бесконечно
}
```

### Счетчик цикла `while`
Счетчик цикла — это целочисленная переменная, которая объявляется с единственной целью:\
считать, сколько раз выполнился цикл.

**Правило: Всегда используйте тип `signed int` для счетчиков цикла.**

### Итерации
Каждое выполнение цикла называется **итерацией** (или **"повтором"**).

**Не фундаментальные типы (такие как структуры или классы) переменных лучше\
определять перед циклом.**

### Тест
**Задание №1. (ответ)**\
Переменные нужно объявлять максимально близко к их первому использованию.

**Задание №2.**\
Напишите программу, которая выводит буквы английского алфавита от `a` до `z`\
вместе с кодами из ASCII-таблицы.

```c++
#include <iostream>

int main() {
    char mychar = 'a';
    while (mychar <= 'z') {
        std::cout << mychar << " " << static_cast<int>(mychar) << "\n";
        ++mychar;
    }
    
    return 0;
}
```

**Задание №3.**\
Измените программу из последнего подраздела «Вложенные циклы» так, чтобы она\
выводила следующее:
```c++
#include <iostream>

int main() {
    int outer = 5;
    while (outer >= 1) {
        int inner = outer;
        while (inner >= 1)
            std::cout << inner-- << " ";
        // Вставляем символ новой строки в конце каждого ряда
        std::cout << "\n";
        --outer;
    }
    
    return 0;
}
```

**Задание №4.**\
Теперь сделайте так, чтобы цифры выводились следующим образом (используя\
программу из предыдущего задания):
```c++
#include <iostream>

int main() {
    // Цикл с 1 до 5
    int outer = 1;
    while (outer <= 5) {
        // Числа в рядах появляются в порядке убывания, поэтому цикл начинаем с 5 и до 1
        int inner = 5;
        while (inner >= 1) {
            // Первое число в любом ряде совпадает с номером этого ряда, поэтому числа должны
            // выводиться только если <= номера ряда (в противном случае, выводится пробел)
            if (inner <= outer)
                std::cout << inner << " ";
            else
                std::cout << " "; // вставляем дополнительные пробелы
            --inner;
        }
        // Этот ряд вывели, переходим к следующему
        std::cout << "\n";
        ++outer;
    }
    
    return 0;
}
```

## Урок №71. Цикл `do while`
**Синтаксис `do while` в языке C++:**
```c++
do
    ...;
while (expression);
```

## Урок №72. Цикл `for`
### Цикл `for`
```c++
for (объявление переменных; условие; инкремент/декремент счетчика)
    ...;
```

Переменные, определенные внутри цикла `for`, имеют специальный тип области\
видимости: **область видимости цикла**. Такие переменные существуют только\
внутри цикла и недоступны за его пределами.

### Выполнение цикла `for`
```c++
#include <iostream>

int main() {
    for (int count = 0; count < 10; ++count)
        std::cout << count << " ";

    return 0;
}
```

### Пропущенные выражения в цикле
```c++
#include <iostream>

int main() {
    int count = 0;
    for (; count < 10; ) {
        std::cout << count << " ";
        ++count;
    }
    
    return 0;
}
```

```c++
for (;;)  // бесконечный цикл
    ...;
```

### Объявления переменных в цикле `for`
```c++
#include <iostream>

int main() {
    for (int aaa = 0, bbb = 9; aaa < 10; ++aaa, --bbb)
        std::cout << aaa << " " << bbb << std::endl;

    return 0;
}

<< 0 9
<< 1 8
<< 2 7
<< 3 6
<< 4 5
<< 5 4
<< 6 3
<< 7 2
<< 8 1
<< 9 0
```

### Тест
**Задание №1.**\
Напишите цикл `for`, который выводит каждое четное число в диапазоне от 0 до 20.
```c++
#include <iostream>

int main() {
    for (int count = 0; count <= 20; count += 2)
        std::cout << count << std::endl;
    
    return 0;
}
```

**Задание №2.**\
Напишите функцию `sumTo()`, которая принимает целочисленный параметр с именем
`value` и возвращает сумму всех чисел от `1` до значения `value`.
```c++
int sumTo(int value) {
    int total(0);
    for (int count=1; count <= value; ++count)
        total += count;
    
    return total;
}
```

## Урок №73. Операторы `break` и `continue`
### Оператор `break`
```c++
#include <iostream>

int main() {
    while (true) {  // бесконечный цикл
        std::cout << "Enter 0 to exit or anything else to continue: ";
        int val;
        std::cin >> val;
        // Выходим из цикла, если пользователь ввел 0
        if (val == 0)
            break;
    }
    std::cout << "We're out!\n";

    return 0;
}
```

### Оператор `continue`
Оператор `continue` позволяет сразу перейти в конец тела цикла, пропуская весь код,
который находится под ним.
```c++
#include <iostream>

int main() {
    int count(0);
    do {
        if (count == 5)
            continue; // переходим в конец тела цикла
        std::cout << count << " ";
    // Точка выполнения после оператора continue перемещается сюда
    } while (++count < 10); // этот код выполняется, так как он находится вне тела цикла

    return 0;
}

<< 0 1 2 3 4 6 7 8 9
```

## Урок №74. Генерация случайных чисел
### Генератор псевдослучайных чисел
**Генератор псевдослучайных чисел** (сокр. "**ГПСЧ**") — это программа, которая\
принимает стартовое/начальное значение и выполняет с ним определенные\
математические операции, чтобы конвертировать его в другое число, которое\
совсем не связано со стартовым.
```c++
unsigned int PRNG() {
    // Наше стартовое число - 4 541
    static unsigned int seed = 4541;

    // Берем стартовое число и, с его помощью, генерируем новое значение.
    // Из-за использования очень больших чисел (и переполнения) угадать следующее число
    // исходя из предыдущего - очень сложно
    seed = (8253729 * seed + 2396403);

    // Берем стартовое число и возвращаем значение в диапазоне от 0 до 32767
    return seed % 32768;
}
```

### Функции `srand()` и `rand()`
`cstdlib`:
* **Функция `srand()`** устанавливает передаваемое пользователем значение в
  качестве стартового. `srand()` следует вызывать только один раз — в начале
  программы (обычно в верхней части функции `main()`).
* **Функция `rand()`** генерирует следующее случайное число в
  последовательности. Оно будет находиться в диапазоне от `0` до
  `RAND_MAX` (константа в `cstdlib`, значением которой является `32767`).

```c++
#include <iostream>
#include <cstdlib> // для функций rand() и srand()

int main() {
    srand(4541); // устанавливаем стартовое значение - 4 541

    // Выводим 100 случайных чисел
    for (int count = 0; count < 20; ++count) {
        std::cout << rand() << "\t";
        // Если вывели 5 чисел, то вставляем символ новой строки
        if ((count + 1) % 5 == 0)
            std::cout << "\n";
    }
}

<< 822351550	1622942556	1721308543	188933821	858593265	
   1584136113	790961218	377942596	486417893	2090487109	
   1000318466	402762403	1806474202	1283089007	1964638683	
   1562682819	1550405832	217774549	309706346	102057035	
```

### Стартовое число и последовательности в ГПСЧ
В языке Cи есть функция `time()`, которая возвращает в качестве времени общее\
количество секунд, прошедшее от полуночи 1 января 1970 года.\
Теперь наша программа будет генерировать разные последовательности случайных чисел:
```c++
#include <iostream>
#include <cstdlib> // для функций rand() и srand()
#include <ctime> // для функции time()

int main() {
    srand(static_cast<unsigned int>(time(0))); // устанавливаем значение системных часов в качестве стартового числа
    for (int count=0; count < 20; ++count) {
        std::cout << rand() << "\t";
        // Если вывели 5 чисел, то вставляем символ новой строки
        if ((count+1) % 5 == 0)
            std::cout << "\n";
    }
}
```

### Генерация случайных чисел в заданном диапазоне
```c++
int getRandomNumber(int min, int max) {
    // Предполагается, что srand уже вызвали
    return rand() % (min - max + 1) + min;
}
```

### Рандомные числа в C++11
**Вихрь Марсенна (Mersenne Twister) для случайных 32-битных чисел `unsigned`:**
```c++
#include <iostream>
#include <random>  // для std::random_device и std::mt19937


int main() {
    std::random_device rd;
    std::mt19937 mersenne{rd()}; // инициализируем Вихрь Мерсенна случайным стартовым числом

    // Выводим несколько случайных чисел
    for (int count = 0; count < 48; ++count) {
        std::cout << mersenne() << "\t";
        // Если вывели 5 чисел, то вставляем символ новой строки
        if ((count + 1) % 5 == 0)
            std::cout << "\n";
    }

    return 0;
}
```

## Урок №75. Обработка некорректного пользовательского ввода
Программа, которая имеет обработку некорректного ввода, называется **надежной**.
### std::cin, буфер данных и извлечение
Оператор `>>` называется **оператором извлечения**.

**Обработка некорректных извлечений (примитивный калькулятор):**
```c++
double getValue() {
    while (true) {  // цикл продолжается до тех пор, пока пользователь не введет корректное значение
        std::cout << "Enter a double value: ";
        double a;
        std::cin >> a;
        if (std::cin.fail()) {  // если предыдущее извлечение оказалось неудачным,
            std::cin.clear(); // то возвращаем cin в 'обычный' режим работы
            std::cin.ignore(32767, '\n'); // и удаляем значения предыдущего ввода из входного буфера
            std::cout << "Oops, that input is invalid. Please try again.\n";
        } else // если всё хорошо, то возвращаем a
            std::cin.ignore(32767,'\n'); // удаляем лишние значения
            return a;
    }
}

char getOperator() {
    while (true) {  // цикл продолжается до тех пор, пока пользователь не введет корректное значение
        std::cout << "Enter one of the following: +, -, *, or /: ";
        char sm;
        std::cin >> sm;
        // Переменные типа char могут принимать любые символы из
        // пользовательского ввода, поэтому нам не стоит беспокоиться по поводу
        // возникновения неудачного извлечения
        std::cin.ignore(32767, '\n'); // удаляем лишний балласт
        // Выполняем проверку пользовательского ввода
        if (sm == '+' || sm == '-' || sm == '*' || sm == '/')
            return sm; // возвращаем обратно в caller
        else // в противном случае, сообщаем пользователю, что что-то пошло не так
            std::cout << "Oops, that input is invalid. Please try again.\n";
    }
}

void printResult(double a, char sm, double b) {
    switch (sm) {
        case '+':
            std::cout << a << " + " << b << " is " << a + b << '\n';
            break;
        case '-':
            std::cout << a << " - " << b << " is " << a - b << '\n';
            break;
        case '*':
            std::cout << a << " * " << b << " is " << a * b << '\n';
            break;
        case '/':
            std::cout << a << " / " << b << " is " << a / b << '\n';
            break;
        default:
            std::cout << "Something went wrong: printResult() got an invalid operator.";
            break;
    }
}


int main() {
    double a = getValue();
    char sm = getOperator();
    double b = getValue();
    printResult(a, sm, b);

    return 0;
}
```

```c++
if (std::cin.fail()) // если предыдущее извлечение не выполнилось или произошло переполнение,
{
    std::cin.clear(); // то возвращаем cin в 'обычный' режим работы
    std::cin.ignore(32767,'\n'); // и удаляем значения предыдущего ввода из входного буфера
}
```

## Урок №76. Введение в тестирование кода
**Тестирование программного обеспечения** — это процесс определения\
работоспособности программного обеспечения согласно ожиданиям разработчика.

**Правило: Часто компилируйте свой код и всегда тестируйте все нетривиальные\
функции, которые вы пишете.**

**Покрытие стейтментов** — это процент стейтментов в вашем коде, которые были
задействованы во время выполнения тестирования.

**Правило: Убедитесь, что во время тестирования задействованы все стейтменты\
вашей функции.**

Термин **"покрытие ветвлений"** относится к проценту ветвлений, которые были\
выполнены в каждом случае (положительном и отрицательном) отдельно.

**Правило: Тестируйте каждый случай ветвления в вашей программе.**

**Правило: Используйте "тест 0, 1, 2" для проверки циклов на корректную работу с\
разным количеством итераций.**

**Правило: Тестируйте разные типы ввода, чтобы убедиться, что ваш "кусок кода"\
правильно их обрабатывает.**

## Глава №5. Итоговый тест
### Теория
**Операторы `if`** позволяют выполнить код, основываясь на результате условия\
(истинно оно или нет). Если условие ложное, то выполняется **оператор `else`**. Можно\
связывать несколько операторов `if` и `else` вместе.

**Оператор `switch`** обеспечивает более удобный и быстрый способ использования\
условий/ветвлений в коде. Он отлично сочетается с перечислениями.

**Оператор `goto`** позволяет переносить точку выполнения в программе из одного\
места в другое. Использовать этот оператор не рекомендуется.

**Цикл `while`** выполняет определенный код до тех пор, пока условие истинно.
Сначала обрабатывается условие, а затем выполняется код.

**Цикл do `while`** — это тот же цикл `while`, только сначала выполняется код, а затем уже\
проверяется условие. Он отлично подходит для вывода меню или других\
элементов, так как позволяет выполнить код хотя бы один раз.

**Циклы `for`** наиболее используемые циклы. Они идеальны, когда нужно выполнить\
код определенное количество раз.

**Оператор `break`** позволяет немедленно завершить выполнение оператора switch,\
циклов `while`, `do while` или `for`.

**Оператор `continue`** позволяет немедленно перейти к следующей итерации цикла.\
Будьте осторожны при использовании этого оператора в связке с циклами `while` или\
`do while` — не забывайте о возникновении проблемы с инкрементом счетчика цикла.

И, наконец, **рандомные числа** позволяют получить разные результаты при\
выполнении одной и той же программы.

### Тест
**Задание №1.**\
В итоговом тесте главы №2 мы написали программу имитации мячика, падающего с\
башни. Так как тогда мы еще ничего не знали о циклах и не умели их использовать,\
то время полета мячика составляло всего лишь 5 секунд.\
Измените программу, приведенную ниже, таким образом, чтобы мячик падал\
ровно то количество секунд, которое необходимо ему для достижения земли.

**constants.h:**
```c++
#ifndef CONSTANTS_H
#define CONSTANTS_H
namespace myConstants {
    const double gravity(9.8);
}
#endif
```

**main.cpp:**
```c++
#include <iostream>
#include "constants.h"

// Получаем начальную высоту от пользователя и возвращаем её
double getInitialHeight() {
    std::cout << "Enter the initial height of the tower in meters: ";
    double initialHeight;
    std::cin >> initialHeight;
    return initialHeight;
}

// Возвращаем расстояние от земли после "..." секунд падения
double calculateHeight(double initialHeight, int seconds) {
    // Используем формулу: [ s = u * t + (g * t^2) / 2 ], где u (начальная скорость) = 0
    double distanceFallen = (myConstants::gravity * seconds * seconds) / 2;
    double currentHeight = initialHeight - distanceFallen;
    return currentHeight;
}

// Выводим высоту, на которой находится мячик после каждой секунды падения
void printHeight(double height, int seconds) {
    if (height > 0.0)
        std::cout << "At " << seconds << " seconds, the ball is at height: "
                  << height << " meters\n";
    else
        std::cout << "At " << seconds << " seconds, the ball is on the ground.\n";
}

int main() {
    const double initialHeight = getInitialHeight();
    int seconds = 0;
    double height;
    do {
        height = calculateHeight(initialHeight, seconds);
        printHeight(height, seconds);
        ++seconds;
    } while (height > 0.0);
    return 0;
}
```

**Задание №2.**\
Напишите программу-игру типа Hi-Lo:
* Во-первых, ваша программа должна выбрать случайное целое число в\
  диапазоне от 1 до 100.
* Пользователю дается 7 попыток, чтобы угадать это число.
* Если пользователь не угадал число, то программа должна подсказывать,\
  была ли его догадка слишком большой или слишком маленькой.
* Если пользователь угадал число, то программа должна сообщить, что всё\
  верно — вы выиграли.
* Если же у пользователя кончились попытки, и он не угадал число, то\
  программа должна сообщить ему, что он проиграл и показать правильный\
  результат.
* В конце игры программа должна спросить у пользователя, не хочет ли он\
  сыграть еще раз. Если пользователь не введет ни y, ни n (а что-то другое), то\
  программа должна спросить его еще раз.

```c++
#include <iostream>
#include <cstdlib> // для функций srand() и rand()
#include <ctime> // для функции time()

// Генерируем случайное число между min и max.
// Предполагается, что srand() уже вызывали
int getRandomNumber(int min, int max) {
    static const double fraction = 1.0 / (static_cast<double>(RAND_MAX) + 1.0);
    // Равномерно распределяем выбор случайного числа в диапазоне
    return static_cast<int>(rand() * fraction * (max - min + 1) + min);
}

// Возвращаем true, если пользователь выиграл, false - если проиграл
bool playGame(int guesses, int number) {
    // Цикл работы с догадками пользователя
    for (int count = 1; count <= guesses; ++count) {
        std::cout << "Guess #" << count << ": ";
        int guess;
        std::cin >> guess;
        if (guess > number)
            std::cout << "Your guess is too high.\n";
        else if (guess < number)
            std::cout << "Your guess is too low.\n";
        else // догадка == число
            return true;
    }
    return false;
}

bool playAgain() {
    // Продолжаем спрашивать у пользователя, хочет ли он сыграть еще раз до тех пор, пока он не нажмет 'y' или 'n'
    char ch;
    do {
        std::cout << "Would you like to play again (y/n)? ";
        std::cin >> ch;
    } while (ch != 'y' && ch != 'n');
    return (ch == 'y');
}

int main() {
    srand(static_cast<unsigned int>(time(0))); // в качестве стартового числа используем системные часы
    rand(); // сбрасываем первый результат, так как функция rand() не особо
    // хорошо рандомизирует первое случайное число в Visual Studio
    const int guesses = 7; // у пользователя есть 7 попыток
    do {
        int number = getRandomNumber(1, 100); // число, которое пользователь должен угадать
        std::cout << "Let's play a game. I'm thinking of a number. You have "
                  << guesses << " tries to guess what it is.\n";
        bool won = playGame(guesses, number);
        if (won)
            std::cout << "Correct! You win!\n";
        else
            std::cout << "Sorry, you lose. The correct number was " << number
                      << "\n";
    }
    while (playAgain());
    std::cout << "Thank you for playing.\n";
    return 0;
}
```