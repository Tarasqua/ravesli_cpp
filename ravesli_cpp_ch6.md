# Глава №6.
## Урок №77. Массивы
```c++
int testResult[30]; // выделяем 30 целочисленных переменных, используя фиксированный массив
testResult[0] = 12;
```

```c++
struct Rectangle {
    int length;
    int width;
};
Rectangle rects[4]; // объявляем массив с 4-мя прямоугольниками
rects[0] = {12, 15};
rects[0].width = 22;
```

### Индексы массивов
В языке C++ индексы массивов **всегда должны быть интегрального типа данных**\
(т.е. типа `char`, `short`, `int`, `long`, `long long`, `bool` и т.д.).

### Объявление массивов фиксированного размера
При объявлении массива фиксированного размера, его длина должна быть\
константой типа `compile-time`:
```c++
// Используем литерал
int array[7]; // хорошо

// Используем макрос-объект с текст_замена в качестве символьной константы
#define ARRAY_WIDTH 4
int array[ARRAY_WIDTH]; // синтаксически хорошо, но не делайте этого

// Используем символьную константу
const int arrayWidth = 7;
int array[arrayWidth]; // хорошо

// Используем перечислитель
enum ArrayElements {
    MIN_ARRAY_WIDTH = 3
};
int array[MIN_ARRAY_WIDTH]; // хорошо

// Используем неконстантную переменную
int width;
std::cin >> width;
int array[width]; // плохо: width должна быть константой типа compile-time!

// Используем константную переменную типа runtime
int temp = 8;
const int width = temp;
int array[width]; // плохо: здесь width является константой типа runtime, но должна быть константой типа compile-time!
```

## Урок №78. Фиксированные массивы
```c++
int array[5] = { 4, 5, 8, 9, 12 }; // используется список инициализаторов для инициализации фиксированного массива
```
Если в списке инициализаторов меньше, чем может содержать массив, то\
остальные элементы будут проинициализированы значением `0`. Если больше - ошибка.

```c++
int array[5] = { }; // Инициализируем все элементы массива значением 0

int array[5] { 4, 5, 8, 9, 12 }; // используем uniform-инициализацию для инициализации фиксированного массива
```

### Длина массива
```c++
int array[5] = { 0, 1, 2, 3, 4 }; // явно указываем длину массива
int array[] = { 0, 1, 2, 3, 4 }; // список инициализаторов автоматически определит длину массива
```

### Массивы и перечисления
```c++
const int numberOfStudents(5);
int testScores[numberOfStudents];
testScores[3] = 65;
```
Кто представлен элементом `testScores[3]`? Непонятно!

Это можно решить, используя перечисление, в котором перечислители\
сопоставляются каждому из возможных индексов массива:
```c++
#include <iostream>

enum StudentNames {
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    MAX_STUDENTS // 5
};

int main() {
    int testScores[StudentNames::MAX_STUDENTS]; // всего 5 студентов
    testScores[JOHN] = 65;

    return 0;
}
```
`MAX_STUDENTS` используется во время объявления массива для\
гарантирования того, что массив имеет корректную длину (она должна быть на\
единицу больше самого большого индекса). Это полезно как для подсчета\
элементов, так и для возможности автоматического изменения длины массива,\
если добавить еще один перечислитель:
```c++
enum StudentNames {
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    KIRILL, // 5
    MAX_STUDENTS // 6
};
```

### Массивы и классы `enum`
```c++
#include <iostream>

enum class StudentNames {
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    MAX_STUDENTS // 5
};

int main() {
    int testScores[static_cast<int>(StudentNames::MAX_STUDENTS)]; // всего 5 студентов
    testScores[static_cast<int>(StudentNames::JOHN)] = 65;

    return 0;
}
```

Стандартное перечисление внутри пространства имен:
```c++
#include <iostream>

namespace StudentNames {
    enum StudentNames {
        SMITH, // 0
        ANDREW, // 1
        IVAN, // 2
        JOHN, // 3
        ANTON, // 4
        MAX_STUDENTS // 5
    };
}

int main() {
    int testScores[static_cast<int>(StudentNames::MAX_STUDENTS)]; // всего 5 студентов
    testScores[static_cast<int>(StudentNames::JOHN)] = 65;

    return 0;
}
```

### Передача массивов в функции
**Когда обычная переменная передается по значению, то C++ копирует значение\
аргумента в параметр функции. Поскольку параметр является копией, то изменение\
значения параметра не изменяет значение исходного аргумента.**

Однако, поскольку копирование больших массивов — дело трудоёмкое, то **C++ не
копирует массив при его передаче в функцию**. Вместо этого передается фактический
массив.

**Примечание:** Если вы **не хотите**, чтобы функция изменяла значения элементов
массива, переданного в нее в качестве параметра, то нужно сделать массив
константным:
```c++
// Даже если array является фактическим массивом, внутри этой функции он должен рассматриваться как константный
void passArray(const int array[5]) {
    // Поэтому каждая из следующих строк вызовет ошибку компиляции!
    array[0] = 11;
    array[1] = 7;
    array[2] = 5;
    array[3] = 3;
    array[4] = 2;
}
```

### Оператор `sizeof` и массивы
```c++
#include <iostream>

void printSize(int array[]) {
    std::cout << sizeof(array) << '\n'; // выводится размер указателя, а не массива
}

int main() {
    int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
    std::cout << sizeof(array) << '\n'; // выводится размер массива
    printSize(array);
    
    return 0;
}

<< 32
<< 8
```

### Определение длины фиксированного массива
Чтобы определить длину фиксированного массива, поделите размер всего массива\
на размер одного элемента массива:
```c++
#include <iostream>

int main() {
    int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
    // размер массива = длина массива * размер одного элемента
    std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";
    
    return 0;
}

<< The array has 8 elements
```

**Правило: При использовании массивов убедитесь, что ваши индексы корректны и\
соответствуют диапазону вашего массива.**

### Тест
**Задание №1.**\
Объявите массив для хранения температуры (дробное число) каждого дня в году\
(всего 365 дней). Проинициализируйте массив значением 0.0 для каждого дня.
```c++
double temperature[365] = { 0.0 };
```

**Задание №2.**\
Создайте перечисление со следующими перечислителями: `chicken`, `lion`,\
`giraffe`, `elephant`, `duck` и `snake`. Поместите перечисление в пространство\
имен. Объявите массив, где элементами будут эти перечислители и, используя\
список инициализаторов, инициализируйте каждый элемент соответствующим\
количеством лап определенного животного. В функции `main()` выведите количество\
ног у слона, используя перечислитель.
```c++
#include <iostream>

namespace Animals {
    enum Animals {
        CHICKEN,
        LION,
        GIRAFFE,
        ELEPHANT,
        DUCK,
        SNAKE,
        MAX_ANIMALS
    };
}

int main() {
    int legs[Animals::MAX_ANIMALS] = { 2, 4, 4, 4, 2, 0 };
    std::cout << "An elephant has " << legs[Animals::ELEPHANT] << " legs.\n";
    return 0;
}
```

## Урок №79. Массивы и циклы
```c++
int students[] = { 73, 85, 84, 44, 78};
const int numStudents = sizeof(students) / sizeof(students[0]);
int totalScore = 0;
// Используем цикл для вычисления totalScore
for (int person = 0; person < numStudents; ++person)
    totalScore += students[person];
double averageScore = static_cast<double>(totalScore) / numStudents;

<< 72.8
```

### Тест
**Задание №1.**\
Выведите на экран следующий массив с помощью цикла:\
`int array[] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };`

```c++
#include <iostream>
int main() {
    int array[] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
    const int arrayLength = sizeof(array) / sizeof(array[0]);
    for (int index=0; index < arrayLength; ++index)
        std::cout << array[index] << " ";
    
    return 0;
}
```

**Задание №2.**\
Используя массив из задания №1:\
Попросите пользователя ввести число от 1 до 9. Если пользователь введет что-либо\
другое — попросите его снова ввести число и так до тех пор, пока он не введет\
корректное значение из заданного диапазона. Как только пользователь введет\
число от 1 до 9, выведите массив на экран. Затем найдите в массиве элемент с\
числом, которое ввел пользователь, и выведите его индекс.

```c++
#include <iostream>

int main() {
    // Сначала принимаем корректный пользовательский ввод
    int number = 0;
    do {
        std::cout << "Enter a number between 1 and 9: ";
        std::cin >> number;
        // Если пользователь ввел некорректное значение
        if (std::cin.fail())
            std::cin.clear();
        std::cin.ignore(32767, '\n');
    } while (number < 1 || number > 9);
    
    // Дальше выводим массив на экран
    int array[] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
    const int arrayLength = sizeof(array) / sizeof(array[0]);
    for (int index=0; index < arrayLength; ++index)
        std::cout << array[index] << " ";
    std::cout << "\n";
    
    // Затем ищем в массиве число, которое ввел пользователь и выводим его индекс
    for (int index=0; index < arrayLength; ++index) {
        if (array[index] == number) {
            std::cout << "The number " << number << " has index " << index << "\n";
            break; // так как каждый элемент в массиве уникальный, то нет надобности продолжать перебирать элементы дальше
        }
    }
    return 0;
}
```

**Задание №3.**\
Измените следующую программу так, чтобы вместо `maxScore` с наибольшим\
значением, переменная `maxIndex` содержала индекс элемента с наибольшим\
значением:
```c++
#include <iostream>
int main() {
    int scores[] = { 73, 85, 84, 44, 78 };
    const int numStudents = sizeof(scores) / sizeof(scores[0]);
    int maxIndex = 0; // отслеживаем самую высокую оценку  (maxScore = 0;)
    for (int student = 0; student < numStudents; ++student)
        if (scores[student] > scores[maxIndex])
            maxIndex = student;  // (maxScore = scores[student];)
    std::cout << "The best score: " << scores[maxIndex] << '\n';
    std::cout << "Index of the best score: " << maxIndex << '\n';
    return 0;
}
```

## Урок №80. Сортировка массивов методом выбора
Чтобы поменять два элемента местами, мы можем использовать функцию\
`std::swap()` из заголовочного файла `utility`.
```c++
#include <iostream>
#include <utility> 

int main() {
    int a = 3;
    int b = 5;
    std::cout << "Before swap: a = " << a << ", b = " << b << '\n';
    std::swap(a, b); // меняем местами значения переменных a и b
    std::cout << "After swap: a = " << a << ", b = " << b << '\n';
    
    return 0;
}

<< Before swap: a = 3, b = 5
<< After swap: a = 5, b = 3
```

### Функция `std::sort()`
```c++
#include <iostream>
#include <algorithm> // для std::sort()

int main() {
    const int length = 5;
    int array[length] = {30, 50, 20, 10, 40};
    std::sort(array, array + length);

    for (int i : array)
        std::cout << i << ' ';
    
    return 0;
}

<< 10 20 30 40 50 
```

## Урок №81. Многомерные массивы
Массив массивов называется **многомерным массивом**:
```c++
// первый элемент - количество строк, второй - количество столбцов
int array[2][4]; // двумерный массив
```

### Инициализация двумерных массивов
```c++
int array[3][5] =
            {
                    { 1, 2, 3, 4, 5 }, // строка №0
                    { 6, 7, 8, 9, 10 }, // строка №1
                    { 11, 12, 13, 14, 15 } // строка №2
            };

int array[3][5] =
            {
                    { 2, 4 }, // строка №0 = 2, 4, 0, 0, 0
                    { 1, 3, 7 }, // строка №1 = 1, 3, 7, 0, 0
                    { 8, 9, 11, 12 } // строка №2 = 8, 9, 11, 12, 0
            };

int array[][5] =  // можно не указывать только левый индекс (длину массива)
            {
                    { 1, 2, 3, 4, 5 },
                    { 6, 7, 8, 9, 10 },
                    { 11, 12, 13, 14, 15 }
            };

// многомерные массивы можно инициализировать значением 0
// это работает только в случае, когда явно объявляется длина массива
int array[3][5] = { 0 };
```

### Доступ к элементам в двумерном массиве
```c++
for (int row = 0; row < numRows; ++row) // доступ по строкам
    for (int col = 0; col < numCols; ++col) // доступ к каждому элементу в строке
        std::cout << array[row][col];
```

https://stackoverflow.com/questions/15927033/what-is-the-correct-way-of-using-c11s-range-based-for
```c++
for (auto & row : array)
        for (int col : row)
            std::cout << col << ' ';
```

### Многомерные массивы более двух измерений
```c++
int array[4][3][2]; // трехмерный массив
std::cout << array[3][2][1];
```

## Урок №82. Строки `C-style`
**Современный C++ поддерживает два разных типа строк:**
* `std::string` (как часть Стандартной библиотеки С++);
* **строки `C-style`** (изначально унаследованные от языка Cи).

### Строки `C-style`
**Строка `C-style`** — это простой массив символов, который использует нуль-\
терминатор. **Нуль-терминатор** — это специальный символ (ASCII-код которого\
равен 0), используемый для обозначения конца строки. Строка C-style еще\
называется "**нуль-терминированной строкой**".

```c++
char mystring[] = "string";
```
Хотя `string` имеет только 6 букв, C++ автоматически добавляет нуль-терминатор в\
конец строки (нам не нужно добавлять его вручную). Следовательно, длина массива\
`mystring` на самом деле равна 7.

```c++
#include <iostream>

int main() {
    char mystring[] = "string";
    // эквивалентно sizeof(mystring) / sizeof(mystring[0])
    std::cout << mystring << " has " << sizeof(mystring) << " characters.\n";

    for (char index : mystring)  // эквивалентно for (int index = 0; index < sizeof(mystring); ++index)
        std::cout << static_cast<int>(index) << " ";

    return 0;
}

<< string has 7 characters.
<< 115 116 114 105 110 103 0 
```
Нуль в конце является ASCII-кодом нуль-терминатора, который был добавлен в конец строки.

```c++
char mystring[] = "string"; // ок
mystring = "cat"; // не ок!

// эквивалентно
int array[] = { 4, 6, 8, 2 }; // ок
array = 7; // что это значит?
```

```c++
// так как строки C-style - массивы, то:
char mystring[] = "string";
mystring[1] = 'p';
std::cout << mystring;

<< spring
```

### Строки `C-style` и `std::cin`
Вызов `cin.getline()` будет принимать до 254 символов в массив name (оставляя\
место для нуль-терминатора!). Любые лишние символы будут проигнорированы.\
Таким образом, мы можем гарантировать, что массив не будет переполнен.
```c++
#include <iostream>

int main() {
    char name[255]; // объявляем достаточно большой массив (для хранения 255 символов)
    std::cout << "Enter your name: ";
    std::cin.getline(name, 255);
    std::cout << "You entered: " << name << '\n';

    return 0;
}
```

### Управление строками `C-style`
**Функция `strcpy_s()`** позволяет копировать содержимое одной строки в другую.\
Чаще всего это используется для присваивания значений строке:
```c++
#include <iostream>
#include <cstring>

int main() {
    char text[] = "Print this!";
    char dest[50]; // длина массива должна быть не меньше длины копируемой строки
    strcpy_s(dest, text); // в dest - text
    std::cout << dest; // выводим "Print this!"
    
    return 0;
}
```

Еще одной полезной функцией управления строками является **функция `strlen()`**,\
которая возвращает длину строки `C-style` (без учета нуль-терминатора):
```c++
#include <iostream>
#include <cstring>

int main() {
    char name[15] = "Max"; // используется только 4 символа (3 буквы + нуль-терминатор)
    std::cout << "My name is " << name << '\n';
    std::cout << name << " has " << strlen(name) << " letters.\n";
    std::cout << name << " has " << sizeof(name) << " characters in the array.\n";
    
    return 0;
}

<< My name is Max
<< Max has 3 letters.
<< Max has 15 characters in the array.
```

Вот еще полезные функции для управления строками C-style:
* **функция `strcat()`** — добавляет одну строку к другой (опасно);
* **функция `strncat()`** — добавляет одну строку к другой (с проверкой размера\
  места назначения);
* **функция `strcmp()`** — сравнивает две строки (возвращает 0, если они равны);
* **функция `strncmp()`** — сравнивает две строки до определенного количества\
  символов (возвращает 0, если до указанного символа не было различий).

### Стоит ли использовать строки `C-style`?
**Правило: Используйте `std::string` вместо строк `C-style`.**

## Урок №83. Введение в класс `std::string_view`
### Введение в класс `std::string_view`
В стандарте С++17 вводится еще один способ использования строк — с помощью\
класса `std::string_view`, который находится в заголовочном файле `string_view`.

В отличие от объектов класса `std::string`, которые хранят свою собственную копию\
строки, класс `std::string_view` обеспечивает **представление** (англ. "**view**") для\
заданной строки, которая может быть определена где-нибудь в другом месте.

```c++
#include <iostream>
#include <string_view>

int main() {
    std::string_view text{ "hello" }; // представление для строки "hello", которое хранится в бинарном виде
    std::string_view str{ text }; // представление этой же строки - "hello"
    std::string_view more{ str }; // представление этой же строки - "hello"
    std::cout << text << ' ' << str << ' ' << more << '\n';
    
    return 0;
}

<< hello hello hello
```
**При таком подходе, у нас не будут созданы лишние копии строки `hello`**

```c++
#include <iostream>
#include <string_view>

int main() {
    std::string_view str{ "Trains are fast!" };
    std::cout << str.length() << '\n'; // 16
    std::cout << str.substr(0, str.find(' ')) << '\n'; // Trains
    std::cout << (str == "Trains are fast!") << '\n'; // 1
    
    // Начиная с C++20
    std::cout << str.starts_with("Boats") << '\n'; // 0
    std::cout << str.ends_with("fast!") << '\n'; // 1
    
    std::cout << str << '\n'; // Trains are fast!
    
    return 0;
}
```

Т.к. объект класса `std::string_view` не создает копии строки, то, изменив исходную\
строку, мы, тем самым, повлияем и на её представление в связанном с ней\
объектом `std::string_view`:
```c++
#include <iostream>
#include <string_view>

int main() {
    char arr[]{"Gold"};
    std::string_view str{arr};

    std::cout << str << '\n'; // Gold
    // Изменяем 'd' на 'f' в arr
    arr[3] = 'f';
    std::cout << str << '\n'; // Golf

    return 0;
}
```

**Совет:** Используйте `std::string_view` вместо строк `C-style`.\ 
Для строк, которые не планируете изменять в дальнейшем, предпочтительнее\
использовать класс `std::string_view` вместо `std::string`.

### Функции, модифицирующие представление
Можно изменять представление строки без изменения исходной строки.\
Для этого используются следующие функции:
* `remove_prefix()` — удаляет символы из левой части представления;
* `remove_suffix()` — удаляет символы из правой части представления.
```c++
#include <iostream>
#include <string_view>

int main() {
    std::string_view str{ "Peach" };
    std::cout << str << '\n'; // Peach

    // Игнорируем первый символ
    str.remove_prefix(1);
    std::cout << str << '\n'; // each

    // Игнорируем последние 2 символа
    str.remove_suffix(2); 
    std::cout << str << '\n';  // ea

    return 0;
}
```
**Важно:** Изменив однажды область видимости, вы уже не сможете вернуться\
к первоначальным значениям.

### `std::string_view` и обычные строки
В отличие от строк `C-Style`, объекты классов `std::string` и `std::string_view` **не\
используют нулевой символ (нуль-терминатор)** в качестве метки для обозначения\
конца строки. Данные объекты знают, где заканчивается строка, т.к. отслеживают её длину:
```c++
#include <iostream>
#include <iterator> // для функции std::size()
#include <string_view>

int main() {
    // Нет нуль-терминатора
    char vowels[]{ 'a', 'e', 'i', 'o', 'u' };

    // Массив vowels не является нуль-терминированным. Мы должны передавать длину вручную.
    // Поскольку vowels является массивом, то мы можем использовать функцию std::size(), чтобы получить его длину
    std::string_view str{ vowels, std::size(vowels) };
    
    // Или просто
    std::string_view str{ vowels };

    std::cout << str << '\n'; // это безопасно, так как std::cout знает, как выводить std::string_view

    return 0;
}
```

### Проблемы владения и доступа
Поскольку `std::string_view` является всего лишь представлением строки, его время\
жизни не зависит от времени жизни строки, которую он представляет. Если\
отображаемая строка выйдет за пределы области видимости, то s`td::string_view`\
больше не сможет её отображать и при попытке доступа к ней мы получим\
неопределенные результаты:
```c++
#include <iostream>
#include <string>
#include <string_view>

std::string_view askForName() {
    std::cout << "What's your name?\n";
    // Используем std::string, поскольку std::cin будет изменять строку
    std::string str{};
    std::cin >> str;
    // Мы переключаемся на std::string_view только в демонстрационных целях.
    // Если вы уже имеете std::string, то нет необходимости переключаться на std::string_view
    std::string_view view{ str };
    std::cout << "Hello " << view << '\n';
    
    return view;
} // str уничтожается и, таким образом, уничтожается и строка, созданная str

int main() {
    std::string_view view{ askForName() };
    // view пытается обратиться к строке, которой уже не существует
    std::cout << "Your name is " << view << '\n'; // неопределенное поведение

    return 0;
}

<< Whats your name?
>> Kirill
<< Hello Kirill
<< Your name is  0#�Y
```

**Предупреждение:** Следите за тем, чтобы исходная строка, на которую ссылается\
объект std::string_view, не выходила за пределы области видимости и не\
изменялась до тех пор, пока используется ссылающийся на нее объект\
`std::string_view`.

### Конвертация `std::string_view` в `std::string`
Объекты класса `std::string_view` не конвертируются неявным образом в объекты\
класса `std::string`, но конвертируются при явном преобразовании:
```c++
#include <iostream>
#include <string>
#include <string_view>

void print(std::string s) {
    std::cout << s << '\n';
}

int main() {
    std::string_view sv{ "balloon" };
    sv.remove_suffix(3); // удаляем 3 элемента справа
    // print(sv); // ошибка компиляции: неявная конвертация запрещена
    std::string str{ sv }; // явное преобразование
    print(str); // ок
    print(static_cast<std::string>(sv)); // ок

    return 0;
}

<< ball
<< ball
```

### Конвертация `std::string_view` в строку `C-style`
Некоторые старые функции (такие как `strlen()`) работают только со строками `C-style`.\
Для того чтобы преобразовать объект класса `std::string_view` в строку `C-style`,\
мы сначала должны конвертировать его в объект класса `std::string`:
```c++
#include <cstring>
#include <iostream>
#include <string>
#include <string_view>

int main() {
    std::string_view sv{ "balloon" };
    sv.remove_suffix(3);
    // Создание объекта std::string из объекта std::string_view
    std::string str{ sv };
    // Получаем строку C-style с нуль-терминатором
    auto szNullTerminated{ str.c_str() };
    // Передаем строку с нуль-терминатором в функцию, которую мы хотим использовать
    std::cout << str << " has " << std::strlen(szNullTerminated) << " letter(s)\n";

    return 0;
}

<< ball has 4 letter(s)
```
Однако стоит учитывать, что создание объекта класса `std::string` всякий раз, когда\
мы хотим преобразовать объект `std::string_view `в строку `C-style`, является\
дорогостоящей операцией, поэтому мы должны по возможности избегать\
подобных ситуаций.

### Функция `data()`
Доступ к исходной строке объекта `std::string_view` можно получить при помощи
**функции `data()`**, которая возвращает строку `C-style`. Но это следует\
использовать только тогда, когда объект `std::string_view` не был изменен (например,\
при помощи функций `remove_prefix()` или `remove_suffix()`) и связанная с\
ним строка имеет нуль-терминатор (так как это строка `C-style`).\

В следующем примере функция `std::strlen()` ничего не знает о `std::string_view`,\
поэтому мы передаем ей функцию `str.data()`:
```c++
#include <cstring> // для функции std::strlen()
#include <iostream>
#include <string_view>

int main() {
    std::string_view str{ "balloon" };
    std::cout << str << '\n';
    // Для простоты мы воспользуемся функцией std::strlen(). Вместо нее можно
    // было бы использовать любую другую функцию, которая работает со строкой с нуль-терминатором в конце.
    // Здесь мы можем использовать функцию data(), так как мы не изменяли представление и строка имеет нуль-терминатор
    std::cout << std::strlen(str.data()) << '\n';

    return 0;
}

<< balloon
<< 7
```

В следующем примере показано, что происходит, когда мы обращаемся к функции\
`data()` после изменения представления строки:
```c++
#include <cstring> // для функции std::strlen()
#include <iostream>
#include <string_view>

int main() {
    std::string_view str{ "balloon" };
    // Удаляем символ "b"
    str.remove_prefix(1);
    // Удаляем часть "oon"
    str.remove_suffix(3);
    // Помните, что предыдущие 2 команды не изменяют исходную строку, они
    // работают лишь с её представлением
    std::cout << str << " has " << std::strlen(str.data()) << " letter(s)\n";
    std::cout << "str.data() is " << str.data() << '\n';
    std::cout << "str is " << str << '\n';

    return 0;
}

<< all has 6 letter(s)
<< str.data() is alloon
<< str is all
```
`std::strlen` и `std::cout` продолжают считывать символы из исходной строки до тех пор,\
пока не встретят нуль-терминатор, который находится в конце строки `baloon`.

**Предупреждение:** Используйте `std::string_view::data()` только в том случае, если\
представление `std::string_view` не было изменено и отображаемая строка\
содержит завершающий нулевой символ (нуль-терминатор). Использование\
функции `std::string_view::data()` со строкой без нуль-терминатора чревато\
возникновением ошибок.

### Нюансы `std::string_view`
```c++
std::string s{ "hello" };
std::string_view v{ "world" };

// Не работает
std::cout << (s + v) << '\n';
std::cout << (v + s) << '\n';

// Потенциально небезопасно или не то, что мы хотим получить,
// поскольку мы пытаемся использовать объект std::string_view в качестве строки C-style
std::cout << (s + v.data()) << '\n'; // helloworld
std::cout << (v.data() + s) << '\n'; // worldhello

// Приемлемо, т.к. нам нужно создать новый объект std::string, но некрасиво и нерационально
std::cout << (s + std::string{ v }) << '\n'; // helloworld
std::cout << (std::string{ v } + s) << '\n'; // worldhello
std::cout << (s + static_cast<std::string>(v)) << '\n'; // helloworld
std::cout << (static_cast<std::string>(v) + s) << '\n'; // worldhello
```

## Урок №84. Указатели
**Оператор адреса `&`** позволяет узнать, какой адрес памяти присвоен определенной\
переменной:
```c++
#include <iostream>

int main() {
    int a = 7;
    std::cout << a << '\n'; // выводим значение переменной a - 7
    std::cout << &a << '\n'; // выводим адрес памяти переменной a - 0x7ffee236f894
    
    return 0;
}
```

### Оператор разыменования `*`
**Оператор разыменования `*`** позволяет получить значение по указанному адресу:
```c++
#include <iostream>

int main() {
    int a = 7;
    std::cout << a << '\n'; // выводим значение переменной a - 7
    std::cout << &a << '\n'; // выводим адрес переменной a - 0x7ffda98f8d24
    std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a - 7

    return 0;
}
```

### Указатели
**Указатель** — это переменная, значением которой является адрес ячейки памяти.
```c++
int *iPtr; // указатель на значение типа int
double *dPtr; // указатель на значение типа double
int* iPtr3; // корректный синтаксис (допустимый, но не желательный)
int * iPtr4; // корректный синтаксис (не делайте так)
int *iPtr5, *iPtr6; // объявляем два указателя для переменных типа int
```

### Присваивание значений указателю
```c++
#include <iostream>

int main() {
    int value = 5;
    int *ptr = &value; // инициализируем ptr адресом значения переменной
    std::cout << *ptr << '\n'; // 5
    value = 2;
    std::cout << *ptr; // 2
    
    return 0;
}
```
`ptr` содержит адрес значения переменной `value`, и, можно сказать, `ptr` указывает на это значение:
![](./images/memory_address.png "Указатели")


```c++
    std::cout << &value << '\n'; // выводим адрес значения переменной value - 0x7ffdf2ddefcc
    std::cout << ptr << '\n'; // выводим адрес, который хранит ptr - 0x7ffdf2ddefcc
```

Тип указателя должен соответствовать типу переменной, на которую он указывает:
```c++
int iValue = 7;
double dValue = 9.0;
int *iPtr = &iValue; // ок
double *dPtr = &dValue; // ок
iPtr = &dValue; // неправильно: указатель типа int не может указывать на адрес переменной типа double
dPtr = &iValue; // неправильно: указатель типа double не может указывать на адрес переменной типа int
```

Указатели могут содержать только адреса, а целочисленный литерал 7 не имеет адреса памяти,\
из-за этого следующее не является допустимым:
```c++
int *ptr = 7;
```

Язык C++ также не позволит вам напрямую присваивать адреса памяти указателю:
```c++
double *dPtr = 0x0012FF7C; // не ок: рассматривается как присваивание целочисленного литерала
```

### Оператор адреса возвращает указатель
Стоит отметить, что оператор адреса `&` не возвращает адрес своего операнда в\
качестве литерала. Вместо этого он возвращает указатель, содержащий адрес\
операнда, тип которого получен из аргумента:
```c++
#include <iostream>

int main() {
    int value(4);
    std::cout << typeid(&value).name(); // Pi

    return 0;
}
```

### Разыменование указателей
```c++
#include <iostream>

int main() {
    int value{5};
    std::cout << &value << std::endl; // выводим адрес value - 0x7ffee21f238c
    std::cout << value << std::endl; // выводим содержимое value - 5

    int *ptr = &value; // ptr указывает на value
    std::cout << ptr << std::endl; // выводим адрес, который хранится в ptr, т.е. &value - 0x7ffee21f238c
    std::cout << *ptr << std::endl; // разыменовываем ptr (получаем значение на которое указывает ptr) - 5

    return 0;
}
```

Одному указателю можно присваивать разные значения:
```c++
int value1 = 5;
int value2 = 7;
int *ptr;
ptr = &value1; // ptr указывает на value1
std::cout << *ptr; // выведется 5
ptr = &value2; // ptr теперь указывает на value2
std::cout << *ptr; // выведется 7
```

Когда адрес значения переменной присвоен указателю, то выполняется следующее:
* `ptr` — это то же самое, что и `&value`;
* `*ptr` обрабатывается так же, как и `value`.

Поскольку `*ptr` обрабатывается так же, как и `value`, то мы можем присваивать\
ему значения так, как если бы это была обычная переменная. Например:
```c++
int value = 5;
int *ptr = &value; // ptr указывает на value
*ptr = 7; // *ptr - это то же самое, что и value, которому мы присвоили значение 7
std::cout << value; // выведется 7
```

### В чём польза указателей?
Указатели полезны в следующих случаях:
* **Случай №1: Массивы реализованы с помощью указателей.** Указатели могут\
  использоваться для итерации по массиву.
* **Случай №2: Они являются единственным способом динамического\
  выделения памяти в C++.** Это, безусловно, самый распространенный вариант\
  использования указателей.
* **Случай №3: Они могут использоваться для передачи большого количества\
  данных в функцию без копирования этих данных.**
* **Случай №4: Они могут использоваться для передачи одной функции в\
  качестве параметра другой функции.**
* **Случай №5: Они используются для достижения полиморфизма при работе с\
  наследованием.**
* **Случай №6: Они могут использоваться для представления одной\
  структуры/класса в другой структуре/классе, формируя, таким образом,\
  целые цепочки.**

### Резюме
Указатели — это переменные, которые содержат адреса памяти. Их можно\
разыменовать с помощью оператора разыменования `*` для извлечения значений,\
хранимых по адресу памяти. Разыменование указателя, значением которого\
является мусор, приведет к сбою в вашей программе.

**Совет:** При объявлении указателя указывайте звёздочку возле имени\
переменной.

### Тест
**Задание №1.**
```c++
#include <iostream>

int main() {
    short value = 7; // &value = 0x7fff193d623c
    short otherValue = 3; // &otherValue = 0x7fff193d623e

    short *ptr = &value;

    std::cout << &value << '\n'; // 0x7fff193d623c
    std::cout << value << '\n'; // 7
    std::cout << ptr << '\n'; // 0x7fff193d623c
    std::cout << *ptr << '\n'; // 7
    std::cout << '\n';

    *ptr = 9;

    std::cout << &value << '\n'; // 0x7fff193d623c
    std::cout << value << '\n'; // 9
    std::cout << ptr << '\n'; // 0x7fff193d623c
    std::cout << *ptr << '\n'; // 9
    std::cout << '\n';

    ptr = &otherValue;

    std::cout << &otherValue << '\n';  // 0x7fff193d623e
    std::cout << otherValue << '\n'; // 3
    std::cout << ptr << '\n'; // 0x7fff193d623e
    std::cout << *ptr << '\n'; // 3
    std::cout << '\n';

    std::cout << sizeof(ptr) << '\n'; // 8 - размер в байтах для 64 разрядной системы
    std::cout << sizeof(*ptr) << '\n'; // 2 - тип short составляет 2 байта

    return 0;
}
```

****Задание №2.****\
Что не так со следующим фрагментом кода:
```c++
int value = 45;
int *ptr = &value; // объявляем указатель и инициализируем его адресом переменной value
*ptr = &value; // присваиваем адрес value для ptr
```

В третьей строке звёздочка уже является оператором разыменования, и\
используется для вытаскивания значения, на которое указывает указатель.\
Таким образом, эта строка говорит: «Вытаскиваем значение, на которое\
указывает `ptr` (целочисленное значение), и переписываем его на адрес этого же\
значения». А это уже какая-то чепуха — вы не можете присвоить адрес\
целочисленному значению!

Должно быть:
```c++
    ptr = &value;
```

## Урок №85. Нулевые указатели
### Нулевое значение и нулевые указатели
**Нулевое значение** (или **"значение `null`"**) — это специальное значение,\
которое означает, что указатель ни на что не указывает. Указатель, содержащий\
значение `null`, называется **нулевым указателем**.
```c++
int *ptr(0); // ptr теперь нулевой указатель

int *ptr1; // ptr1 не инициализирован
ptr1 = 0; // ptr1 теперь нулевой указатель
```

**Совет:** Инициализируйте указатели нулевым значением, если не собираетесь\
присваивать им другие значения.

### Макрос `NULL`
```c++
int *ptr(NULL); // присваиваем адрес 0 указателю ptr
```
**Не рекомендуется использовать.**

### Ключевое слово `nullptr` в C++11
Начиная с C++11, при работе с нулевыми указателями, использование `nullptr`\
является более предпочтительным вариантом, нежели использование `0`:
```c++
// примечание: ptr по-прежнему остается указателем типа int, просто со значением null (0)
int *ptr = nullptr; 
```

```c++
#include <iostream>

void doAnything(int *ptr) {
    if (ptr)
        std::cout << "You passed in " << *ptr << '\n';
    else
        std::cout << "You passed in a null pointer\n";
}

int main() {
    // теперь аргумент является точно нулевым указателем, а не целочисленным значением
    doAnything(nullptr); // You passed in a null pointer

    return 0;
}
```

**Совет: В C++11 используйте `nullptr` для инициализации нулевых указателей.**

### Тип данных `std::nullptr_t` в C++11
В C++11 добавили новый тип данных `std::nullptr_t`, который находится в\
заголовочном файле `cstddef`. `std::nullptr_t` может иметь только одно\
значение — `nullptr`:
```c++
#include <iostream>

void doAnything(std::nullptr_t *ptr) {
    if (ptr)
        std::cout << "You passed in " << *ptr << '\n';
    else
        std::cout << "You passed in a null pointer\n";
}

int main() {
    // вызов функции doAnything() с аргументом типа std::nullptr_t
    doAnything(nullptr);

    return 0;
}
```

## Урок №86. Указатели и массивы
### Сходства между указателями и массивами
Переменная array содержит адрес первого элемента массива, как если бы это был\
указатель:
```c++
#include <iostream>

int main() {
    int array[4] = { 5, 8, 6, 4 };
    // Выводим значение массива (переменной array)
    std::cout << "The array has address: " << array << '\n'; // 0x7ffe2200bb00
    // Выводим адрес элемента массива
    std::cout << "Element 0 has address: " << &array[0] << '\n'; // 0x7ffe2200bb00

    return 0;
}
```

Разыменование массива:
```c++
int array[4] = { 5, 8, 6, 4 };
std::cout << *array << '\n';  // 5

char name[] = "Kirill";
std::cout << *name; // K
```

Обратите внимание, мы не разыменовываем фактический массив. Массив (типа\
`int[4]`) неявно конвертируется в указатель (типа `int *`), и мы разыменовываем\
указатель, который указывает на значение первого элемента массива.

Также мы можем создать указатель и присвоить ему `array`:
```c++
#include <iostream>

int main() {
    int array[4] = { 5, 8, 6, 4 };
    std::cout << *array; // выведется 5

    int *ptr = array;
    std::cout << *ptr; // выведется 5

    return 0;
}
```
Это работает из-за того, что переменная array распадается в указатель типа\
`int *`, а тип нашего указателя такой же (т.е. `int *`).

### Различия между указателями и массивами
При использовании в фиксированном массиве, оператор `sizeof`\
возвращает размер всего массива (`длина массива * размер элемента`). При\
использовании с указателем, оператор sizeof возвращает размер адреса памяти\
(в байтах). Например:
```c++
#include <iostream>

int main() {
    int array[4] = {5, 8, 6, 4};
    std::cout << sizeof(array) << '\n'; // выведется sizeof(int) * длина array - 16
    int *ptr = array;
    std::cout << sizeof(ptr) << '\n'; // выведется размер указателя - 8
    return 0;
}
```
Фиксированный массив знает свою длину, а указатель на массив — нет.

### Передача массивов в функции
```c++
#include <iostream>

void printSize(int *array) {
    // Здесь массив рассматривается как указатель
    std::cout << sizeof(array) << '\n'; // выведется размер указателя, а не длина массива!
}

int main() {
    int array[] = {1, 2, 3, 4, 4, 9, 15, 25};
    std::cout << sizeof(array) << '\n'; // выведется sizeof(int) * длина массива - 32
    printSize(array); // здесь аргумент array распадается на указатель - 8
    return 0;
}
```

C++ неявно конвертирует параметр из синтаксиса массива (`[]`) в синтаксис\
указателя (`*`). Это означает, что следующие два объявления функции идентичны:
```c++
void printSize(int array[]);
void printSize(int *array);
```

**Совет:** Используйте синтаксис указателя (`*`) вместо синтаксиса массива (`[]`) при\
передаче массивов в качестве параметров в функции.

### Передача по адресу
```c++
#include <iostream>

// Параметр ptr содержит копию адреса массива
void changeArray(int *ptr) {
    *ptr = 5; // поэтому изменение элемента массива приведет к изменению фактического массива
}

int main() {
    int array[] = {1, 2, 3, 4, 4, 9, 15, 25};
    std::cout << "Element 0 has value: " << array[0] << '\n'; // 1
    changeArray(array);
    std::cout << "Element 0 has value: " << array[0] << '\n'; // 5

    return 0;
}
```

## Урок №87. Адресная арифметика и индексация массивов
### Адресная арифметика
Обратите внимание, `ptr + 1` не возвращает следующий любой адрес памяти,\
который находится сразу после `ptr`, но он возвращает адрес памяти следующего\
объекта, тип которого совпадает с типом значения, на которое указывает `ptr`.\
Если ptr указывает на адрес памяти целочисленного значения (размер которого 4\
байта), то `ptr + 3` будет возвращать адрес памяти третьего целочисленного\
значения после `ptr`. Если `ptr` указывает на адрес памяти значения **типа `char`**, то\
`ptr + 3` будет возвращать адрес памяти третьего значения типа `char` после `ptr`.

При вычислении результата выражения **адресной арифметики** (или "**арифметики\
с указателями**") компилятор всегда умножает целочисленный операнд на размер\
объекта, на который указывает указатель. Например:
```c++
#include <iostream>

int main() {
    short value = 8;
    short *ptr = &value;

    // каждый последующий адрес увеличивается на 2, так как
    // размер типа short составляет 2 байта
    std::cout << ptr << '\n'; // 0x7fff387ddf5e
    std::cout << ptr+1 << '\n'; // 0x7fff387ddf60
    std::cout << ptr+2 << '\n'; // 0x7fff387ddf62
    std::cout << ptr+3 << '\n'; // 0x7fff387ddf64a

    return 0;
}
```

### Расположение элементов массива в памяти
```c++
#include <iostream>

int main() {
    int array[] = { 7, 8, 2, 4, 5 };
    
    // Используя оператор адреса &, мы можем легко определить, что элементы массива
    // расположены в памяти последовательно
    std::cout << "Element 0 is at address: " << &array[0] << '\n'; // 0x7fffe2dc1020
    std::cout << "Element 1 is at address: " << &array[1] << '\n'; // 0x7fffe2dc1024
    std::cout << "Element 2 is at address: " << &array[2] << '\n'; // 0x7fffe2dc1028
    std::cout << "Element 3 is at address: " << &array[3] << '\n'; // 0x7fffe2dc102c

    return 0;
}
```

### Индексация массивов
Можно предположить, что добавление единицы к идентификатору массива\
приведет к возврату адреса памяти второго элемента (элемента под индексом 1) массива.
```c++
#include <iostream>

int main() {
    int array [5] = { 7, 8, 2, 4, 5 };

    std::cout << &array[1] << '\n'; // выведется адрес памяти элемента под индексом 1 - 0x7fff0152adf4
    std::cout << array+1 << '\n'; // выведется адрес памяти указателя на массив + 1 - 0x7fff0152adf4

    std::cout << array[1] << '\n'; // выведется 8
    std::cout << *(array+1) << '\n'; // выведется 8 (обратите внимание на скобки, они здесь обязательны,
    // поскольку оператор * имеет более высокий приоритет, чем оператор +)

    return 0;
}
```

Оказывается, когда компилятор видит оператор индекса `[]`, он, на самом деле,\
конвертирует его в указатель с операцией сложения и разыменования! То есть,\
`array[n]` — это то же самое, что и `*(array + n)`, где `n` является целочисленным\
значением. Оператор индекса `[]` используется в целях удобства, чтобы не нужно\
было всегда помнить о скобках.

### Использование указателя для итерации по массиву
```c++
#include <iostream>

int main() {
    const int arrayLength = 9;
    char name[arrayLength] = "Jonathan";
    int numVowels(0);
    for (char *ptr = name; ptr < name + arrayLength; ++ptr) {
        switch (*ptr)
        {
            case 'A':
            case 'a':
            case 'E':
            case 'e':
            case 'I':
            case 'i':
            case 'O':
            case 'o':
            case 'U':
            case 'u':
                ++numVowels;
        }
    }

    std::cout << name << " has " << numVowels << " vowels.\n"; // Jonathan has 3 vowels.

    return 0;
}

```
Как это работает? Программа использует указатель для прогона каждого элемента\
массива поочередно. Помните, что массив распадается в указатель на первый\
элемент массива? Поэтому, присвоив `name` для `ptr`, сам `ptr` стал указывать на\
первый элемент массива. Каждый элемент разыменовывается с помощью\
выражения `switch`, и, если текущий элемент массива является гласной буквой, то\
`numVowels` увеличивается. Для перемещения указателя на следующий символ\
(элемент) массива в цикле `for` используется оператор `++`. Работа цикла завершится,\
когда все символы будут проверены.

## Урок №88. Символьные константы строк C-style
Еще один способ создания символьных констант строк `C-style` — через указатели:
```c++
#include <iostream>

int main() {
    const char *myName = "Kirill";  // вместо char myName[] = "Kirill";
    std::cout << myName; // Kirill

    return 0;
}
```

```c++
const char* getName() {
    return "Kirill";
}
```
В фрагменте, приведенном выше, функция `getName()` возвращает указатель на\
строку C-style `Kirill`. Всё хорошо, так как `Kirill` не выходит из области видимости,\
когда `getName()` завершает свое выполнение, поэтому вызывающий объект все\
равно имеет доступ к строке.

### `std::cout` и указатели типа `char`
```c++
#include <iostream>

int main() {
    int nArray[5] = { 9, 7, 5, 3, 1 };
    char cArray[] = "Hello!";
    const char *name = "John";

    std::cout << nArray << '\n'; // nArray распадается в указатель типа int - 0x7ffed3c6fd90
    std::cout << cArray << '\n'; // cArray распадается в указатель типа char - Hello!
    std::cout << name << '\n'; // name уже и так является указателем типа char - John

    return 0;
}
```

## Урок №89. Динамическое выделение памяти
Язык С++ поддерживает три основных типа **выделения** (или **"распределения"**)\
**памяти**, с двумя из которых, мы уже знакомы:
* **Статическое выделение памяти** выполняется для статических и глобальных\
  переменных. Память выделяется один раз (при запуске программы) и\
  сохраняется на протяжении работы всей программы.
* **Автоматическое выделение памяти** выполняется для параметров функции и\
  локальных переменных. Память выделяется при входе в блок, в котором\
  находятся эти переменные, и удаляется при выходе из него.
* **Динамическое выделение памяти** является темой этого урока.

### Динамическое выделение переменных
**Динамическое выделение памяти** — это способ запроса памяти из\
операционной системы запущенными программами по мере необходимости. Эта\
память не выделяется из ограниченной памяти стека программы, а выделяется из\
гораздо большего хранилища, управляемого операционной системой — **кучи**. На\
современных компьютерах размер кучи может составлять гигабайты памяти.

Для динамического выделения памяти одной переменной используется **оператор `new`**:
```c++
// динамически выделяем целочисленную переменную и сразу же отбрасываем результат (так как нигде его не сохраняем)
new int; 
```

Для доступа к выделенной памяти создается указатель:
```c++
// динамически выделяем целочисленную переменную и присваиваем её адрес ptr, чтобы затем иметь доступ к ней
int *ptr = new int;
```

Затем мы можем разыменовать указатель для получения значения:
```c++
*ptr = 8; // присваиваем значение 8 только что выделенной памяти
```

### Освобождение памяти
Когда вы динамически выделяете переменную, то вы также можете её\
инициализировать посредством прямой инициализации или uniform-\
инициализации (в С++11):
```c++
int *ptr1 = new int (7); // используем прямую инициализацию
int *ptr2 = new int { 8 }; // используем uniform-инициализацию
```

Когда уже всё, что требовалось, выполнено с динамически выделенной переменной\
— нужно явно указать для С++ освободить эту память. Для переменных это\
выполняется с помощью **оператора `delete`**:
```c++
// Предположим, что ptr ранее уже был выделен с помощью оператора new
delete ptr; // возвращаем память, на которую указывал ptr, обратно в операционную систему
ptr = nullptr; // делаем ptr нулевым указателем
```

Оператор `delete` на самом деле ничего не удаляет. Он просто возвращает память,\
которая была выделена ранее, обратно в операционную систему. Затем\
операционная система может переназначить эту память другому приложению (или\
этому же снова).

### Висячие указатели
Указатель, указывающий на освобожденную память, называется **висячим\
указателем**. Разыменование или удаление висячего указателя приведет к\
неожиданным результатам. Рассмотрим следующую программу:
```c++
#include <iostream>

int main() {
    int *ptr = new int; // динамически выделяем целочисленную переменную
    *ptr = 8; // помещаем значение в выделенную ячейку памяти

    delete ptr; // возвращаем память обратно в операционную систему, ptr теперь является висячим указателем

    std::cout << *ptr; // разыменование висячего указателя приведет к неожиданным результатам
    delete ptr; // попытка освободить память снова приведет к неожиданным результатам также

    return 0;
}
```

В программе, приведенной выше, значение `8`, которое ранее было присвоено\
динамической переменной, после освобождения может и далее находиться там, а\
может и нет. Также возможно, что освобожденная память уже могла быть выделена\
другому приложению (или для собственного использования операционной\
системы), и попытка доступа к ней приведет к тому, что операционная система\
автоматически прекратит выполнение вашей программы.

Процесс освобождения памяти может также привести и к созданию нескольких\
висячих указателей. Рассмотрим следующий пример:
```c++
#include <iostream>

int main() {
    int *ptr = new int; // динамически выделяем целочисленную переменную
    int *otherPtr = ptr; // otherPtr теперь указывает на ту же самую выделенную память, что и ptr

    delete ptr; // возвращаем память обратно в операционную систему. ptr и otherPtr теперь висячие указатели

    ptr = 0; // ptr теперь уже nullptr
    // Однако, otherPtr по-прежнему является висячим указателем!

    return 0;
}
```

**Правило: Присваивайте удаленным указателям значение 0 (или nullptr в C++11),\
если они не выходят из области видимости сразу же после удаления.**

### Оператор `new`
Альтернативная форма оператора `new`, которая возвращает нулевой указатель, если\
память не может быть выделена - `std::nothrow`:
```c++
// указатель value станет нулевым, если динамическое выделение целочисленной переменной не выполнится
int *value = new (std::nothrow) int;
```

Наилучшей практикой является проверка всех запросов на выделение памяти для\
обеспечения того, что эти запросы будут выполнены успешно и память выделится:
```c++
int *value = new (std::nothrow) int; // запрос на выделение динамической памяти для целочисленного значения
if (!value) { // обрабатываем случай, когда new возвращает null (т.е. память не выделяется)
    // Обработка этого случая
    std::cout << "Could not allocate memory";
}
```

### Нулевые указатели и динамическое выделение памяти
Если `ptr` не является нулевым, то динамически выделенная переменная будет\
удалена. Если значением указателя является нуль, то ничего не произойдет.
```c++
// Если для ptr до сих пор не выделено памяти, то выделяем её
if (!ptr)
    ptr = new int;
...
delete ptr;
```

### Утечка памяти
```c++
void doSomething() {
    int *ptr = new int;
}
```
Здесь мы динамически выделяем целочисленную переменную, но никогда не\
освобождаем память через использование оператора delete. Поскольку указатели\
следуют всем тем же правилам, что и обычные переменные, то, когда функция\
завершит свое выполнение, `ptr` выйдет из области видимости. Поскольку `ptr` —\
это единственная переменная, хранящая адрес динамически выделенной\
целочисленной переменной, то, когда `ptr` уничтожится, больше не останется\
указателей на динамически выделенную память. Это означает, что программа\
«потеряет» адрес динамически выделенной памяти. И в результате эту\
динамически выделенную целочисленную переменную нельзя будет удалить.

Это называется **утечкой памяти**. Утечка памяти происходит, когда ваша программа\
теряет адрес некоторой динамически выделенной части памяти (например,\
переменной или массива), прежде чем вернуть её обратно в операционную\
систему. Когда это происходит, то программа уже не может удалить эту\
динамически выделенную память, поскольку больше не знает, где выделенная\
память находится. Операционная система также не может использовать эту память,\
поскольку считается, что она по-прежнему используется вашей программой.

Только после того, как выполнение вашей программы завершится, операционная\
система сможет очистить и вернуть всю память, которая "утекла".

Однако, возможны и другие способы, которые могут привести к утечкам памяти.\
Например, если указателю, хранящему адрес динамически выделенной памяти,\
присвоить другое значение:
```c++
int value = 7;
int *ptr = new int; // выделяем память
ptr = &value; // старый адрес утерян - произойдет утечка памяти
```

Это легко решается удалением указателя перед операцией переприсваивания:
```c++
int value = 7;
int *ptr = new int; // выделяем память
delete ptr; // возвращаем память обратно в операционную систему
ptr = &value; // переприсваиваем указателю адрес value
```

Кроме того, утечка памяти также может произойти и через двойное выделение\
памяти (можно избежать удалением указателя перед операцией переприсваивания):
```c++
int *ptr = new int;
ptr = new int; // старый адрес утерян - произойдёт утечка памяти
```

### Резюме
С помощью операторов new и delete можно динамически выделять отдельные\
переменные в программе. Динамически выделенная память не имеет области\
видимости и остается выделенной до тех пор, пока не произойдет её освобождение\
или пока программа не завершит свое выполнение. Будьте осторожны, не\
разыменовывайте висячие или нулевые указатели.

## Урок №90. Динамические массивы
### Динамические массивы
Для выделения динамического массива и работы с ним используются отдельные\
формы операторов new и delete: `new[]` и `delete[]`.
```c++
#include <iostream>

int main() {
    std::cout << "Enter a positive integer: ";
    int length;
    std::cin >> length;
    
    // Используем оператор new[] для выделения массива. 
    // Обратите внимание, переменная length не обязательно должна быть константой!
    int *array = new int[length]; 

    std::cout << "I just allocated an array of integers of length " << length << '\n';

    array[0] = 7; // присваиваем элементу под индексом 0 значение 7
    delete[] array; // используем оператор delete[] для освобождения выделенной массиву памяти
    array = nullptr;

    return 0;
}
```

### Удаление динамического массива
При удалении динамических массивов также используется форма оператора `delete`\
для массивов — `delete[]`.

### Инициализация динамических массивов
```c++
int *array = new int[length](); // инициализация динамического массива значением 0
```

```c++
int fixedArray[5] = { 9, 7, 5, 3, 1 }; // инициализируем фиксированный массив
int *array = new int[5] { 9, 7, 5, 3, 1 }; // инициализируем динамический массив
char *array = new char[] { "Hello, world!" };
```

### Тест
Напишите программу, которая:
* спрашивает у пользователя, сколько имен он хочет ввести;
* просит пользователя ввести каждое имя;
* вызывает функцию для сортировки имен в алфавитном порядке;
* выводит отсортированный список имен.

```c++
#include <iostream>
#include <string>
#include <utility> // для std::swap()

void sortArray(std::string *array, int length) {
    // Перебираем каждый элемент массива
    for (int startIndex = 0; startIndex < length; ++startIndex) {
        // smallestIndex - индекс наименьшего элемента, с которым мы столкнулись
        int smallestIndex = startIndex;
        // Ищем наименьший элемент, который остался в массиве (начиная со startIndex+1)
        for (int currentIndex = startIndex + 1; currentIndex < length; ++currentIndex) {
            // Если текущий элемент меньше нашего ранее найденного наименьшего элемента,
            if (array[currentIndex] < array[smallestIndex])
                // то тогда это новое наименьшее значение в этой итерации
                smallestIndex = currentIndex;
        }
        // Меняем местами наш начальный элемент с найденным наименьшим элементом массива
        std::swap(array[startIndex], array[smallestIndex]);
    }
}

int main() {
    std::cout << "How many names would you like to enter? ";
    int length;
    std::cin >> length;
    // Выделяем массив для хранения имен
    auto *names = new std::string[length];
    // Просим пользователя ввести все имена
    for (int i = 0; i < length; ++i) {
        std::cout << "Enter name #" << i + 1 << ": ";
        std::cin >> names[i];
    }
    
    // Сортируем массив
    sortArray(names, length);
    std::cout << "\nHere is your sorted list:\n";
    // Выводим отсортированный массив
    for (int i = 0; i < length; ++i)
        std::cout << "Name #" << i + 1 << ": " << names[i] << '\n';
    delete[] names; // не забываем использовать оператор delete[] для освобождения памяти
    names = nullptr;
    return 0;
}
```

## Урок №91. Указатели и `const`
